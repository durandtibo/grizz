{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p><code>grizz</code> is a light library to ingest and transform data in polars DataFrame. <code>grizz</code> uses an object-oriented strategy, where ingestors and transformers are building blocks that can be combined together. <code>grizz</code> can be extend to add custom DataFrame ingestors and transformers. For example, the following example shows how to change the casting of some columns.</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Cast\n&gt;&gt;&gt; transformer = Cast(columns=[\"col1\", \"col3\"], dtype=pl.Int32)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i32  \u2506 str  \u2506 i32  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"#api-stability","title":"API stability","text":"<p> While <code>grizz</code> is in development stage, no API is guaranteed to be stable from one release to the next. In fact, it is very likely that the API will change multiple times before a stable 1.0.0 release. In practice, this means that upgrading <code>grizz</code> to a new version will possibly break any code that was using the old version of <code>grizz</code>.</p>"},{"location":"#license","title":"License","text":"<p><code>grizz</code> is licensed under BSD 3-Clause \"New\" or \"Revised\" license available in LICENSE file.</p>"},{"location":"get_started/","title":"Get Started","text":"<p>It is highly recommended to install in a virtual environment to keep your system in order.</p>"},{"location":"get_started/#installing-with-pip-recommended","title":"Installing with <code>pip</code> (recommended)","text":"<p>The following command installs the latest version of the library:</p> <pre><code>pip install grizz\n</code></pre> <p>To make the package as slim as possible, only the packages required to use <code>grizz</code> are installed. It is possible to install all the optional dependencies by running the following command:</p> <pre><code>pip install 'grizz[all]'\n</code></pre>"},{"location":"get_started/#installing-from-source","title":"Installing from source","text":"<p>To install <code>grizz</code> from source, you can follow the steps below. First, you will need to install <code>poetry</code>. <code>poetry</code> is used to manage and install the dependencies. If <code>poetry</code> is already installed on your machine, you can skip this step. There are several ways to install <code>poetry</code> so you can use the one that you prefer. You can check the <code>poetry</code> installation by running the following command:</p> <pre><code>poetry --version\n</code></pre> <p>Then, you can clone the git repository:</p> <pre><code>git clone git@github.com:durandtibo/grizz.git\n</code></pre> <p>It is recommended to create a Python 3.8+ virtual environment. This step is optional so you can skip it. To create a virtual environment, you can use the following command:</p> <pre><code>make conda\n</code></pre> <p>It automatically creates a conda virtual environment. When the virtual environment is created, you can activate it with the following command:</p> <pre><code>conda activate grizz\n</code></pre> <p>This example uses <code>conda</code> to create a virtual environment, but you can use other tools or configurations. Then, you should install the required package to use <code>grizz</code> with the following command:</p> <pre><code>make install\n</code></pre> <p>This command will install all the required packages. You can also use this command to update the required packages. This command will check if there is a more recent package available and will install it. Finally, you can test the installation with the following command:</p> <pre><code>make unit-test-cov\n</code></pre>"},{"location":"refs/exporter/","title":"exporter","text":""},{"location":"refs/exporter/#grizz.exporter","title":"grizz.exporter","text":"<p>Contain DataFrame exporters.</p>"},{"location":"refs/exporter/#grizz.exporter.BaseExporter","title":"grizz.exporter.BaseExporter","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to implement a DataFrame exporter.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.exporter import ParquetExporter\n&gt;&gt;&gt; exporter = ParquetExporter(path=\"/path/to/frame.parquet\")\n&gt;&gt;&gt; exporter\nParquetExporter(path=/path/to/frame.parquet)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; exporter.export(frame)  # doctest: +SKIP\n</code></pre>"},{"location":"refs/exporter/#grizz.exporter.BaseExporter.export","title":"grizz.exporter.BaseExporter.export  <code>abstractmethod</code>","text":"<pre><code>export(frame: DataFrame) -&gt; None\n</code></pre> <p>Export a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to export.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.exporter import ParquetExporter\n&gt;&gt;&gt; exporter = ParquetExporter(path=\"/path/to/frame.parquet\")\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; exporter.export(frame)  # doctest: +SKIP\n</code></pre>"},{"location":"refs/exporter/#grizz.exporter.CsvExporter","title":"grizz.exporter.CsvExporter","text":"<p>               Bases: <code>BaseExporter</code></p> <p>Implement a CSV DataFrame exporter.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The path to the csv file to ingest.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for <code>polars.DataFrame.write_csv</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.exporter import CsvExporter\n&gt;&gt;&gt; exporter = CsvExporter(path=\"/path/to/frame.csv\")\n&gt;&gt;&gt; exporter\nCsvExporter(path=/path/to/frame.csv)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; exporter.export(frame)  # doctest: +SKIP\n</code></pre>"},{"location":"refs/exporter/#grizz.exporter.InMemoryExporter","title":"grizz.exporter.InMemoryExporter","text":"<p>               Bases: <code>BaseExporter</code>, <code>BaseIngestor</code></p> <p>Implement an in-memory DataFrame exporter and ingestor.</p> Notes <p>This exporter is both exporter and ingestor as the object     stores the DataFrame.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.exporter import InMemoryExporter\n&gt;&gt;&gt; exporter = InMemoryExporter()\n&gt;&gt;&gt; exporter\nInMemoryExporter(frame=None)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; exporter.export(frame)\n&gt;&gt;&gt; df = exporter.ingest()\n&gt;&gt;&gt; df\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/exporter/#grizz.exporter.ParquetExporter","title":"grizz.exporter.ParquetExporter","text":"<p>               Bases: <code>BaseExporter</code></p> <p>Implement a parquet DataFrame exporter.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The path to the parquet file to ingest.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for <code>polars.DataFrame.write_parquet</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.exporter import ParquetExporter\n&gt;&gt;&gt; exporter = ParquetExporter(path=\"/path/to/frame.parquet\")\n&gt;&gt;&gt; exporter\nParquetExporter(path=/path/to/frame.parquet)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; exporter.export(frame)  # doctest: +SKIP\n</code></pre>"},{"location":"refs/exporter/#grizz.exporter.TransformExporter","title":"grizz.exporter.TransformExporter","text":"<p>               Bases: <code>BaseExporter</code></p> <p>Implement an exporter that transforms the DataFrame before to export it.</p> <p>Parameters:</p> Name Type Description Default <code>transformer</code> <code>BaseTransformer | dict</code> <p>The <code>polars.DataFrame</code> transformer or its configuration.</p> required <code>exporter</code> <code>BaseExporter | dict</code> <p>The DataFrame exporter or its configuration.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.exporter import TransformExporter, ParquetExporter\n&gt;&gt;&gt; from grizz.transformer import Cast\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; exporter = TransformExporter(\n...     transformer=Cast(columns=[\"col1\", \"col3\"], dtype=pl.Float32),\n...     exporter=ParquetExporter(path=\"/path/to/frame.parquet\"),\n... )\n&gt;&gt;&gt; exporter\nTransformExporter(\n  (transformer): CastTransformer(columns=('col1', 'col3'), dtype=Float32, exclude_columns=(), missing_policy='raise')\n  (exporter): ParquetExporter(path=/path/to/frame.parquet)\n)\n&gt;&gt;&gt; exporter.export(frame)  # doctest: +SKIP\n</code></pre>"},{"location":"refs/exporter/#grizz.exporter.is_exporter_config","title":"grizz.exporter.is_exporter_config","text":"<pre><code>is_exporter_config(config: dict) -&gt; bool\n</code></pre> <p>Indicate if the input configuration is a configuration for a <code>BaseExporter</code>.</p> <p>This function only checks if the value of the key  <code>_target_</code> is valid. It does not check the other values. If <code>_target_</code> indicates a function, the returned type hint is used to check the class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input configuration is a configuration for a <code>BaseExporter</code> object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.exporter import is_exporter_config\n&gt;&gt;&gt; is_exporter_config(\n...     {\"_target_\": \"grizz.exporter.ParquetExporter\", \"path\": \"/path/to/data.parquet\"}\n... )\nTrue\n</code></pre>"},{"location":"refs/exporter/#grizz.exporter.setup_exporter","title":"grizz.exporter.setup_exporter","text":"<pre><code>setup_exporter(\n    exporter: BaseExporter | dict,\n) -&gt; BaseExporter\n</code></pre> <p>Set up an exporter.</p> <p>The exporter is instantiated from its configuration by using the <code>BaseExporter</code> factory function.</p> <p>Parameters:</p> Name Type Description Default <code>exporter</code> <code>BaseExporter | dict</code> <p>A exporter or its configuration.</p> required <p>Returns:</p> Type Description <code>BaseExporter</code> <p>An instantiated exporter.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.exporter import setup_exporter\n&gt;&gt;&gt; exporter = setup_exporter(\n...     {\"_target_\": \"grizz.exporter.ParquetExporter\", \"path\": \"/path/to/data.parquet\"}\n... )\n&gt;&gt;&gt; exporter\nParquetExporter(path=/path/to/data.parquet)\n</code></pre>"},{"location":"refs/ingestor/","title":"ingestor","text":""},{"location":"refs/ingestor/#grizz.ingestor","title":"grizz.ingestor","text":"<p>Contain DataFrame ingestors.</p>"},{"location":"refs/ingestor/#grizz.ingestor.BaseIngestor","title":"grizz.ingestor.BaseIngestor","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to implement a DataFrame ingestor.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.ingestor import ParquetIngestor\n&gt;&gt;&gt; ingestor = ParquetIngestor(path=\"/path/to/frame.parquet\")\n&gt;&gt;&gt; ingestor\nParquetIngestor(path=/path/to/frame.parquet)\n&gt;&gt;&gt; frame = ingestor.ingest()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/ingestor/#grizz.ingestor.BaseIngestor.ingest","title":"grizz.ingestor.BaseIngestor.ingest  <code>abstractmethod</code>","text":"<pre><code>ingest() -&gt; DataFrame\n</code></pre> <p>Ingest a DataFrame.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The ingested DataFrame.</p> <p>Raises:</p> Type Description <code>DataFrameNotFoundError</code> <p>if the DataFrame cannot be ingested.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.ingestor import ParquetIngestor\n&gt;&gt;&gt; ingestor = ParquetIngestor(path=\"/path/to/frame.parquet\")\n&gt;&gt;&gt; frame = ingestor.ingest()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/ingestor/#grizz.ingestor.CacheIngestor","title":"grizz.ingestor.CacheIngestor","text":"<p>               Bases: <code>BaseIngestor</code></p> <p>Implement an ingestor that attempts the fast ingestor first, falling back to the slow ingestor if needed.</p> <p>Internally, this ingestor attempts to load the DataFrame using the fast ingestor. If a DataFrameNotFoundError is raised, it falls back to the slow ingestor, then exports the DataFrame for ingestion by the fast ingestor during the next cycle.</p> <p>Parameters:</p> Name Type Description Default <code>ingestor_slow</code> <code>BaseIngestor | dict</code> <p>The slow DataFrame ingestor or its configuration.</p> required <code>ingestor_fast</code> <code>BaseIngestor | dict</code> <p>The fast DataFrame ingestor or its configuration.</p> required <code>exporter</code> <code>BaseExporter | dict</code> <p>The DataFrame exporter or its configuration. The DataFrame exporter is responsible for storing the output of the slower DataFrame ingestor, allowing it to be ingested by the faster DataFrame ingestor during the next ingestion cycle.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.ingestor import CacheIngestor, Ingestor\n&gt;&gt;&gt; from grizz.exporter import InMemoryExporter\n&gt;&gt;&gt; ingestor_slow = Ingestor(\n...     pl.DataFrame(\n...         {\n...             \"col1\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...             \"col2\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...             \"col3\": [1.2, 2.2, 3.2, 4.2, 5.2],\n...         }\n...     )\n... )\n&gt;&gt;&gt; exporter_ingestor = InMemoryExporter()\n&gt;&gt;&gt; ingestor = CacheIngestor(\n...     ingestor_slow=ingestor_slow,\n...     ingestor_fast=exporter_ingestor,\n...     exporter=exporter_ingestor,\n... )\n&gt;&gt;&gt; ingestor\nCacheIngestor(\n  (ingestor_slow): Ingestor(shape=(5, 3))\n  (ingestor_fast): InMemoryExporter(frame=None)\n  (exporter): InMemoryExporter(frame=None)\n)\n&gt;&gt;&gt; frame = ingestor.ingest()\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 str  \u2506 str  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 a    \u2506 1.2  \u2502\n\u2502 2    \u2506 b    \u2506 2.2  \u2502\n\u2502 3    \u2506 c    \u2506 3.2  \u2502\n\u2502 4    \u2506 d    \u2506 4.2  \u2502\n\u2502 5    \u2506 e    \u2506 5.2  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/ingestor/#grizz.ingestor.ClickHouseIngestor","title":"grizz.ingestor.ClickHouseIngestor","text":"<p>               Bases: <code>BaseIngestor</code></p> <p>Implement a clickhouse DataFrame ingestor.</p> <p>This ingestor requires <code>clickhouse_connect</code> and <code>pyarrow</code>.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query to get the data.</p> required <code>client</code> <code>Client | dict</code> <p>The clickhouse client or its configuration. Please check the documentation of <code>clickhouse_connect.get_client</code> to get more information.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.ingestor import ClickHouseIngestor\n&gt;&gt;&gt; import clickhouse_connect\n&gt;&gt;&gt; client = clickhouse_connect.get_client()  # doctest: +SKIP\n&gt;&gt;&gt; ingestor = ClickHouseIngestor(query=\"\", client=client)  # doctest: +SKIP\n&gt;&gt;&gt; frame = ingestor.ingest()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/ingestor/#grizz.ingestor.CsvIngestor","title":"grizz.ingestor.CsvIngestor","text":"<p>               Bases: <code>BaseIngestor</code></p> <p>Implement a CSV DataFrame ingestor.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The path to the CSV file to ingest.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for <code>polars.read_csv</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.ingestor import CsvIngestor\n&gt;&gt;&gt; ingestor = CsvIngestor(path=\"/path/to/frame.csv\")\n&gt;&gt;&gt; ingestor\nCsvIngestor(path=/path/to/frame.csv)\n&gt;&gt;&gt; frame = ingestor.ingest()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/ingestor/#grizz.ingestor.Ingestor","title":"grizz.ingestor.Ingestor","text":"<p>               Bases: <code>BaseIngestor</code></p> <p>Implement a simple DataFrame ingestor.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to ingest.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.ingestor import Ingestor\n&gt;&gt;&gt; ingestor = Ingestor(\n...     frame=pl.DataFrame(\n...         {\n...             \"col1\": [1, 2, 3, 4, 5],\n...             \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...             \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...             \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...         }\n...     )\n... )\n&gt;&gt;&gt; ingestor\nIngestor(shape=(5, 4))\n&gt;&gt;&gt; frame = ingestor.ingest()\n</code></pre>"},{"location":"refs/ingestor/#grizz.ingestor.ParquetIngestor","title":"grizz.ingestor.ParquetIngestor","text":"<p>               Bases: <code>BaseIngestor</code></p> <p>Implement a parquet DataFrame ingestor.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The path to the parquet file to ingest.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for <code>polars.read_parquet</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.ingestor import ParquetIngestor\n&gt;&gt;&gt; ingestor = ParquetIngestor(path=\"/path/to/frame.parquet\")\n&gt;&gt;&gt; ingestor\nParquetIngestor(path=/path/to/frame.parquet)\n&gt;&gt;&gt; frame = ingestor.ingest()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/ingestor/#grizz.ingestor.TransformIngestor","title":"grizz.ingestor.TransformIngestor","text":"<p>               Bases: <code>BaseIngestor</code></p> <p>Implement an ingestor that also transforms the DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>ingestor</code> <code>BaseIngestor | dict</code> <p>The base ingestor.</p> required <code>transformer</code> <code>BaseTransformer | dict</code> <p>The <code>polars.DataFrame</code> transformer or its configuration.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.ingestor import TransformIngestor, Ingestor\n&gt;&gt;&gt; from grizz.transformer import Cast\n&gt;&gt;&gt; ingestor = TransformIngestor(\n...     ingestor=Ingestor(\n...         pl.DataFrame(\n...             {\n...                 \"col1\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...                 \"col2\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...                 \"col3\": [1.2, 2.2, 3.2, 4.2, 5.2],\n...             }\n...         )\n...     ),\n...     transformer=Cast(columns=[\"col1\", \"col3\"], dtype=pl.Float32),\n... )\n&gt;&gt;&gt; ingestor\nTransformIngestor(\n  (ingestor): Ingestor(shape=(5, 3))\n  (transformer): CastTransformer(columns=('col1', 'col3'), dtype=Float32, exclude_columns=(), missing_policy='raise')\n)\n&gt;&gt;&gt; frame = ingestor.ingest()\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 f32  \u2506 str  \u2506 f32  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0  \u2506 a    \u2506 1.2  \u2502\n\u2502 2.0  \u2506 b    \u2506 2.2  \u2502\n\u2502 3.0  \u2506 c    \u2506 3.2  \u2502\n\u2502 4.0  \u2506 d    \u2506 4.2  \u2502\n\u2502 5.0  \u2506 e    \u2506 5.2  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/ingestor/#grizz.ingestor.is_ingestor_config","title":"grizz.ingestor.is_ingestor_config","text":"<pre><code>is_ingestor_config(config: dict) -&gt; bool\n</code></pre> <p>Indicate if the input configuration is a configuration for a <code>BaseIngestor</code>.</p> <p>This function only checks if the value of the key  <code>_target_</code> is valid. It does not check the other values. If <code>_target_</code> indicates a function, the returned type hint is used to check the class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input configuration is a configuration for a <code>BaseIngestor</code> object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.ingestor import is_ingestor_config\n&gt;&gt;&gt; is_ingestor_config(\n...     {\"_target_\": \"grizz.ingestor.CsvIngestor\", \"path\": \"/path/to/data.csv\"}\n... )\nTrue\n</code></pre>"},{"location":"refs/ingestor/#grizz.ingestor.setup_ingestor","title":"grizz.ingestor.setup_ingestor","text":"<pre><code>setup_ingestor(\n    ingestor: BaseIngestor | dict,\n) -&gt; BaseIngestor\n</code></pre> <p>Set up an ingestor.</p> <p>The ingestor is instantiated from its configuration by using the <code>BaseIngestor</code> factory function.</p> <p>Parameters:</p> Name Type Description Default <code>ingestor</code> <code>BaseIngestor | dict</code> <p>An ingestor or its configuration.</p> required <p>Returns:</p> Type Description <code>BaseIngestor</code> <p>An instantiated ingestor.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.ingestor import setup_ingestor\n&gt;&gt;&gt; ingestor = setup_ingestor(\n...     {\"_target_\": \"grizz.ingestor.CsvIngestor\", \"path\": \"/path/to/data.csv\"}\n... )\n&gt;&gt;&gt; ingestor\nCsvIngestor(path=/path/to/data.csv)\n</code></pre>"},{"location":"refs/transformer/","title":"transformer","text":""},{"location":"refs/transformer/#grizz.transformer","title":"grizz.transformer","text":"<p>Contain <code>polars.DataFrame</code> transformers.</p>"},{"location":"refs/transformer/#grizz.transformer.AbsDiffHorizontal","title":"grizz.transformer.AbsDiffHorizontal","text":"<p>               Bases: <code>BaseIn2Out1Transformer</code></p> <p>Implement a transformer to compute the absolute difference between two columns.</p> <p>Internally, this tranformer computes: <code>out = abs(in1 - in2)</code></p> <p>Parameters:</p> Name Type Description Default <code>in1_col</code> <code>str</code> <p>The first input column name.</p> required <code>in2_col</code> <code>str</code> <p>The second input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import AbsDiffHorizontal\n&gt;&gt;&gt; transformer = AbsDiffHorizontal(in1_col=\"col1\", in2_col=\"col2\", out_col=\"diff\")\n&gt;&gt;&gt; transformer\nAbsDiffHorizontalTransformer(in1_col='col1', in2_col='col2', out_col='diff', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [5, 4, 3, 2, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 diff \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2506 4    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2506 2    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506 0    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2506 2    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2506 4    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.AbsDiffHorizontalTransformer","title":"grizz.transformer.AbsDiffHorizontalTransformer","text":"<p>               Bases: <code>BaseIn2Out1Transformer</code></p> <p>Implement a transformer to compute the absolute difference between two columns.</p> <p>Internally, this tranformer computes: <code>out = abs(in1 - in2)</code></p> <p>Parameters:</p> Name Type Description Default <code>in1_col</code> <code>str</code> <p>The first input column name.</p> required <code>in2_col</code> <code>str</code> <p>The second input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import AbsDiffHorizontal\n&gt;&gt;&gt; transformer = AbsDiffHorizontal(in1_col=\"col1\", in2_col=\"col2\", out_col=\"diff\")\n&gt;&gt;&gt; transformer\nAbsDiffHorizontalTransformer(in1_col='col1', in2_col='col2', out_col='diff', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [5, 4, 3, 2, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 diff \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2506 4    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2506 2    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506 0    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2506 2    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2506 4    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.BaseIn1Out1Transformer","title":"grizz.transformer.BaseIn1Out1Transformer","text":"<p>               Bases: <code>BaseTransformer</code></p> <p>Define a base class to implement <code>polars.DataFrame</code> transformers that takes one input column and generate one output column.</p> <p>Parameters:</p> Name Type Description Default <code>in_col</code> <code>str</code> <p>The input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code>"},{"location":"refs/transformer/#grizz.transformer.BaseIn2Out1Transformer","title":"grizz.transformer.BaseIn2Out1Transformer","text":"<p>               Bases: <code>BaseTransformer</code></p> <p>Define a base class to implement <code>polars.DataFrame</code> transformers that takes two input columns and generate one output column.</p> <p>Parameters:</p> Name Type Description Default <code>in1_col</code> <code>str</code> <p>The first input column name.</p> required <code>in2_col</code> <code>str</code> <p>The second input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import AbsDiffHorizontal\n&gt;&gt;&gt; transformer = AbsDiffHorizontal(in1_col=\"col1\", in2_col=\"col2\", out_col=\"diff\")\n&gt;&gt;&gt; transformer\nAbsDiffHorizontalTransformer(in1_col='col1', in2_col='col2', out_col='diff', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [5, 4, 3, 2, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 diff \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2506 4    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2506 2    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506 0    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2506 2    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2506 4    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.BaseInNOut1Transformer","title":"grizz.transformer.BaseInNOut1Transformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Define a base class to implement <code>polars.DataFrame</code> transformers that generate a single output column by using multiple input columns.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to prepare. If <code>None</code>, it processes all the columns.</p> required <code>out_col</code> <code>str</code> <p>The output column.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ConcatColumns\n&gt;&gt;&gt; transformer = ConcatColumns(columns=[\"col1\", \"col2\", \"col3\"], out_col=\"col\")\n&gt;&gt;&gt; transformer\nConcatColumnsTransformer(columns=('col1', 'col2', 'col3'), out_col='col', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [11, 12, 13, 14, 15],\n...         \"col2\": [21, 22, 23, 24, 25],\n...         \"col3\": [31, 32, 33, 34, 35],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11   \u2506 21   \u2506 31   \u2506 a    \u2502\n\u2502 12   \u2506 22   \u2506 32   \u2506 b    \u2502\n\u2502 13   \u2506 23   \u2506 33   \u2506 c    \u2502\n\u2502 14   \u2506 24   \u2506 34   \u2506 d    \u2502\n\u2502 15   \u2506 25   \u2506 35   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.fit_transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col          \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---          \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2506 list[i64]    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11   \u2506 21   \u2506 31   \u2506 a    \u2506 [11, 21, 31] \u2502\n\u2502 12   \u2506 22   \u2506 32   \u2506 b    \u2506 [12, 22, 32] \u2502\n\u2502 13   \u2506 23   \u2506 33   \u2506 c    \u2506 [13, 23, 33] \u2502\n\u2502 14   \u2506 24   \u2506 34   \u2506 d    \u2506 [14, 24, 34] \u2502\n\u2502 15   \u2506 25   \u2506 35   \u2506 e    \u2506 [15, 25, 35] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.BaseInNTransformer","title":"grizz.transformer.BaseInNTransformer","text":"<p>               Bases: <code>BaseTransformer</code></p> <p>Define a base class to implement <code>polars.DataFrame</code> transformers that transform DataFrames by using multiple input columns.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to prepare. If <code>None</code>, it processes all the columns.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import StripChars\n&gt;&gt;&gt; transformer = StripChars(columns=[\"col2\", \"col3\"])\n&gt;&gt;&gt; transformer\nStripCharsTransformer(columns=('col2', 'col3'), exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...         \"col4\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3  \u2506 col4  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---   \u2506 ---   \u2502\n\u2502 i64  \u2506 str  \u2506 str   \u2506 str   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 a     \u2506 a     \u2502\n\u2502 2    \u2506 2    \u2506  b    \u2506  b    \u2502\n\u2502 3    \u2506 3    \u2506   c   \u2506   c   \u2502\n\u2502 4    \u2506 4    \u2506 d     \u2506 d     \u2502\n\u2502 5    \u2506 5    \u2506 e     \u2506 e     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 a    \u2506 a     \u2502\n\u2502 2    \u2506 2    \u2506 b    \u2506  b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506   c   \u2502\n\u2502 4    \u2506 4    \u2506 d    \u2506 d     \u2502\n\u2502 5    \u2506 5    \u2506 e    \u2506 e     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.BaseInNTransformer.find_columns","title":"grizz.transformer.BaseInNTransformer.find_columns","text":"<pre><code>find_columns(frame: DataFrame) -&gt; tuple[str, ...]\n</code></pre> <p>Find the columns to transform.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The input DataFrame. Sometimes the columns to transform are found by analyzing the input DataFrame.</p> required <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>The columns to transform.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import StripChars\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...         \"col4\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; transformer = StripChars(columns=[\"col2\", \"col3\"])\n&gt;&gt;&gt; transformer.find_columns(frame)\n('col2', 'col3')\n&gt;&gt;&gt; transformer = StripChars()\n&gt;&gt;&gt; transformer.find_columns(frame)\n('col1', 'col2', 'col3', 'col4')\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.BaseInNTransformer.find_common_columns","title":"grizz.transformer.BaseInNTransformer.find_common_columns","text":"<pre><code>find_common_columns(frame: DataFrame) -&gt; tuple[str, ...]\n</code></pre> <p>Find the common columns between the DataFrame columns and the input columns.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The input DataFrame. Sometimes the columns to transform are found by analyzing the input DataFrame.</p> required <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>The common columns.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import StripChars\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...         \"col4\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; transformer = StripChars(columns=[\"col2\", \"col3\", \"col5\"])\n&gt;&gt;&gt; transformer.find_common_columns(frame)\n('col2', 'col3')\n&gt;&gt;&gt; transformer = StripChars()\n&gt;&gt;&gt; transformer.find_common_columns(frame)\n('col1', 'col2', 'col3', 'col4')\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.BaseInNTransformer.find_missing_columns","title":"grizz.transformer.BaseInNTransformer.find_missing_columns","text":"<pre><code>find_missing_columns(frame: DataFrame) -&gt; tuple[str, ...]\n</code></pre> <p>Find the missing columns.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The input DataFrame. Sometimes the columns to transform are found by analyzing the input DataFrame.</p> required <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>The missing columns.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import StripChars\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...         \"col4\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; transformer = StripChars(columns=[\"col2\", \"col3\", \"col5\"])\n&gt;&gt;&gt; transformer.find_missing_columns(frame)\n('col5',)\n&gt;&gt;&gt; transformer = StripChars()\n&gt;&gt;&gt; transformer.find_missing_columns(frame)\n()\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.BaseTransformer","title":"grizz.transformer.BaseTransformer","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to transform a <code>polars.DataFrame</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Cast\n&gt;&gt;&gt; transformer = Cast(columns=[\"col1\", \"col3\"], dtype=pl.Int32)\n&gt;&gt;&gt; transformer\nCastTransformer(columns=('col1', 'col3'), dtype=Int32, exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i32  \u2506 str  \u2506 i32  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.BaseTransformer.fit","title":"grizz.transformer.BaseTransformer.fit  <code>abstractmethod</code>","text":"<pre><code>fit(frame: DataFrame) -&gt; None\n</code></pre> <p>Fit to the data in the <code>polars.DataFrame</code>.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The <code>polars.DataFrame</code> to fit.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Cast\n&gt;&gt;&gt; transformer = Cast(columns=[\"col1\", \"col3\"], dtype=pl.Int32)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; transformer.fit(frame)\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i32  \u2506 str  \u2506 i32  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.BaseTransformer.fit_transform","title":"grizz.transformer.BaseTransformer.fit_transform  <code>abstractmethod</code>","text":"<pre><code>fit_transform(frame: DataFrame) -&gt; None\n</code></pre> <p>Fit to the data, then transform it.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The <code>polars.DataFrame</code> to fit.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The transformed DataFrame.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Cast\n&gt;&gt;&gt; transformer = Cast(columns=[\"col1\", \"col3\"], dtype=pl.Int32)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.fit_transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i32  \u2506 str  \u2506 i32  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.BaseTransformer.transform","title":"grizz.transformer.BaseTransformer.transform  <code>abstractmethod</code>","text":"<pre><code>transform(frame: DataFrame) -&gt; DataFrame\n</code></pre> <p>Transform the data in the <code>polars.DataFrame</code>.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The <code>polars.DataFrame</code> to transform.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>The transformed DataFrame.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Cast\n&gt;&gt;&gt; transformer = Cast(columns=[\"col1\", \"col3\"], dtype=pl.Int32)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i32  \u2506 str  \u2506 i32  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.Cast","title":"grizz.transformer.Cast","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to convert some columns to a new data type.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to convert. <code>None</code> means all the columns.</p> required <code>dtype</code> <code>type[DataType]</code> <p>The target data type.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>cast</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Cast\n&gt;&gt;&gt; transformer = Cast(columns=[\"col1\", \"col3\"], dtype=pl.Int32)\n&gt;&gt;&gt; transformer\nCastTransformer(columns=('col1', 'col3'), dtype=Int32, exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i32  \u2506 str  \u2506 i32  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.CastTransformer","title":"grizz.transformer.CastTransformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to convert some columns to a new data type.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to convert. <code>None</code> means all the columns.</p> required <code>dtype</code> <code>type[DataType]</code> <p>The target data type.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>cast</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Cast\n&gt;&gt;&gt; transformer = Cast(columns=[\"col1\", \"col3\"], dtype=pl.Int32)\n&gt;&gt;&gt; transformer\nCastTransformer(columns=('col1', 'col3'), dtype=Int32, exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i32  \u2506 str  \u2506 i32  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.CloseColumns","title":"grizz.transformer.CloseColumns","text":"<p>               Bases: <code>BaseIn2Out1Transformer</code></p> <p>Implement a transformer to compute a column that indicates if the values of two columns are element-wise equal within a tolerance.</p> <p>The output column contains <code>True</code> if two columns are element-wise equal within a tolerance. Internally, this tranformer computes: <code>out = (|actual - expected| &lt;= atol + rtol * |expected|)</code></p> <p>Parameters:</p> Name Type Description Default <code>actual</code> <code>str</code> <p>The actual input column name. This column must be a numeric column.</p> required <code>expected</code> <code>str</code> <p>The expected input column name. This column must be a numeric column.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>atol</code> <code>float</code> <p>The absolute tolerance parameter.</p> <code>1e-08</code> <code>rtol</code> <code>float</code> <p>The relative tolerance parameter.</p> <code>1e-05</code> <code>equal_nan</code> <code>bool</code> <p>Whether to compare NaN's as equal. If <code>True</code>, NaN's in <code>actual</code> will be considered equal to NaN's in <code>expected</code> in the output column.</p> <code>False</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import CloseColumns\n&gt;&gt;&gt; transformer = CloseColumns(actual=\"col1\", expected=\"col2\", out_col=\"out\")\n&gt;&gt;&gt; transformer\nCloseColumnsTransformer(actual='col1', expected='col2', out_col='out', atol=1e-08, rtol=1e-05, equal_nan=False, exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [5, 4, 3, 2, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 out   \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2506 false \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2506 false \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506 true  \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2506 false \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2506 false \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.CloseColumnsTransformer","title":"grizz.transformer.CloseColumnsTransformer","text":"<p>               Bases: <code>BaseIn2Out1Transformer</code></p> <p>Implement a transformer to compute a column that indicates if the values of two columns are element-wise equal within a tolerance.</p> <p>The output column contains <code>True</code> if two columns are element-wise equal within a tolerance. Internally, this tranformer computes: <code>out = (|actual - expected| &lt;= atol + rtol * |expected|)</code></p> <p>Parameters:</p> Name Type Description Default <code>actual</code> <code>str</code> <p>The actual input column name. This column must be a numeric column.</p> required <code>expected</code> <code>str</code> <p>The expected input column name. This column must be a numeric column.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>atol</code> <code>float</code> <p>The absolute tolerance parameter.</p> <code>1e-08</code> <code>rtol</code> <code>float</code> <p>The relative tolerance parameter.</p> <code>1e-05</code> <code>equal_nan</code> <code>bool</code> <p>Whether to compare NaN's as equal. If <code>True</code>, NaN's in <code>actual</code> will be considered equal to NaN's in <code>expected</code> in the output column.</p> <code>False</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import CloseColumns\n&gt;&gt;&gt; transformer = CloseColumns(actual=\"col1\", expected=\"col2\", out_col=\"out\")\n&gt;&gt;&gt; transformer\nCloseColumnsTransformer(actual='col1', expected='col2', out_col='out', atol=1e-08, rtol=1e-05, equal_nan=False, exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [5, 4, 3, 2, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 out   \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2506 false \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2506 false \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506 true  \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2506 false \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2506 false \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ColumnSelection","title":"grizz.transformer.ColumnSelection","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a <code>polars.DataFrame</code> transformer to select a subset of columns.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to keep.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ColumnSelection\n&gt;&gt;&gt; transformer = ColumnSelection(columns=[\"col1\", \"col2\"])\n&gt;&gt;&gt; transformer\nColumnSelectionTransformer(columns=('col1', 'col2'), exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [\"2020-1-1\", \"2020-1-2\", \"2020-1-31\", \"2020-12-31\", None],\n...         \"col2\": [1, 2, 3, 4, 5],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\n    shape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1       \u2506 col2 \u2502\n\u2502 ---        \u2506 ---  \u2502\n\u2502 str        \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-1-1   \u2506 1    \u2502\n\u2502 2020-1-2   \u2506 2    \u2502\n\u2502 2020-1-31  \u2506 3    \u2502\n\u2502 2020-12-31 \u2506 4    \u2502\n\u2502 null       \u2506 5    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ColumnSelectionTransformer","title":"grizz.transformer.ColumnSelectionTransformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a <code>polars.DataFrame</code> transformer to select a subset of columns.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to keep.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ColumnSelection\n&gt;&gt;&gt; transformer = ColumnSelection(columns=[\"col1\", \"col2\"])\n&gt;&gt;&gt; transformer\nColumnSelectionTransformer(columns=('col1', 'col2'), exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [\"2020-1-1\", \"2020-1-2\", \"2020-1-31\", \"2020-12-31\", None],\n...         \"col2\": [1, 2, 3, 4, 5],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\n    shape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1       \u2506 col2 \u2502\n\u2502 ---        \u2506 ---  \u2502\n\u2502 str        \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-1-1   \u2506 1    \u2502\n\u2502 2020-1-2   \u2506 2    \u2502\n\u2502 2020-1-31  \u2506 3    \u2502\n\u2502 2020-12-31 \u2506 4    \u2502\n\u2502 null       \u2506 5    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ConcatColumns","title":"grizz.transformer.ConcatColumns","text":"<p>               Bases: <code>BaseInNOut1Transformer</code></p> <p>Implement a transformer to concatenate columns into a new column.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to concatenate. The columns should have the same type or compatible types. If <code>None</code>, it processes all the columns.</p> required <code>out_col</code> <code>str</code> <p>The output column.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ConcatColumns\n&gt;&gt;&gt; transformer = ConcatColumns(columns=[\"col1\", \"col2\", \"col3\"], out_col=\"col\")\n&gt;&gt;&gt; transformer\nConcatColumnsTransformer(columns=('col1', 'col2', 'col3'), out_col='col', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [11, 12, 13, 14, 15],\n...         \"col2\": [21, 22, 23, 24, 25],\n...         \"col3\": [31, 32, 33, 34, 35],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11   \u2506 21   \u2506 31   \u2506 a    \u2502\n\u2502 12   \u2506 22   \u2506 32   \u2506 b    \u2502\n\u2502 13   \u2506 23   \u2506 33   \u2506 c    \u2502\n\u2502 14   \u2506 24   \u2506 34   \u2506 d    \u2502\n\u2502 15   \u2506 25   \u2506 35   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col          \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---          \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2506 list[i64]    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11   \u2506 21   \u2506 31   \u2506 a    \u2506 [11, 21, 31] \u2502\n\u2502 12   \u2506 22   \u2506 32   \u2506 b    \u2506 [12, 22, 32] \u2502\n\u2502 13   \u2506 23   \u2506 33   \u2506 c    \u2506 [13, 23, 33] \u2502\n\u2502 14   \u2506 24   \u2506 34   \u2506 d    \u2506 [14, 24, 34] \u2502\n\u2502 15   \u2506 25   \u2506 35   \u2506 e    \u2506 [15, 25, 35] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ConcatColumnsTransformer","title":"grizz.transformer.ConcatColumnsTransformer","text":"<p>               Bases: <code>BaseInNOut1Transformer</code></p> <p>Implement a transformer to concatenate columns into a new column.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to concatenate. The columns should have the same type or compatible types. If <code>None</code>, it processes all the columns.</p> required <code>out_col</code> <code>str</code> <p>The output column.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ConcatColumns\n&gt;&gt;&gt; transformer = ConcatColumns(columns=[\"col1\", \"col2\", \"col3\"], out_col=\"col\")\n&gt;&gt;&gt; transformer\nConcatColumnsTransformer(columns=('col1', 'col2', 'col3'), out_col='col', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [11, 12, 13, 14, 15],\n...         \"col2\": [21, 22, 23, 24, 25],\n...         \"col3\": [31, 32, 33, 34, 35],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11   \u2506 21   \u2506 31   \u2506 a    \u2502\n\u2502 12   \u2506 22   \u2506 32   \u2506 b    \u2502\n\u2502 13   \u2506 23   \u2506 33   \u2506 c    \u2502\n\u2502 14   \u2506 24   \u2506 34   \u2506 d    \u2502\n\u2502 15   \u2506 25   \u2506 35   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col          \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---          \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2506 list[i64]    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11   \u2506 21   \u2506 31   \u2506 a    \u2506 [11, 21, 31] \u2502\n\u2502 12   \u2506 22   \u2506 32   \u2506 b    \u2506 [12, 22, 32] \u2502\n\u2502 13   \u2506 23   \u2506 33   \u2506 c    \u2506 [13, 23, 33] \u2502\n\u2502 14   \u2506 24   \u2506 34   \u2506 d    \u2506 [14, 24, 34] \u2502\n\u2502 15   \u2506 25   \u2506 35   \u2506 e    \u2506 [15, 25, 35] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.CopyColumn","title":"grizz.transformer.CopyColumn","text":"<p>               Bases: <code>BaseIn1Out1Transformer</code></p> <p>Implement a <code>polars.DataFrame</code> to copy a column.</p> <p>Parameters:</p> Name Type Description Default <code>in_col</code> <code>str</code> <p>The input column name i.e. the column to copy.</p> required <code>out_col</code> <code>str</code> <p>The output column name i.e. the copied column.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import CopyColumn\n&gt;&gt;&gt; transformer = CopyColumn(in_col=\"col1\", out_col=\"out\")\n&gt;&gt;&gt; transformer\nCopyColumnTransformer(in_col='col1', out_col='out', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 --- \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2506 1   \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2506 2   \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2506 3   \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2506 4   \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2506 5   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.CopyColumnTransformer","title":"grizz.transformer.CopyColumnTransformer","text":"<p>               Bases: <code>BaseIn1Out1Transformer</code></p> <p>Implement a <code>polars.DataFrame</code> to copy a column.</p> <p>Parameters:</p> Name Type Description Default <code>in_col</code> <code>str</code> <p>The input column name i.e. the column to copy.</p> required <code>out_col</code> <code>str</code> <p>The output column name i.e. the copied column.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import CopyColumn\n&gt;&gt;&gt; transformer = CopyColumn(in_col=\"col1\", out_col=\"out\")\n&gt;&gt;&gt; transformer\nCopyColumnTransformer(in_col='col1', out_col='out', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 --- \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2506 1   \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2506 2   \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2506 3   \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2506 4   \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2506 5   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.CopyColumns","title":"grizz.transformer.CopyColumns","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to copy some columns.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to copy. <code>None</code> means all the columns.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the copied columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the copied columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import CopyColumns\n&gt;&gt;&gt; transformer = CopyColumns(columns=[\"col1\", \"col3\"], prefix=\"\", suffix=\"_raw\")\n&gt;&gt;&gt; transformer\nCopyColumnsTransformer(columns=('col1', 'col3'), prefix='', suffix='_raw', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_raw \u2506 col3_raw \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2506 i64      \u2506 str      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2506 1        \u2506 1        \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2506 2        \u2506 2        \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2506 3        \u2506 3        \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2506 4        \u2506 4        \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2506 5        \u2506 5        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.CopyColumns.check_output_columns","title":"grizz.transformer.CopyColumns.check_output_columns","text":"<pre><code>check_output_columns(frame: DataFrame) -&gt; None\n</code></pre> <p>Check if the output columns already exist.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The input DataFrame to check.</p> required"},{"location":"refs/transformer/#grizz.transformer.CopyColumnsTransformer","title":"grizz.transformer.CopyColumnsTransformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to copy some columns.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to copy. <code>None</code> means all the columns.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the copied columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the copied columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import CopyColumns\n&gt;&gt;&gt; transformer = CopyColumns(columns=[\"col1\", \"col3\"], prefix=\"\", suffix=\"_raw\")\n&gt;&gt;&gt; transformer\nCopyColumnsTransformer(columns=('col1', 'col3'), prefix='', suffix='_raw', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_raw \u2506 col3_raw \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2506 i64      \u2506 str      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2506 1        \u2506 1        \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2506 2        \u2506 2        \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2506 3        \u2506 3        \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2506 4        \u2506 4        \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2506 5        \u2506 5        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.CopyColumnsTransformer.check_output_columns","title":"grizz.transformer.CopyColumnsTransformer.check_output_columns","text":"<pre><code>check_output_columns(frame: DataFrame) -&gt; None\n</code></pre> <p>Check if the output columns already exist.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The input DataFrame to check.</p> required"},{"location":"refs/transformer/#grizz.transformer.DecimalCast","title":"grizz.transformer.DecimalCast","text":"<p>               Bases: <code>CastTransformer</code></p> <p>Implement a transformer to convert columns of type decimal to a new data type.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to convert. <code>None</code> means all the columns.</p> required <code>dtype</code> <code>type[DataType]</code> <p>The target data type.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>cast</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import DecimalCast\n&gt;&gt;&gt; transformer = DecimalCast(columns=[\"col1\", \"col2\"], dtype=pl.Float32)\n&gt;&gt;&gt; transformer\nDecimalCastTransformer(columns=('col1', 'col2'), dtype=Float32, exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [1.0, 2.0, 3.0, 4.0, 5.0],\n...         \"col3\": [1.0, 2.0, 3.0, 4.0, 5.0],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     },\n...     schema={\n...         \"col1\": pl.Int64,\n...         \"col2\": pl.Decimal,\n...         \"col3\": pl.Decimal,\n...         \"col4\": pl.String,\n...     },\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2         \u2506 col3         \u2506 col4 \u2502\n\u2502 ---  \u2506 ---          \u2506 ---          \u2506 ---  \u2502\n\u2502 i64  \u2506 decimal[*,0] \u2506 decimal[*,0] \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1            \u2506 1            \u2506 a    \u2502\n\u2502 2    \u2506 2            \u2506 2            \u2506 b    \u2502\n\u2502 3    \u2506 3            \u2506 3            \u2506 c    \u2502\n\u2502 4    \u2506 4            \u2506 4            \u2506 d    \u2502\n\u2502 5    \u2506 5            \u2506 5            \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3         \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---          \u2506 ---  \u2502\n\u2502 i64  \u2506 f32  \u2506 decimal[*,0] \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.0  \u2506 1            \u2506 a    \u2502\n\u2502 2    \u2506 2.0  \u2506 2            \u2506 b    \u2502\n\u2502 3    \u2506 3.0  \u2506 3            \u2506 c    \u2502\n\u2502 4    \u2506 4.0  \u2506 4            \u2506 d    \u2502\n\u2502 5    \u2506 5.0  \u2506 5            \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.DecimalCastTransformer","title":"grizz.transformer.DecimalCastTransformer","text":"<p>               Bases: <code>CastTransformer</code></p> <p>Implement a transformer to convert columns of type decimal to a new data type.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to convert. <code>None</code> means all the columns.</p> required <code>dtype</code> <code>type[DataType]</code> <p>The target data type.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>cast</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import DecimalCast\n&gt;&gt;&gt; transformer = DecimalCast(columns=[\"col1\", \"col2\"], dtype=pl.Float32)\n&gt;&gt;&gt; transformer\nDecimalCastTransformer(columns=('col1', 'col2'), dtype=Float32, exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [1.0, 2.0, 3.0, 4.0, 5.0],\n...         \"col3\": [1.0, 2.0, 3.0, 4.0, 5.0],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     },\n...     schema={\n...         \"col1\": pl.Int64,\n...         \"col2\": pl.Decimal,\n...         \"col3\": pl.Decimal,\n...         \"col4\": pl.String,\n...     },\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2         \u2506 col3         \u2506 col4 \u2502\n\u2502 ---  \u2506 ---          \u2506 ---          \u2506 ---  \u2502\n\u2502 i64  \u2506 decimal[*,0] \u2506 decimal[*,0] \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1            \u2506 1            \u2506 a    \u2502\n\u2502 2    \u2506 2            \u2506 2            \u2506 b    \u2502\n\u2502 3    \u2506 3            \u2506 3            \u2506 c    \u2502\n\u2502 4    \u2506 4            \u2506 4            \u2506 d    \u2502\n\u2502 5    \u2506 5            \u2506 5            \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3         \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---          \u2506 ---  \u2502\n\u2502 i64  \u2506 f32  \u2506 decimal[*,0] \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.0  \u2506 1            \u2506 a    \u2502\n\u2502 2    \u2506 2.0  \u2506 2            \u2506 b    \u2502\n\u2502 3    \u2506 3.0  \u2506 3            \u2506 c    \u2502\n\u2502 4    \u2506 4.0  \u2506 4            \u2506 d    \u2502\n\u2502 5    \u2506 5.0  \u2506 5            \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.Diff","title":"grizz.transformer.Diff","text":"<p>               Bases: <code>BaseIn1Out1Transformer</code></p> <p>Implement a transformer to compute the first discrete difference between shifted items.</p> <p>Parameters:</p> Name Type Description Default <code>in_col</code> <code>str</code> <p>The input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>shift</code> <code>int</code> <p>The number of slots to shift.</p> <code>1</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Diff\n&gt;&gt;&gt; transformer = Diff(in_col=\"col1\", out_col=\"diff\")\n&gt;&gt;&gt; transformer\nDiffTransformer(in_col='col1', out_col='diff', shift=1, exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame({\"col1\": [1, 2, 3, 4, 5], \"col2\": [\"a\", \"b\", \"c\", \"d\", \"e\"]})\n&gt;&gt;&gt; frame\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2502\n\u2502 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 a    \u2502\n\u2502 2    \u2506 b    \u2502\n\u2502 3    \u2506 c    \u2502\n\u2502 4    \u2506 d    \u2502\n\u2502 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 diff \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 a    \u2506 null \u2502\n\u2502 2    \u2506 b    \u2506 1    \u2502\n\u2502 3    \u2506 c    \u2506 1    \u2502\n\u2502 4    \u2506 d    \u2506 1    \u2502\n\u2502 5    \u2506 e    \u2506 1    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.DiffHorizontal","title":"grizz.transformer.DiffHorizontal","text":"<p>               Bases: <code>BaseIn2Out1Transformer</code></p> <p>Implement a transformer to compute the difference between two columns.</p> <p>Internally, this tranformer computes: <code>out = in1 - in2</code></p> <p>Parameters:</p> Name Type Description Default <code>in1_col</code> <code>str</code> <p>The first input column name.</p> required <code>in2_col</code> <code>str</code> <p>The second input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import DiffHorizontal\n&gt;&gt;&gt; transformer = DiffHorizontal(in1_col=\"col1\", in2_col=\"col2\", out_col=\"diff\")\n&gt;&gt;&gt; transformer\nDiffHorizontalTransformer(in1_col='col1', in2_col='col2', out_col='diff', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [5, 4, 3, 2, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 diff \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2506 -4   \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2506 -2   \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506 0    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2506 2    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2506 4    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.DiffHorizontalTransformer","title":"grizz.transformer.DiffHorizontalTransformer","text":"<p>               Bases: <code>BaseIn2Out1Transformer</code></p> <p>Implement a transformer to compute the difference between two columns.</p> <p>Internally, this tranformer computes: <code>out = in1 - in2</code></p> <p>Parameters:</p> Name Type Description Default <code>in1_col</code> <code>str</code> <p>The first input column name.</p> required <code>in2_col</code> <code>str</code> <p>The second input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import DiffHorizontal\n&gt;&gt;&gt; transformer = DiffHorizontal(in1_col=\"col1\", in2_col=\"col2\", out_col=\"diff\")\n&gt;&gt;&gt; transformer\nDiffHorizontalTransformer(in1_col='col1', in2_col='col2', out_col='diff', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [5, 4, 3, 2, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 diff \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2506 -4   \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2506 -2   \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506 0    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2506 2    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2506 4    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.DiffTransformer","title":"grizz.transformer.DiffTransformer","text":"<p>               Bases: <code>BaseIn1Out1Transformer</code></p> <p>Implement a transformer to compute the first discrete difference between shifted items.</p> <p>Parameters:</p> Name Type Description Default <code>in_col</code> <code>str</code> <p>The input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>shift</code> <code>int</code> <p>The number of slots to shift.</p> <code>1</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Diff\n&gt;&gt;&gt; transformer = Diff(in_col=\"col1\", out_col=\"diff\")\n&gt;&gt;&gt; transformer\nDiffTransformer(in_col='col1', out_col='diff', shift=1, exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame({\"col1\": [1, 2, 3, 4, 5], \"col2\": [\"a\", \"b\", \"c\", \"d\", \"e\"]})\n&gt;&gt;&gt; frame\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2502\n\u2502 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 a    \u2502\n\u2502 2    \u2506 b    \u2502\n\u2502 3    \u2506 c    \u2502\n\u2502 4    \u2506 d    \u2502\n\u2502 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 diff \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 a    \u2506 null \u2502\n\u2502 2    \u2506 b    \u2506 1    \u2502\n\u2502 3    \u2506 c    \u2506 1    \u2502\n\u2502 4    \u2506 d    \u2506 1    \u2502\n\u2502 5    \u2506 e    \u2506 1    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.DropDuplicate","title":"grizz.transformer.DropDuplicate","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to drop duplicate rows.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to check. If set to <code>None</code> (default), use all columns.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>unique</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import DropDuplicate\n&gt;&gt;&gt; transformer = DropDuplicate(keep=\"first\", maintain_order=True)\n&gt;&gt;&gt; transformer\nDropDuplicateTransformer(columns=None, exclude_columns=(), missing_policy='raise', keep=first, maintain_order=True)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 1],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"1\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"1\", \"1\"],\n...         \"col4\": [\"a\", \"a\", \"a\", \"a\", \"a\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 a    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 a    \u2502\n\u2502 4    \u2506 4    \u2506 1    \u2506 a    \u2502\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (4, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 a    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 a    \u2502\n\u2502 4    \u2506 4    \u2506 1    \u2506 a    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.DropDuplicateTransformer","title":"grizz.transformer.DropDuplicateTransformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to drop duplicate rows.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to check. If set to <code>None</code> (default), use all columns.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>unique</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import DropDuplicate\n&gt;&gt;&gt; transformer = DropDuplicate(keep=\"first\", maintain_order=True)\n&gt;&gt;&gt; transformer\nDropDuplicateTransformer(columns=None, exclude_columns=(), missing_policy='raise', keep=first, maintain_order=True)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 1],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"1\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"1\", \"1\"],\n...         \"col4\": [\"a\", \"a\", \"a\", \"a\", \"a\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 a    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 a    \u2502\n\u2502 4    \u2506 4    \u2506 1    \u2506 a    \u2502\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (4, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 a    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 a    \u2502\n\u2502 4    \u2506 4    \u2506 1    \u2506 a    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.DropNullColumn","title":"grizz.transformer.DropNullColumn","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to remove the columns that have too many null values.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to convert. <code>None</code> means all the columns.</p> <code>None</code> <code>threshold</code> <code>float</code> <p>The maximum percentage of null values to keep columns. If the proportion of null vallues is greater or equal to this threshold value, the column is removed. If set to <code>1.0</code>, it removes all the columns that have only null values.</p> <code>1.0</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>cast</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import DropNullColumn\n&gt;&gt;&gt; transformer = DropNullColumn()\n&gt;&gt;&gt; transformer\nDropNullColumnTransformer(columns=None, threshold=1.0, exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [\"2020-1-1\", \"2020-1-2\", \"2020-1-31\", \"2020-12-31\", None],\n...         \"col2\": [1, None, 3, None, 5],\n...         \"col3\": [None, None, None, None, None],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1       \u2506 col2 \u2506 col3 \u2502\n\u2502 ---        \u2506 ---  \u2506 ---  \u2502\n\u2502 str        \u2506 i64  \u2506 null \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-1-1   \u2506 1    \u2506 null \u2502\n\u2502 2020-1-2   \u2506 null \u2506 null \u2502\n\u2502 2020-1-31  \u2506 3    \u2506 null \u2502\n\u2502 2020-12-31 \u2506 null \u2506 null \u2502\n\u2502 null       \u2506 5    \u2506 null \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1       \u2506 col2 \u2502\n\u2502 ---        \u2506 ---  \u2502\n\u2502 str        \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-1-1   \u2506 1    \u2502\n\u2502 2020-1-2   \u2506 null \u2502\n\u2502 2020-1-31  \u2506 3    \u2502\n\u2502 2020-12-31 \u2506 null \u2502\n\u2502 null       \u2506 5    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.DropNullColumnTransformer","title":"grizz.transformer.DropNullColumnTransformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to remove the columns that have too many null values.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to convert. <code>None</code> means all the columns.</p> <code>None</code> <code>threshold</code> <code>float</code> <p>The maximum percentage of null values to keep columns. If the proportion of null vallues is greater or equal to this threshold value, the column is removed. If set to <code>1.0</code>, it removes all the columns that have only null values.</p> <code>1.0</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>cast</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import DropNullColumn\n&gt;&gt;&gt; transformer = DropNullColumn()\n&gt;&gt;&gt; transformer\nDropNullColumnTransformer(columns=None, threshold=1.0, exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [\"2020-1-1\", \"2020-1-2\", \"2020-1-31\", \"2020-12-31\", None],\n...         \"col2\": [1, None, 3, None, 5],\n...         \"col3\": [None, None, None, None, None],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1       \u2506 col2 \u2506 col3 \u2502\n\u2502 ---        \u2506 ---  \u2506 ---  \u2502\n\u2502 str        \u2506 i64  \u2506 null \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-1-1   \u2506 1    \u2506 null \u2502\n\u2502 2020-1-2   \u2506 null \u2506 null \u2502\n\u2502 2020-1-31  \u2506 3    \u2506 null \u2502\n\u2502 2020-12-31 \u2506 null \u2506 null \u2502\n\u2502 null       \u2506 5    \u2506 null \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1       \u2506 col2 \u2502\n\u2502 ---        \u2506 ---  \u2502\n\u2502 str        \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-1-1   \u2506 1    \u2502\n\u2502 2020-1-2   \u2506 null \u2502\n\u2502 2020-1-31  \u2506 3    \u2502\n\u2502 2020-12-31 \u2506 null \u2502\n\u2502 null       \u2506 5    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.DropNullRow","title":"grizz.transformer.DropNullRow","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to drop all rows that contain null values.</p> <p>Note that all the values in the row need to be null to drop the row.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to check. If set to <code>None</code> (default), use all columns.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import DropNullRow\n&gt;&gt;&gt; transformer = DropNullRow()\n&gt;&gt;&gt; transformer\nDropNullRowTransformer(columns=None, exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [\"2020-1-1\", \"2020-1-2\", \"2020-1-31\", \"2020-12-31\", None],\n...         \"col2\": [1, None, 3, None, None],\n...         \"col3\": [None, None, None, None, None],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1       \u2506 col2 \u2506 col3 \u2502\n\u2502 ---        \u2506 ---  \u2506 ---  \u2502\n\u2502 str        \u2506 i64  \u2506 null \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-1-1   \u2506 1    \u2506 null \u2502\n\u2502 2020-1-2   \u2506 null \u2506 null \u2502\n\u2502 2020-1-31  \u2506 3    \u2506 null \u2502\n\u2502 2020-12-31 \u2506 null \u2506 null \u2502\n\u2502 null       \u2506 null \u2506 null \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (4, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1       \u2506 col2 \u2506 col3 \u2502\n\u2502 ---        \u2506 ---  \u2506 ---  \u2502\n\u2502 str        \u2506 i64  \u2506 null \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-1-1   \u2506 1    \u2506 null \u2502\n\u2502 2020-1-2   \u2506 null \u2506 null \u2502\n\u2502 2020-1-31  \u2506 3    \u2506 null \u2502\n\u2502 2020-12-31 \u2506 null \u2506 null \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.DropNullRowTransformer","title":"grizz.transformer.DropNullRowTransformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to drop all rows that contain null values.</p> <p>Note that all the values in the row need to be null to drop the row.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to check. If set to <code>None</code> (default), use all columns.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import DropNullRow\n&gt;&gt;&gt; transformer = DropNullRow()\n&gt;&gt;&gt; transformer\nDropNullRowTransformer(columns=None, exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [\"2020-1-1\", \"2020-1-2\", \"2020-1-31\", \"2020-12-31\", None],\n...         \"col2\": [1, None, 3, None, None],\n...         \"col3\": [None, None, None, None, None],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1       \u2506 col2 \u2506 col3 \u2502\n\u2502 ---        \u2506 ---  \u2506 ---  \u2502\n\u2502 str        \u2506 i64  \u2506 null \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-1-1   \u2506 1    \u2506 null \u2502\n\u2502 2020-1-2   \u2506 null \u2506 null \u2502\n\u2502 2020-1-31  \u2506 3    \u2506 null \u2502\n\u2502 2020-12-31 \u2506 null \u2506 null \u2502\n\u2502 null       \u2506 null \u2506 null \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (4, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1       \u2506 col2 \u2506 col3 \u2502\n\u2502 ---        \u2506 ---  \u2506 ---  \u2502\n\u2502 str        \u2506 i64  \u2506 null \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-1-1   \u2506 1    \u2506 null \u2502\n\u2502 2020-1-2   \u2506 null \u2506 null \u2502\n\u2502 2020-1-31  \u2506 3    \u2506 null \u2502\n\u2502 2020-12-31 \u2506 null \u2506 null \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.FillNan","title":"grizz.transformer.FillNan","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to fill NaN values.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to prepare. If <code>None</code>, it processes all the columns of type string.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>fill_nan</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import FillNan\n&gt;&gt;&gt; transformer = FillNan(columns=[\"col1\", \"col4\"], value=100)\n&gt;&gt;&gt; transformer\nFillNanTransformer(columns=('col1', 'col4'), exclude_columns=(), missing_policy='raise', value=100)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, None],\n...         \"col2\": [1.2, 2.2, 3.2, 4.2, float(\"nan\")],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", None],\n...         \"col4\": [1.2, float(\"nan\"), 3.2, None, 5.2],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 f64  \u2506 str  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.2  \u2506 a    \u2506 1.2  \u2502\n\u2502 2    \u2506 2.2  \u2506 b    \u2506 NaN  \u2502\n\u2502 3    \u2506 3.2  \u2506 c    \u2506 3.2  \u2502\n\u2502 4    \u2506 4.2  \u2506 d    \u2506 null \u2502\n\u2502 null \u2506 NaN  \u2506 null \u2506 5.2  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 f64  \u2506 str  \u2506 f64   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.2  \u2506 a    \u2506 1.2   \u2502\n\u2502 2    \u2506 2.2  \u2506 b    \u2506 100.0 \u2502\n\u2502 3    \u2506 3.2  \u2506 c    \u2506 3.2   \u2502\n\u2502 4    \u2506 4.2  \u2506 d    \u2506 null  \u2502\n\u2502 null \u2506 NaN  \u2506 null \u2506 5.2   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.FillNanTransformer","title":"grizz.transformer.FillNanTransformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to fill NaN values.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to prepare. If <code>None</code>, it processes all the columns of type string.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>fill_nan</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import FillNan\n&gt;&gt;&gt; transformer = FillNan(columns=[\"col1\", \"col4\"], value=100)\n&gt;&gt;&gt; transformer\nFillNanTransformer(columns=('col1', 'col4'), exclude_columns=(), missing_policy='raise', value=100)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, None],\n...         \"col2\": [1.2, 2.2, 3.2, 4.2, float(\"nan\")],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", None],\n...         \"col4\": [1.2, float(\"nan\"), 3.2, None, 5.2],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 f64  \u2506 str  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.2  \u2506 a    \u2506 1.2  \u2502\n\u2502 2    \u2506 2.2  \u2506 b    \u2506 NaN  \u2502\n\u2502 3    \u2506 3.2  \u2506 c    \u2506 3.2  \u2502\n\u2502 4    \u2506 4.2  \u2506 d    \u2506 null \u2502\n\u2502 null \u2506 NaN  \u2506 null \u2506 5.2  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 f64  \u2506 str  \u2506 f64   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.2  \u2506 a    \u2506 1.2   \u2502\n\u2502 2    \u2506 2.2  \u2506 b    \u2506 100.0 \u2502\n\u2502 3    \u2506 3.2  \u2506 c    \u2506 3.2   \u2502\n\u2502 4    \u2506 4.2  \u2506 d    \u2506 null  \u2502\n\u2502 null \u2506 NaN  \u2506 null \u2506 5.2   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.FillNull","title":"grizz.transformer.FillNull","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to fill null values.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to prepare. If <code>None</code>, it processes all the columns of type string.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>fill_null</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import FillNull\n&gt;&gt;&gt; transformer = FillNull(columns=[\"col1\", \"col4\"], value=100)\n&gt;&gt;&gt; transformer\nFillNullTransformer(columns=('col1', 'col4'), exclude_columns=(), missing_policy='raise', value=100)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, None],\n...         \"col2\": [1.2, 2.2, 3.2, 4.2, None],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", None],\n...         \"col4\": [1.2, float(\"nan\"), 3.2, None, 5.2],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 f64  \u2506 str  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.2  \u2506 a    \u2506 1.2  \u2502\n\u2502 2    \u2506 2.2  \u2506 b    \u2506 NaN  \u2502\n\u2502 3    \u2506 3.2  \u2506 c    \u2506 3.2  \u2502\n\u2502 4    \u2506 4.2  \u2506 d    \u2506 null \u2502\n\u2502 null \u2506 null \u2506 null \u2506 5.2  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 f64  \u2506 str  \u2506 f64   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.2  \u2506 a    \u2506 1.2   \u2502\n\u2502 2    \u2506 2.2  \u2506 b    \u2506 NaN   \u2502\n\u2502 3    \u2506 3.2  \u2506 c    \u2506 3.2   \u2502\n\u2502 4    \u2506 4.2  \u2506 d    \u2506 100.0 \u2502\n\u2502 100  \u2506 null \u2506 null \u2506 5.2   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.FillNullTransformer","title":"grizz.transformer.FillNullTransformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to fill null values.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to prepare. If <code>None</code>, it processes all the columns of type string.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>fill_null</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import FillNull\n&gt;&gt;&gt; transformer = FillNull(columns=[\"col1\", \"col4\"], value=100)\n&gt;&gt;&gt; transformer\nFillNullTransformer(columns=('col1', 'col4'), exclude_columns=(), missing_policy='raise', value=100)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, None],\n...         \"col2\": [1.2, 2.2, 3.2, 4.2, None],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", None],\n...         \"col4\": [1.2, float(\"nan\"), 3.2, None, 5.2],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 f64  \u2506 str  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.2  \u2506 a    \u2506 1.2  \u2502\n\u2502 2    \u2506 2.2  \u2506 b    \u2506 NaN  \u2502\n\u2502 3    \u2506 3.2  \u2506 c    \u2506 3.2  \u2502\n\u2502 4    \u2506 4.2  \u2506 d    \u2506 null \u2502\n\u2502 null \u2506 null \u2506 null \u2506 5.2  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 f64  \u2506 str  \u2506 f64   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.2  \u2506 a    \u2506 1.2   \u2502\n\u2502 2    \u2506 2.2  \u2506 b    \u2506 NaN   \u2502\n\u2502 3    \u2506 3.2  \u2506 c    \u2506 3.2   \u2502\n\u2502 4    \u2506 4.2  \u2506 d    \u2506 100.0 \u2502\n\u2502 100  \u2506 null \u2506 null \u2506 5.2   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.FilterCardinality","title":"grizz.transformer.FilterCardinality","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to filter based on the cardinality (i.e. number of unique values) in each column.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to use to filter based on the number of unique values. If <code>None</code>, it processes all the columns of type string.</p> <code>None</code> <code>n_min</code> <code>int</code> <p>The minimal cardinality (included).</p> <code>0</code> <code>n_max</code> <code>int</code> <p>The maximal cardinality (excluded).</p> <code>float('inf')</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import FilterCardinality\n&gt;&gt;&gt; transformer = FilterCardinality(columns=[\"col1\", \"col2\", \"col3\"], n_min=2, n_max=5)\n&gt;&gt;&gt; transformer\nFilterCardinalityTransformer(columns=('col1', 'col2', 'col3'), n_min=2, n_max=5, exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [1, 1, 1, 1, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"a\", \"b\"],\n...         \"col4\": [1.2, float(\"nan\"), 3.2, None, 5.2],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 a    \u2506 1.2  \u2502\n\u2502 2    \u2506 1    \u2506 b    \u2506 NaN  \u2502\n\u2502 3    \u2506 1    \u2506 c    \u2506 3.2  \u2502\n\u2502 4    \u2506 1    \u2506 a    \u2506 null \u2502\n\u2502 5    \u2506 1    \u2506 b    \u2506 5.2  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2502\n\u2502 str  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a    \u2506 1.2  \u2502\n\u2502 b    \u2506 NaN  \u2502\n\u2502 c    \u2506 3.2  \u2502\n\u2502 a    \u2506 null \u2502\n\u2502 b    \u2506 5.2  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.FilterCardinalityTransformer","title":"grizz.transformer.FilterCardinalityTransformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to filter based on the cardinality (i.e. number of unique values) in each column.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to use to filter based on the number of unique values. If <code>None</code>, it processes all the columns of type string.</p> <code>None</code> <code>n_min</code> <code>int</code> <p>The minimal cardinality (included).</p> <code>0</code> <code>n_max</code> <code>int</code> <p>The maximal cardinality (excluded).</p> <code>float('inf')</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import FilterCardinality\n&gt;&gt;&gt; transformer = FilterCardinality(columns=[\"col1\", \"col2\", \"col3\"], n_min=2, n_max=5)\n&gt;&gt;&gt; transformer\nFilterCardinalityTransformer(columns=('col1', 'col2', 'col3'), n_min=2, n_max=5, exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [1, 1, 1, 1, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"a\", \"b\"],\n...         \"col4\": [1.2, float(\"nan\"), 3.2, None, 5.2],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 a    \u2506 1.2  \u2502\n\u2502 2    \u2506 1    \u2506 b    \u2506 NaN  \u2502\n\u2502 3    \u2506 1    \u2506 c    \u2506 3.2  \u2502\n\u2502 4    \u2506 1    \u2506 a    \u2506 null \u2502\n\u2502 5    \u2506 1    \u2506 b    \u2506 5.2  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2502\n\u2502 str  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a    \u2506 1.2  \u2502\n\u2502 b    \u2506 NaN  \u2502\n\u2502 c    \u2506 3.2  \u2502\n\u2502 a    \u2506 null \u2502\n\u2502 b    \u2506 5.2  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.FloatCast","title":"grizz.transformer.FloatCast","text":"<p>               Bases: <code>CastTransformer</code></p> <p>Implement a transformer to convert columns of type float to a new data type.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to convert. <code>None</code> means all the columns.</p> required <code>dtype</code> <code>type[DataType]</code> <p>The target data type.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>cast</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import FloatCast\n&gt;&gt;&gt; transformer = FloatCast(columns=[\"col1\", \"col2\"], dtype=pl.Int32)\n&gt;&gt;&gt; transformer\nFloatCastTransformer(columns=('col1', 'col2'), dtype=Int32, exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [1.0, 2.0, 3.0, 4.0, 5.0],\n...         \"col3\": [1.0, 2.0, 3.0, 4.0, 5.0],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     },\n...     schema={\n...         \"col1\": pl.Int64,\n...         \"col2\": pl.Float64,\n...         \"col3\": pl.Float64,\n...         \"col4\": pl.String,\n...     },\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 f64  \u2506 f64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.0  \u2506 1.0  \u2506 a    \u2502\n\u2502 2    \u2506 2.0  \u2506 2.0  \u2506 b    \u2502\n\u2502 3    \u2506 3.0  \u2506 3.0  \u2506 c    \u2502\n\u2502 4    \u2506 4.0  \u2506 4.0  \u2506 d    \u2502\n\u2502 5    \u2506 5.0  \u2506 5.0  \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i32  \u2506 f64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1.0  \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2.0  \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3.0  \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4.0  \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5.0  \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.FloatCastTransformer","title":"grizz.transformer.FloatCastTransformer","text":"<p>               Bases: <code>CastTransformer</code></p> <p>Implement a transformer to convert columns of type float to a new data type.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to convert. <code>None</code> means all the columns.</p> required <code>dtype</code> <code>type[DataType]</code> <p>The target data type.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>cast</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import FloatCast\n&gt;&gt;&gt; transformer = FloatCast(columns=[\"col1\", \"col2\"], dtype=pl.Int32)\n&gt;&gt;&gt; transformer\nFloatCastTransformer(columns=('col1', 'col2'), dtype=Int32, exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [1.0, 2.0, 3.0, 4.0, 5.0],\n...         \"col3\": [1.0, 2.0, 3.0, 4.0, 5.0],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     },\n...     schema={\n...         \"col1\": pl.Int64,\n...         \"col2\": pl.Float64,\n...         \"col3\": pl.Float64,\n...         \"col4\": pl.String,\n...     },\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 f64  \u2506 f64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.0  \u2506 1.0  \u2506 a    \u2502\n\u2502 2    \u2506 2.0  \u2506 2.0  \u2506 b    \u2502\n\u2502 3    \u2506 3.0  \u2506 3.0  \u2506 c    \u2502\n\u2502 4    \u2506 4.0  \u2506 4.0  \u2506 d    \u2502\n\u2502 5    \u2506 5.0  \u2506 5.0  \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i32  \u2506 f64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1.0  \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2.0  \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3.0  \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4.0  \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5.0  \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.Function","title":"grizz.transformer.Function","text":"<p>               Bases: <code>BaseTransformer</code></p> <p>Implement a transformer that is a wrapper around a function to transform the DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[DataFrame], DataFrame]</code> <p>The function to transform the DataFrame.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import FunctionTransformer\n&gt;&gt;&gt; transformer = FunctionTransformer(\n...     func=lambda frame: frame.filter(pl.col(\"col1\").is_in({2, 4}))\n... )\n&gt;&gt;&gt; transformer\nFunctionTransformer(func=&lt;function &lt;lambda&gt; at 0x...&gt;)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (2, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.FunctionTransformer","title":"grizz.transformer.FunctionTransformer","text":"<p>               Bases: <code>BaseTransformer</code></p> <p>Implement a transformer that is a wrapper around a function to transform the DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[DataFrame], DataFrame]</code> <p>The function to transform the DataFrame.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import FunctionTransformer\n&gt;&gt;&gt; transformer = FunctionTransformer(\n...     func=lambda frame: frame.filter(pl.col(\"col1\").is_in({2, 4}))\n... )\n&gt;&gt;&gt; transformer\nFunctionTransformer(func=&lt;function &lt;lambda&gt; at 0x...&gt;)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (2, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.IntegerCast","title":"grizz.transformer.IntegerCast","text":"<p>               Bases: <code>CastTransformer</code></p> <p>Implement a transformer to convert columns of type integer to a new data type.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to convert. <code>None</code> means all the columns.</p> required <code>dtype</code> <code>type[DataType]</code> <p>The target data type.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>cast</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import IntegerCast\n&gt;&gt;&gt; transformer = IntegerCast(columns=[\"col1\", \"col2\"], dtype=pl.Float32)\n&gt;&gt;&gt; transformer\nIntegerCastTransformer(columns=('col1', 'col2'), dtype=Float32, exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [1.0, 2.0, 3.0, 4.0, 5.0],\n...         \"col3\": [1, 2, 3, 4, 5],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     },\n...     schema={\n...         \"col1\": pl.Int64,\n...         \"col2\": pl.Float64,\n...         \"col3\": pl.Int64,\n...         \"col4\": pl.String,\n...     },\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 f64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.0  \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2.0  \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3.0  \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4.0  \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5.0  \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 f32  \u2506 f64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0  \u2506 1.0  \u2506 1    \u2506 a    \u2502\n\u2502 2.0  \u2506 2.0  \u2506 2    \u2506 b    \u2502\n\u2502 3.0  \u2506 3.0  \u2506 3    \u2506 c    \u2502\n\u2502 4.0  \u2506 4.0  \u2506 4    \u2506 d    \u2502\n\u2502 5.0  \u2506 5.0  \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.IntegerCastTransformer","title":"grizz.transformer.IntegerCastTransformer","text":"<p>               Bases: <code>CastTransformer</code></p> <p>Implement a transformer to convert columns of type integer to a new data type.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to convert. <code>None</code> means all the columns.</p> required <code>dtype</code> <code>type[DataType]</code> <p>The target data type.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>cast</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import IntegerCast\n&gt;&gt;&gt; transformer = IntegerCast(columns=[\"col1\", \"col2\"], dtype=pl.Float32)\n&gt;&gt;&gt; transformer\nIntegerCastTransformer(columns=('col1', 'col2'), dtype=Float32, exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [1.0, 2.0, 3.0, 4.0, 5.0],\n...         \"col3\": [1, 2, 3, 4, 5],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     },\n...     schema={\n...         \"col1\": pl.Int64,\n...         \"col2\": pl.Float64,\n...         \"col3\": pl.Int64,\n...         \"col4\": pl.String,\n...     },\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 f64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.0  \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2.0  \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3.0  \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4.0  \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5.0  \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 f32  \u2506 f64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0  \u2506 1.0  \u2506 1    \u2506 a    \u2502\n\u2502 2.0  \u2506 2.0  \u2506 2    \u2506 b    \u2502\n\u2502 3.0  \u2506 3.0  \u2506 3    \u2506 c    \u2502\n\u2502 4.0  \u2506 4.0  \u2506 4    \u2506 d    \u2502\n\u2502 5.0  \u2506 5.0  \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.JsonDecode","title":"grizz.transformer.JsonDecode","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to parse string values as JSON.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to parse. <code>None</code> means all the columns.</p> <code>None</code> <code>dtype</code> <code>PolarsDataType | PythonDataType | None</code> <p>The dtype to cast the extracted value to. If <code>None</code>, the dtype will be inferred from the JSON value.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import JsonDecode\n&gt;&gt;&gt; transformer = JsonDecode(columns=[\"col1\", \"col3\"])\n&gt;&gt;&gt; transformer\nJsonDecodeTransformer(columns=('col1', 'col3'), dtype=None, exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [\"[1, 2]\", \"[2]\", \"[1, 2, 3]\", \"[4, 5]\", \"[5, 4]\"],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"['1', '2']\", \"['2']\", \"['1', '2', '3']\", \"['4', '5']\", \"['5', '4']\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1      \u2506 col2 \u2506 col3            \u2506 col4 \u2502\n\u2502 ---       \u2506 ---  \u2506 ---             \u2506 ---  \u2502\n\u2502 str       \u2506 str  \u2506 str             \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 [1, 2]    \u2506 1    \u2506 ['1', '2']      \u2506 a    \u2502\n\u2502 [2]       \u2506 2    \u2506 ['2']           \u2506 b    \u2502\n\u2502 [1, 2, 3] \u2506 3    \u2506 ['1', '2', '3'] \u2506 c    \u2502\n\u2502 [4, 5]    \u2506 4    \u2506 ['4', '5']      \u2506 d    \u2502\n\u2502 [5, 4]    \u2506 5    \u2506 ['5', '4']      \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1      \u2506 col2 \u2506 col3            \u2506 col4 \u2502\n\u2502 ---       \u2506 ---  \u2506 ---             \u2506 ---  \u2502\n\u2502 list[i64] \u2506 str  \u2506 list[str]       \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 [1, 2]    \u2506 1    \u2506 [\"1\", \"2\"]      \u2506 a    \u2502\n\u2502 [2]       \u2506 2    \u2506 [\"2\"]           \u2506 b    \u2502\n\u2502 [1, 2, 3] \u2506 3    \u2506 [\"1\", \"2\", \"3\"] \u2506 c    \u2502\n\u2502 [4, 5]    \u2506 4    \u2506 [\"4\", \"5\"]      \u2506 d    \u2502\n\u2502 [5, 4]    \u2506 5    \u2506 [\"5\", \"4\"]      \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.JsonDecodeTransformer","title":"grizz.transformer.JsonDecodeTransformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to parse string values as JSON.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to parse. <code>None</code> means all the columns.</p> <code>None</code> <code>dtype</code> <code>PolarsDataType | PythonDataType | None</code> <p>The dtype to cast the extracted value to. If <code>None</code>, the dtype will be inferred from the JSON value.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import JsonDecode\n&gt;&gt;&gt; transformer = JsonDecode(columns=[\"col1\", \"col3\"])\n&gt;&gt;&gt; transformer\nJsonDecodeTransformer(columns=('col1', 'col3'), dtype=None, exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [\"[1, 2]\", \"[2]\", \"[1, 2, 3]\", \"[4, 5]\", \"[5, 4]\"],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"['1', '2']\", \"['2']\", \"['1', '2', '3']\", \"['4', '5']\", \"['5', '4']\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1      \u2506 col2 \u2506 col3            \u2506 col4 \u2502\n\u2502 ---       \u2506 ---  \u2506 ---             \u2506 ---  \u2502\n\u2502 str       \u2506 str  \u2506 str             \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 [1, 2]    \u2506 1    \u2506 ['1', '2']      \u2506 a    \u2502\n\u2502 [2]       \u2506 2    \u2506 ['2']           \u2506 b    \u2502\n\u2502 [1, 2, 3] \u2506 3    \u2506 ['1', '2', '3'] \u2506 c    \u2502\n\u2502 [4, 5]    \u2506 4    \u2506 ['4', '5']      \u2506 d    \u2502\n\u2502 [5, 4]    \u2506 5    \u2506 ['5', '4']      \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1      \u2506 col2 \u2506 col3            \u2506 col4 \u2502\n\u2502 ---       \u2506 ---  \u2506 ---             \u2506 ---  \u2502\n\u2502 list[i64] \u2506 str  \u2506 list[str]       \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 [1, 2]    \u2506 1    \u2506 [\"1\", \"2\"]      \u2506 a    \u2502\n\u2502 [2]       \u2506 2    \u2506 [\"2\"]           \u2506 b    \u2502\n\u2502 [1, 2, 3] \u2506 3    \u2506 [\"1\", \"2\", \"3\"] \u2506 c    \u2502\n\u2502 [4, 5]    \u2506 4    \u2506 [\"4\", \"5\"]      \u2506 d    \u2502\n\u2502 [5, 4]    \u2506 5    \u2506 [\"5\", \"4\"]      \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.LabelEncoder","title":"grizz.transformer.LabelEncoder","text":"<p>               Bases: <code>BaseIn1Out1Transformer</code></p> <p>Implement a <code>polars.DataFrame</code> to encode the labels in a given column.</p> <p>Parameters:</p> Name Type Description Default <code>in_col</code> <code>str</code> <p>The input column name i.e. the column with the label to encode.</p> required <code>out_col</code> <code>str</code> <p>The output column name i.e. the column with encoded labels.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import LabelEncoderTransformer\n&gt;&gt;&gt; transformer = LabelEncoderTransformer(in_col=\"col1\", out_col=\"out\")\n&gt;&gt;&gt; transformer\nLabelEncoderTransformer(in_col='col1', out_col='out', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2502\n\u2502 ---  \u2506 ---  \u2502\n\u2502 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a    \u2506 1    \u2502\n\u2502 b    \u2506 2    \u2502\n\u2502 c    \u2506 3    \u2502\n\u2502 d    \u2506 4    \u2502\n\u2502 e    \u2506 5    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.fit_transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 out \u2502\n\u2502 ---  \u2506 ---  \u2506 --- \u2502\n\u2502 str  \u2506 str  \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a    \u2506 1    \u2506 0   \u2502\n\u2502 b    \u2506 2    \u2506 1   \u2502\n\u2502 c    \u2506 3    \u2506 2   \u2502\n\u2502 d    \u2506 4    \u2506 3   \u2502\n\u2502 e    \u2506 5    \u2506 4   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.LabelEncoderTransformer","title":"grizz.transformer.LabelEncoderTransformer","text":"<p>               Bases: <code>BaseIn1Out1Transformer</code></p> <p>Implement a <code>polars.DataFrame</code> to encode the labels in a given column.</p> <p>Parameters:</p> Name Type Description Default <code>in_col</code> <code>str</code> <p>The input column name i.e. the column with the label to encode.</p> required <code>out_col</code> <code>str</code> <p>The output column name i.e. the column with encoded labels.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import LabelEncoderTransformer\n&gt;&gt;&gt; transformer = LabelEncoderTransformer(in_col=\"col1\", out_col=\"out\")\n&gt;&gt;&gt; transformer\nLabelEncoderTransformer(in_col='col1', out_col='out', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2502\n\u2502 ---  \u2506 ---  \u2502\n\u2502 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a    \u2506 1    \u2502\n\u2502 b    \u2506 2    \u2502\n\u2502 c    \u2506 3    \u2502\n\u2502 d    \u2506 4    \u2502\n\u2502 e    \u2506 5    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.fit_transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 out \u2502\n\u2502 ---  \u2506 ---  \u2506 --- \u2502\n\u2502 str  \u2506 str  \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a    \u2506 1    \u2506 0   \u2502\n\u2502 b    \u2506 2    \u2506 1   \u2502\n\u2502 c    \u2506 3    \u2506 2   \u2502\n\u2502 d    \u2506 4    \u2506 3   \u2502\n\u2502 e    \u2506 5    \u2506 4   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.MaxHorizontal","title":"grizz.transformer.MaxHorizontal","text":"<p>               Bases: <code>BaseInNOut1Transformer</code></p> <p>Implement a transformer to get the maximum value horizontally across columns and store the result in a column.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns the maximum value horizontally. The columns should be compatible. If <code>None</code>, it processes all the columns.</p> required <code>out_col</code> <code>str</code> <p>The output column.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import MaxHorizontal\n&gt;&gt;&gt; transformer = MaxHorizontal(columns=[\"col1\", \"col2\", \"col3\"], out_col=\"col\")\n&gt;&gt;&gt; transformer\nMaxHorizontalTransformer(columns=('col1', 'col2', 'col3'), out_col='col', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [9, 5, 4, 9, 6],\n...         \"col2\": [8, 0, 1, 8, 9],\n...         \"col3\": [0, 4, 8, 7, 0],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 9    \u2506 8    \u2506 0    \u2506 a    \u2502\n\u2502 5    \u2506 0    \u2506 4    \u2506 b    \u2502\n\u2502 4    \u2506 1    \u2506 8    \u2506 c    \u2502\n\u2502 9    \u2506 8    \u2506 7    \u2506 d    \u2502\n\u2502 6    \u2506 9    \u2506 0    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 --- \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 9    \u2506 8    \u2506 0    \u2506 a    \u2506 9   \u2502\n\u2502 5    \u2506 0    \u2506 4    \u2506 b    \u2506 5   \u2502\n\u2502 4    \u2506 1    \u2506 8    \u2506 c    \u2506 8   \u2502\n\u2502 9    \u2506 8    \u2506 7    \u2506 d    \u2506 9   \u2502\n\u2502 6    \u2506 9    \u2506 0    \u2506 e    \u2506 9   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.MaxHorizontalTransformer","title":"grizz.transformer.MaxHorizontalTransformer","text":"<p>               Bases: <code>BaseInNOut1Transformer</code></p> <p>Implement a transformer to get the maximum value horizontally across columns and store the result in a column.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns the maximum value horizontally. The columns should be compatible. If <code>None</code>, it processes all the columns.</p> required <code>out_col</code> <code>str</code> <p>The output column.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import MaxHorizontal\n&gt;&gt;&gt; transformer = MaxHorizontal(columns=[\"col1\", \"col2\", \"col3\"], out_col=\"col\")\n&gt;&gt;&gt; transformer\nMaxHorizontalTransformer(columns=('col1', 'col2', 'col3'), out_col='col', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [9, 5, 4, 9, 6],\n...         \"col2\": [8, 0, 1, 8, 9],\n...         \"col3\": [0, 4, 8, 7, 0],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 9    \u2506 8    \u2506 0    \u2506 a    \u2502\n\u2502 5    \u2506 0    \u2506 4    \u2506 b    \u2502\n\u2502 4    \u2506 1    \u2506 8    \u2506 c    \u2502\n\u2502 9    \u2506 8    \u2506 7    \u2506 d    \u2502\n\u2502 6    \u2506 9    \u2506 0    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 --- \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 9    \u2506 8    \u2506 0    \u2506 a    \u2506 9   \u2502\n\u2502 5    \u2506 0    \u2506 4    \u2506 b    \u2506 5   \u2502\n\u2502 4    \u2506 1    \u2506 8    \u2506 c    \u2506 8   \u2502\n\u2502 9    \u2506 8    \u2506 7    \u2506 d    \u2506 9   \u2502\n\u2502 6    \u2506 9    \u2506 0    \u2506 e    \u2506 9   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.MeanHorizontal","title":"grizz.transformer.MeanHorizontal","text":"<p>               Bases: <code>BaseInNOut1Transformer</code></p> <p>Implement a transformer to get the mean value horizontally across columns and store the result in a column.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns the mean value horizontally. The columns should be compatible. If <code>None</code>, it processes all the columns.</p> required <code>out_col</code> <code>str</code> <p>The output column.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>ignore_nulls</code> <code>bool</code> <p>If set to False, any null value in the input will lead to a null output.</p> <code>True</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import MeanHorizontal\n&gt;&gt;&gt; transformer = MeanHorizontal(columns=[\"col1\", \"col2\", \"col3\"], out_col=\"col\")\n&gt;&gt;&gt; transformer\nMeanHorizontalTransformer(columns=('col1', 'col2', 'col3'), out_col='col', exclude_columns=(), ignore_nulls=True, exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [11, 12, 13, 14, 15],\n...         \"col2\": [21, 22, 23, 24, 25],\n...         \"col3\": [31, 32, 33, 34, 35],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11   \u2506 21   \u2506 31   \u2506 a    \u2502\n\u2502 12   \u2506 22   \u2506 32   \u2506 b    \u2502\n\u2502 13   \u2506 23   \u2506 33   \u2506 c    \u2502\n\u2502 14   \u2506 24   \u2506 34   \u2506 d    \u2502\n\u2502 15   \u2506 25   \u2506 35   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11   \u2506 21   \u2506 31   \u2506 a    \u2506 21.0 \u2502\n\u2502 12   \u2506 22   \u2506 32   \u2506 b    \u2506 22.0 \u2502\n\u2502 13   \u2506 23   \u2506 33   \u2506 c    \u2506 23.0 \u2502\n\u2502 14   \u2506 24   \u2506 34   \u2506 d    \u2506 24.0 \u2502\n\u2502 15   \u2506 25   \u2506 35   \u2506 e    \u2506 25.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.MeanHorizontalTransformer","title":"grizz.transformer.MeanHorizontalTransformer","text":"<p>               Bases: <code>BaseInNOut1Transformer</code></p> <p>Implement a transformer to get the mean value horizontally across columns and store the result in a column.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns the mean value horizontally. The columns should be compatible. If <code>None</code>, it processes all the columns.</p> required <code>out_col</code> <code>str</code> <p>The output column.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>ignore_nulls</code> <code>bool</code> <p>If set to False, any null value in the input will lead to a null output.</p> <code>True</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import MeanHorizontal\n&gt;&gt;&gt; transformer = MeanHorizontal(columns=[\"col1\", \"col2\", \"col3\"], out_col=\"col\")\n&gt;&gt;&gt; transformer\nMeanHorizontalTransformer(columns=('col1', 'col2', 'col3'), out_col='col', exclude_columns=(), ignore_nulls=True, exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [11, 12, 13, 14, 15],\n...         \"col2\": [21, 22, 23, 24, 25],\n...         \"col3\": [31, 32, 33, 34, 35],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11   \u2506 21   \u2506 31   \u2506 a    \u2502\n\u2502 12   \u2506 22   \u2506 32   \u2506 b    \u2502\n\u2502 13   \u2506 23   \u2506 33   \u2506 c    \u2502\n\u2502 14   \u2506 24   \u2506 34   \u2506 d    \u2502\n\u2502 15   \u2506 25   \u2506 35   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11   \u2506 21   \u2506 31   \u2506 a    \u2506 21.0 \u2502\n\u2502 12   \u2506 22   \u2506 32   \u2506 b    \u2506 22.0 \u2502\n\u2502 13   \u2506 23   \u2506 33   \u2506 c    \u2506 23.0 \u2502\n\u2502 14   \u2506 24   \u2506 34   \u2506 d    \u2506 24.0 \u2502\n\u2502 15   \u2506 25   \u2506 35   \u2506 e    \u2506 25.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.MinHorizontal","title":"grizz.transformer.MinHorizontal","text":"<p>               Bases: <code>BaseInNOut1Transformer</code></p> <p>Implement a transformer to get the minimum value horizontally across columns and store the result in a column.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns the minimum value horizontally. The columns should be compatible. If <code>None</code>, it processes all the columns.</p> required <code>out_col</code> <code>str</code> <p>The output column.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import MinHorizontal\n&gt;&gt;&gt; transformer = MinHorizontal(columns=[\"col1\", \"col2\", \"col3\"], out_col=\"col\")\n&gt;&gt;&gt; transformer\nMinHorizontalTransformer(columns=('col1', 'col2', 'col3'), out_col='col', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [9, 5, 4, 9, 6],\n...         \"col2\": [8, 0, 1, 8, 9],\n...         \"col3\": [0, 4, 8, 7, 0],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 9    \u2506 8    \u2506 0    \u2506 a    \u2502\n\u2502 5    \u2506 0    \u2506 4    \u2506 b    \u2502\n\u2502 4    \u2506 1    \u2506 8    \u2506 c    \u2502\n\u2502 9    \u2506 8    \u2506 7    \u2506 d    \u2502\n\u2502 6    \u2506 9    \u2506 0    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 --- \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 9    \u2506 8    \u2506 0    \u2506 a    \u2506 0   \u2502\n\u2502 5    \u2506 0    \u2506 4    \u2506 b    \u2506 0   \u2502\n\u2502 4    \u2506 1    \u2506 8    \u2506 c    \u2506 1   \u2502\n\u2502 9    \u2506 8    \u2506 7    \u2506 d    \u2506 7   \u2502\n\u2502 6    \u2506 9    \u2506 0    \u2506 e    \u2506 0   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.MinHorizontalTransformer","title":"grizz.transformer.MinHorizontalTransformer","text":"<p>               Bases: <code>BaseInNOut1Transformer</code></p> <p>Implement a transformer to get the minimum value horizontally across columns and store the result in a column.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns the minimum value horizontally. The columns should be compatible. If <code>None</code>, it processes all the columns.</p> required <code>out_col</code> <code>str</code> <p>The output column.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import MinHorizontal\n&gt;&gt;&gt; transformer = MinHorizontal(columns=[\"col1\", \"col2\", \"col3\"], out_col=\"col\")\n&gt;&gt;&gt; transformer\nMinHorizontalTransformer(columns=('col1', 'col2', 'col3'), out_col='col', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [9, 5, 4, 9, 6],\n...         \"col2\": [8, 0, 1, 8, 9],\n...         \"col3\": [0, 4, 8, 7, 0],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 9    \u2506 8    \u2506 0    \u2506 a    \u2502\n\u2502 5    \u2506 0    \u2506 4    \u2506 b    \u2502\n\u2502 4    \u2506 1    \u2506 8    \u2506 c    \u2502\n\u2502 9    \u2506 8    \u2506 7    \u2506 d    \u2502\n\u2502 6    \u2506 9    \u2506 0    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 --- \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 9    \u2506 8    \u2506 0    \u2506 a    \u2506 0   \u2502\n\u2502 5    \u2506 0    \u2506 4    \u2506 b    \u2506 0   \u2502\n\u2502 4    \u2506 1    \u2506 8    \u2506 c    \u2506 1   \u2502\n\u2502 9    \u2506 8    \u2506 7    \u2506 d    \u2506 7   \u2502\n\u2502 6    \u2506 9    \u2506 0    \u2506 e    \u2506 0   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.Replace","title":"grizz.transformer.Replace","text":"<p>               Bases: <code>BaseIn1Out1Transformer</code></p> <p>Replace the values in a column by the values in a mapping.</p> <p>Parameters:</p> Name Type Description Default <code>in_col</code> <code>str</code> <p>The input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments to pass to <code>replace</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Replace\n&gt;&gt;&gt; transformer = Replace(in_col=\"old\", out_col=\"new\", old={\"a\": 1, \"b\": 2, \"c\": 3})\n&gt;&gt;&gt; transformer\nReplaceTransformer(in_col='old', out_col='new', exist_policy='raise', missing_policy='raise', old={'a': 1, 'b': 2, 'c': 3})\n&gt;&gt;&gt; frame = pl.DataFrame({\"old\": [\"a\", \"b\", \"c\", \"d\", \"e\"]})\n&gt;&gt;&gt; frame\nshape: (5, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 old \u2502\n\u2502 --- \u2502\n\u2502 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2502\n\u2502 b   \u2502\n\u2502 c   \u2502\n\u2502 d   \u2502\n\u2502 e   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 old \u2506 new \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 str \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1   \u2502\n\u2502 b   \u2506 2   \u2502\n\u2502 c   \u2506 3   \u2502\n\u2502 d   \u2506 d   \u2502\n\u2502 e   \u2506 e   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; transformer = Replace(\n...     in_col=\"old\",\n...     out_col=\"new\",\n...     old={\"a\": 1, \"b\": 2, \"c\": 3},\n...     default=None,\n... )\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 old \u2506 new  \u2502\n\u2502 --- \u2506 ---  \u2502\n\u2502 str \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1    \u2502\n\u2502 b   \u2506 2    \u2502\n\u2502 c   \u2506 3    \u2502\n\u2502 d   \u2506 null \u2502\n\u2502 e   \u2506 null \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ReplaceStrict","title":"grizz.transformer.ReplaceStrict","text":"<p>               Bases: <code>BaseIn1Out1Transformer</code></p> <p>Replace the values in a column by the values in a mapping.</p> <p>Parameters:</p> Name Type Description Default <code>in_col</code> <code>str</code> <p>The input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments to pass to <code>replace</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ReplaceStrict\n&gt;&gt;&gt; transformer = ReplaceStrict(\n...     in_col=\"old\", out_col=\"new\", old={\"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4, \"e\": 5}\n... )\n&gt;&gt;&gt; transformer\nReplaceStrictTransformer(in_col='old', out_col='new', exist_policy='raise', missing_policy='raise', old={'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5})\n&gt;&gt;&gt; frame = pl.DataFrame({\"old\": [\"a\", \"b\", \"c\", \"d\", \"e\"]})\n&gt;&gt;&gt; frame\nshape: (5, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 old \u2502\n\u2502 --- \u2502\n\u2502 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2502\n\u2502 b   \u2502\n\u2502 c   \u2502\n\u2502 d   \u2502\n\u2502 e   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 old \u2506 new \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 str \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1   \u2502\n\u2502 b   \u2506 2   \u2502\n\u2502 c   \u2506 3   \u2502\n\u2502 d   \u2506 4   \u2502\n\u2502 e   \u2506 5   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; transformer = ReplaceStrict(\n...     in_col=\"old\",\n...     out_col=\"new\",\n...     old={\"a\": 1, \"b\": 2, \"c\": 3},\n...     default=None,\n... )\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 old \u2506 new  \u2502\n\u2502 --- \u2506 ---  \u2502\n\u2502 str \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1    \u2502\n\u2502 b   \u2506 2    \u2502\n\u2502 c   \u2506 3    \u2502\n\u2502 d   \u2506 null \u2502\n\u2502 e   \u2506 null \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ReplaceStrictTransformer","title":"grizz.transformer.ReplaceStrictTransformer","text":"<p>               Bases: <code>BaseIn1Out1Transformer</code></p> <p>Replace the values in a column by the values in a mapping.</p> <p>Parameters:</p> Name Type Description Default <code>in_col</code> <code>str</code> <p>The input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments to pass to <code>replace</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ReplaceStrict\n&gt;&gt;&gt; transformer = ReplaceStrict(\n...     in_col=\"old\", out_col=\"new\", old={\"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4, \"e\": 5}\n... )\n&gt;&gt;&gt; transformer\nReplaceStrictTransformer(in_col='old', out_col='new', exist_policy='raise', missing_policy='raise', old={'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5})\n&gt;&gt;&gt; frame = pl.DataFrame({\"old\": [\"a\", \"b\", \"c\", \"d\", \"e\"]})\n&gt;&gt;&gt; frame\nshape: (5, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 old \u2502\n\u2502 --- \u2502\n\u2502 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2502\n\u2502 b   \u2502\n\u2502 c   \u2502\n\u2502 d   \u2502\n\u2502 e   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 old \u2506 new \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 str \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1   \u2502\n\u2502 b   \u2506 2   \u2502\n\u2502 c   \u2506 3   \u2502\n\u2502 d   \u2506 4   \u2502\n\u2502 e   \u2506 5   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; transformer = ReplaceStrict(\n...     in_col=\"old\",\n...     out_col=\"new\",\n...     old={\"a\": 1, \"b\": 2, \"c\": 3},\n...     default=None,\n... )\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 old \u2506 new  \u2502\n\u2502 --- \u2506 ---  \u2502\n\u2502 str \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1    \u2502\n\u2502 b   \u2506 2    \u2502\n\u2502 c   \u2506 3    \u2502\n\u2502 d   \u2506 null \u2502\n\u2502 e   \u2506 null \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ReplaceTransformer","title":"grizz.transformer.ReplaceTransformer","text":"<p>               Bases: <code>BaseIn1Out1Transformer</code></p> <p>Replace the values in a column by the values in a mapping.</p> <p>Parameters:</p> Name Type Description Default <code>in_col</code> <code>str</code> <p>The input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments to pass to <code>replace</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Replace\n&gt;&gt;&gt; transformer = Replace(in_col=\"old\", out_col=\"new\", old={\"a\": 1, \"b\": 2, \"c\": 3})\n&gt;&gt;&gt; transformer\nReplaceTransformer(in_col='old', out_col='new', exist_policy='raise', missing_policy='raise', old={'a': 1, 'b': 2, 'c': 3})\n&gt;&gt;&gt; frame = pl.DataFrame({\"old\": [\"a\", \"b\", \"c\", \"d\", \"e\"]})\n&gt;&gt;&gt; frame\nshape: (5, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 old \u2502\n\u2502 --- \u2502\n\u2502 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2502\n\u2502 b   \u2502\n\u2502 c   \u2502\n\u2502 d   \u2502\n\u2502 e   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 old \u2506 new \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 str \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1   \u2502\n\u2502 b   \u2506 2   \u2502\n\u2502 c   \u2506 3   \u2502\n\u2502 d   \u2506 d   \u2502\n\u2502 e   \u2506 e   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; transformer = Replace(\n...     in_col=\"old\",\n...     out_col=\"new\",\n...     old={\"a\": 1, \"b\": 2, \"c\": 3},\n...     default=None,\n... )\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 old \u2506 new  \u2502\n\u2502 --- \u2506 ---  \u2502\n\u2502 str \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1    \u2502\n\u2502 b   \u2506 2    \u2502\n\u2502 c   \u2506 3    \u2502\n\u2502 d   \u2506 null \u2502\n\u2502 e   \u2506 null \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.Sequential","title":"grizz.transformer.Sequential","text":"<p>               Bases: <code>BaseTransformer</code></p> <p>Implement a <code>polars.DataFrame</code> transformer to apply sequentially several transformers.</p> <p>Parameters:</p> Name Type Description Default <code>transformers</code> <code>Sequence[BaseTransformer | dict]</code> <p>The transformers or their configurations.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import (\n...     Sequential,\n...     Cast,\n... )\n&gt;&gt;&gt; transformer = Sequential(\n...     [\n...         Cast(columns=[\"col1\"], dtype=pl.Float32),\n...         Cast(columns=[\"col2\"], dtype=pl.Int64),\n...     ]\n... )\n&gt;&gt;&gt; transformer\nSequentialTransformer(\n  (0): CastTransformer(columns=('col1',), dtype=Float32, exclude_columns=(), missing_policy='raise')\n  (1): CastTransformer(columns=('col2',), dtype=Int64, exclude_columns=(), missing_policy='raise')\n)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...         \"col4\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3  \u2506 col4  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---   \u2506 ---   \u2502\n\u2502 i64  \u2506 str  \u2506 str   \u2506 str   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 a     \u2506 a     \u2502\n\u2502 2    \u2506 2    \u2506  b    \u2506  b    \u2502\n\u2502 3    \u2506 3    \u2506   c   \u2506   c   \u2502\n\u2502 4    \u2506 4    \u2506 d     \u2506 d     \u2502\n\u2502 5    \u2506 5    \u2506 e     \u2506 e     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3  \u2506 col4  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---   \u2506 ---   \u2502\n\u2502 f32  \u2506 i64  \u2506 str   \u2506 str   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0  \u2506 1    \u2506 a     \u2506 a     \u2502\n\u2502 2.0  \u2506 2    \u2506  b    \u2506  b    \u2502\n\u2502 3.0  \u2506 3    \u2506   c   \u2506   c   \u2502\n\u2502 4.0  \u2506 4    \u2506 d     \u2506 d     \u2502\n\u2502 5.0  \u2506 5    \u2506 e     \u2506 e     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.SequentialTransformer","title":"grizz.transformer.SequentialTransformer","text":"<p>               Bases: <code>BaseTransformer</code></p> <p>Implement a <code>polars.DataFrame</code> transformer to apply sequentially several transformers.</p> <p>Parameters:</p> Name Type Description Default <code>transformers</code> <code>Sequence[BaseTransformer | dict]</code> <p>The transformers or their configurations.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import (\n...     Sequential,\n...     Cast,\n... )\n&gt;&gt;&gt; transformer = Sequential(\n...     [\n...         Cast(columns=[\"col1\"], dtype=pl.Float32),\n...         Cast(columns=[\"col2\"], dtype=pl.Int64),\n...     ]\n... )\n&gt;&gt;&gt; transformer\nSequentialTransformer(\n  (0): CastTransformer(columns=('col1',), dtype=Float32, exclude_columns=(), missing_policy='raise')\n  (1): CastTransformer(columns=('col2',), dtype=Int64, exclude_columns=(), missing_policy='raise')\n)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...         \"col4\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3  \u2506 col4  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---   \u2506 ---   \u2502\n\u2502 i64  \u2506 str  \u2506 str   \u2506 str   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 a     \u2506 a     \u2502\n\u2502 2    \u2506 2    \u2506  b    \u2506  b    \u2502\n\u2502 3    \u2506 3    \u2506   c   \u2506   c   \u2502\n\u2502 4    \u2506 4    \u2506 d     \u2506 d     \u2502\n\u2502 5    \u2506 5    \u2506 e     \u2506 e     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3  \u2506 col4  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---   \u2506 ---   \u2502\n\u2502 f32  \u2506 i64  \u2506 str   \u2506 str   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0  \u2506 1    \u2506 a     \u2506 a     \u2502\n\u2502 2.0  \u2506 2    \u2506  b    \u2506  b    \u2502\n\u2502 3.0  \u2506 3    \u2506   c   \u2506   c   \u2502\n\u2502 4.0  \u2506 4    \u2506 d     \u2506 d     \u2502\n\u2502 5.0  \u2506 5    \u2506 e     \u2506 e     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.Sort","title":"grizz.transformer.Sort","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to sort the DataFrame by the given columns.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to use to sort the rows.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments to pass to <code>sort</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Sort\n&gt;&gt;&gt; transformer = Sort(columns=[\"col3\", \"col1\"])\n&gt;&gt;&gt; transformer\nSortTransformer(columns=('col3', 'col1'), exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\"col1\": [1, 2, None], \"col2\": [6.0, 5.0, 4.0], \"col3\": [\"a\", \"c\", \"b\"]}\n... )\n&gt;&gt;&gt; frame\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 f64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 6.0  \u2506 a    \u2502\n\u2502 2    \u2506 5.0  \u2506 c    \u2502\n\u2502 null \u2506 4.0  \u2506 b    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 f64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 6.0  \u2506 a    \u2502\n\u2502 null \u2506 4.0  \u2506 b    \u2502\n\u2502 2    \u2506 5.0  \u2506 c    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.SortColumns","title":"grizz.transformer.SortColumns","text":"<p>               Bases: <code>BaseTransformer</code></p> <p>Implement a transformer to sort the DataFrame columns by name.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>If set to <code>False</code>, then the columns are sorted by alphabetical order.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import SortColumns\n&gt;&gt;&gt; transformer = SortColumns()\n&gt;&gt;&gt; transformer\nSortColumnsTransformer(reverse=False)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\"col2\": [1, 2, None], \"col3\": [6.0, 5.0, 4.0], \"col1\": [\"a\", \"c\", \"b\"]}\n... )\n&gt;&gt;&gt; frame\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col2 \u2506 col3 \u2506 col1 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 f64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 6.0  \u2506 a    \u2502\n\u2502 2    \u2506 5.0  \u2506 c    \u2502\n\u2502 null \u2506 4.0  \u2506 b    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 str  \u2506 i64  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a    \u2506 1    \u2506 6.0  \u2502\n\u2502 c    \u2506 2    \u2506 5.0  \u2502\n\u2502 b    \u2506 null \u2506 4.0  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.SortColumnsTransformer","title":"grizz.transformer.SortColumnsTransformer","text":"<p>               Bases: <code>BaseTransformer</code></p> <p>Implement a transformer to sort the DataFrame columns by name.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>If set to <code>False</code>, then the columns are sorted by alphabetical order.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import SortColumns\n&gt;&gt;&gt; transformer = SortColumns()\n&gt;&gt;&gt; transformer\nSortColumnsTransformer(reverse=False)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\"col2\": [1, 2, None], \"col3\": [6.0, 5.0, 4.0], \"col1\": [\"a\", \"c\", \"b\"]}\n... )\n&gt;&gt;&gt; frame\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col2 \u2506 col3 \u2506 col1 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 f64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 6.0  \u2506 a    \u2502\n\u2502 2    \u2506 5.0  \u2506 c    \u2502\n\u2502 null \u2506 4.0  \u2506 b    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 str  \u2506 i64  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a    \u2506 1    \u2506 6.0  \u2502\n\u2502 c    \u2506 2    \u2506 5.0  \u2502\n\u2502 b    \u2506 null \u2506 4.0  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.SortTransformer","title":"grizz.transformer.SortTransformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to sort the DataFrame by the given columns.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to use to sort the rows.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments to pass to <code>sort</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Sort\n&gt;&gt;&gt; transformer = Sort(columns=[\"col3\", \"col1\"])\n&gt;&gt;&gt; transformer\nSortTransformer(columns=('col3', 'col1'), exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\"col1\": [1, 2, None], \"col2\": [6.0, 5.0, 4.0], \"col3\": [\"a\", \"c\", \"b\"]}\n... )\n&gt;&gt;&gt; frame\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 f64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 6.0  \u2506 a    \u2502\n\u2502 2    \u2506 5.0  \u2506 c    \u2502\n\u2502 null \u2506 4.0  \u2506 b    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 f64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 6.0  \u2506 a    \u2502\n\u2502 null \u2506 4.0  \u2506 b    \u2502\n\u2502 2    \u2506 5.0  \u2506 c    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.SqlTransformer","title":"grizz.transformer.SqlTransformer","text":"<p>               Bases: <code>BaseTransformer</code></p> <p>Implement a transformer that execute a SQL query against the DataFrame..</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The SQL query to execute.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import SqlTransformer\n&gt;&gt;&gt; transformer = SqlTransformer(query=\"SELECT col1, col4 FROM self WHERE col1 &gt; 2\")\n&gt;&gt;&gt; transformer\nSqlTransformer(\n  (query): SELECT col1, col4 FROM self WHERE col1 &gt; 2\n)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 3    \u2506 c    \u2502\n\u2502 4    \u2506 d    \u2502\n\u2502 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.StripChars","title":"grizz.transformer.StripChars","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to remove leading and trailing characters.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to prepare. If <code>None</code>, it processes all the columns of type string.</p> <code>None</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>strip_chars</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import StripChars\n&gt;&gt;&gt; transformer = StripChars(columns=[\"col2\", \"col3\"])\n&gt;&gt;&gt; transformer\nStripCharsTransformer(columns=('col2', 'col3'), exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...         \"col4\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3  \u2506 col4  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---   \u2506 ---   \u2502\n\u2502 i64  \u2506 str  \u2506 str   \u2506 str   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 a     \u2506 a     \u2502\n\u2502 2    \u2506 2    \u2506  b    \u2506  b    \u2502\n\u2502 3    \u2506 3    \u2506   c   \u2506   c   \u2502\n\u2502 4    \u2506 4    \u2506 d     \u2506 d     \u2502\n\u2502 5    \u2506 5    \u2506 e     \u2506 e     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 a    \u2506 a     \u2502\n\u2502 2    \u2506 2    \u2506 b    \u2506  b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506   c   \u2502\n\u2502 4    \u2506 4    \u2506 d    \u2506 d     \u2502\n\u2502 5    \u2506 5    \u2506 e    \u2506 e     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.StripCharsTransformer","title":"grizz.transformer.StripCharsTransformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to remove leading and trailing characters.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to prepare. If <code>None</code>, it processes all the columns of type string.</p> <code>None</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>strip_chars</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import StripChars\n&gt;&gt;&gt; transformer = StripChars(columns=[\"col2\", \"col3\"])\n&gt;&gt;&gt; transformer\nStripCharsTransformer(columns=('col2', 'col3'), exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...         \"col4\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3  \u2506 col4  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---   \u2506 ---   \u2502\n\u2502 i64  \u2506 str  \u2506 str   \u2506 str   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 a     \u2506 a     \u2502\n\u2502 2    \u2506 2    \u2506  b    \u2506  b    \u2502\n\u2502 3    \u2506 3    \u2506   c   \u2506   c   \u2502\n\u2502 4    \u2506 4    \u2506 d     \u2506 d     \u2502\n\u2502 5    \u2506 5    \u2506 e     \u2506 e     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 a    \u2506 a     \u2502\n\u2502 2    \u2506 2    \u2506 b    \u2506  b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506   c   \u2502\n\u2502 4    \u2506 4    \u2506 d    \u2506 d     \u2502\n\u2502 5    \u2506 5    \u2506 e    \u2506 e     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.SumHorizontal","title":"grizz.transformer.SumHorizontal","text":"<p>               Bases: <code>BaseInNOut1Transformer</code></p> <p>Implement a transformer to sum all values horizontally across columns and store the result in a column.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to sum. The columns should be compatible. If <code>None</code>, it processes all the columns.</p> required <code>out_col</code> <code>str</code> <p>The output column.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import SumHorizontal\n&gt;&gt;&gt; transformer = SumHorizontal(columns=[\"col1\", \"col2\", \"col3\"], out_col=\"col\")\n&gt;&gt;&gt; transformer\nSumHorizontalTransformer(columns=('col1', 'col2', 'col3'), out_col='col', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [11, 12, 13, 14, 15],\n...         \"col2\": [21, 22, 23, 24, 25],\n...         \"col3\": [31, 32, 33, 34, 35],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11   \u2506 21   \u2506 31   \u2506 a    \u2502\n\u2502 12   \u2506 22   \u2506 32   \u2506 b    \u2502\n\u2502 13   \u2506 23   \u2506 33   \u2506 c    \u2502\n\u2502 14   \u2506 24   \u2506 34   \u2506 d    \u2502\n\u2502 15   \u2506 25   \u2506 35   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 --- \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11   \u2506 21   \u2506 31   \u2506 a    \u2506 63  \u2502\n\u2502 12   \u2506 22   \u2506 32   \u2506 b    \u2506 66  \u2502\n\u2502 13   \u2506 23   \u2506 33   \u2506 c    \u2506 69  \u2502\n\u2502 14   \u2506 24   \u2506 34   \u2506 d    \u2506 72  \u2502\n\u2502 15   \u2506 25   \u2506 35   \u2506 e    \u2506 75  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.SumHorizontalTransformer","title":"grizz.transformer.SumHorizontalTransformer","text":"<p>               Bases: <code>BaseInNOut1Transformer</code></p> <p>Implement a transformer to sum all values horizontally across columns and store the result in a column.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to sum. The columns should be compatible. If <code>None</code>, it processes all the columns.</p> required <code>out_col</code> <code>str</code> <p>The output column.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import SumHorizontal\n&gt;&gt;&gt; transformer = SumHorizontal(columns=[\"col1\", \"col2\", \"col3\"], out_col=\"col\")\n&gt;&gt;&gt; transformer\nSumHorizontalTransformer(columns=('col1', 'col2', 'col3'), out_col='col', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [11, 12, 13, 14, 15],\n...         \"col2\": [21, 22, 23, 24, 25],\n...         \"col3\": [31, 32, 33, 34, 35],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11   \u2506 21   \u2506 31   \u2506 a    \u2502\n\u2502 12   \u2506 22   \u2506 32   \u2506 b    \u2502\n\u2502 13   \u2506 23   \u2506 33   \u2506 c    \u2502\n\u2502 14   \u2506 24   \u2506 34   \u2506 d    \u2502\n\u2502 15   \u2506 25   \u2506 35   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 --- \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11   \u2506 21   \u2506 31   \u2506 a    \u2506 63  \u2502\n\u2502 12   \u2506 22   \u2506 32   \u2506 b    \u2506 66  \u2502\n\u2502 13   \u2506 23   \u2506 33   \u2506 c    \u2506 69  \u2502\n\u2502 14   \u2506 24   \u2506 34   \u2506 d    \u2506 72  \u2502\n\u2502 15   \u2506 25   \u2506 35   \u2506 e    \u2506 75  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.TimeDiff","title":"grizz.transformer.TimeDiff","text":"<p>               Bases: <code>BaseTransformer</code></p> <p>Implement a transformer to compute the time difference between consecutive time steps.</p> <p>Parameters:</p> Name Type Description Default <code>group_cols</code> <code>Sequence[str]</code> <p>The columns used to generate the group for each sequence.</p> required <code>time_col</code> <code>str</code> <p>The input time column name.</p> required <code>time_diff_col</code> <code>str</code> <p>The output time difference column name.</p> required <code>shift</code> <code>int</code> <p>The number of slots to shift.</p> <code>1</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import TimeDiff\n&gt;&gt;&gt; transformer = TimeDiff(group_cols=[\"col\"], time_col=\"time\", time_diff_col=\"diff\")\n&gt;&gt;&gt; transformer\nTimeDiffTransformer(group_cols=['col'], time_col='time', time_diff_col='diff', shift=1)\n&gt;&gt;&gt; frame = pl.DataFrame({\"col\": [\"a\", \"b\", \"a\", \"a\", \"b\"], \"time\": [1, 2, 3, 4, 5]})\n&gt;&gt;&gt; frame\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col \u2506 time \u2502\n\u2502 --- \u2506 ---  \u2502\n\u2502 str \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1    \u2502\n\u2502 b   \u2506 2    \u2502\n\u2502 a   \u2506 3    \u2502\n\u2502 a   \u2506 4    \u2502\n\u2502 b   \u2506 5    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col \u2506 time \u2506 diff \u2502\n\u2502 --- \u2506 ---  \u2506 ---  \u2502\n\u2502 str \u2506 i64  \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1    \u2506 0    \u2502\n\u2502 a   \u2506 3    \u2506 2    \u2502\n\u2502 a   \u2506 4    \u2506 1    \u2502\n\u2502 b   \u2506 2    \u2506 0    \u2502\n\u2502 b   \u2506 5    \u2506 3    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.TimeDiffTransformer","title":"grizz.transformer.TimeDiffTransformer","text":"<p>               Bases: <code>BaseTransformer</code></p> <p>Implement a transformer to compute the time difference between consecutive time steps.</p> <p>Parameters:</p> Name Type Description Default <code>group_cols</code> <code>Sequence[str]</code> <p>The columns used to generate the group for each sequence.</p> required <code>time_col</code> <code>str</code> <p>The input time column name.</p> required <code>time_diff_col</code> <code>str</code> <p>The output time difference column name.</p> required <code>shift</code> <code>int</code> <p>The number of slots to shift.</p> <code>1</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import TimeDiff\n&gt;&gt;&gt; transformer = TimeDiff(group_cols=[\"col\"], time_col=\"time\", time_diff_col=\"diff\")\n&gt;&gt;&gt; transformer\nTimeDiffTransformer(group_cols=['col'], time_col='time', time_diff_col='diff', shift=1)\n&gt;&gt;&gt; frame = pl.DataFrame({\"col\": [\"a\", \"b\", \"a\", \"a\", \"b\"], \"time\": [1, 2, 3, 4, 5]})\n&gt;&gt;&gt; frame\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col \u2506 time \u2502\n\u2502 --- \u2506 ---  \u2502\n\u2502 str \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1    \u2502\n\u2502 b   \u2506 2    \u2502\n\u2502 a   \u2506 3    \u2502\n\u2502 a   \u2506 4    \u2502\n\u2502 b   \u2506 5    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col \u2506 time \u2506 diff \u2502\n\u2502 --- \u2506 ---  \u2506 ---  \u2502\n\u2502 str \u2506 i64  \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1    \u2506 0    \u2502\n\u2502 a   \u2506 3    \u2506 2    \u2502\n\u2502 a   \u2506 4    \u2506 1    \u2502\n\u2502 b   \u2506 2    \u2506 0    \u2502\n\u2502 b   \u2506 5    \u2506 3    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.TimeToSecond","title":"grizz.transformer.TimeToSecond","text":"<p>               Bases: <code>BaseIn1Out1Transformer</code></p> <p>Implement a transformer to convert a column with time values to seconds.</p> <p>Parameters:</p> Name Type Description Default <code>in_col</code> <code>str</code> <p>The input column with the time value to convert.</p> required <code>out_col</code> <code>str</code> <p>The output column with the time in seconds.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import datetime\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import TimeToSecond\n&gt;&gt;&gt; transformer = TimeToSecond(in_col=\"time\", out_col=\"second\")\n&gt;&gt;&gt; transformer\nTimeToSecondTransformer(in_col='time', out_col='second', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"time\": [\n...             datetime.time(0, 0, 1, 890000),\n...             datetime.time(0, 1, 1, 890000),\n...             datetime.time(1, 1, 1, 890000),\n...             datetime.time(0, 19, 19, 890000),\n...             datetime.time(19, 19, 19, 890000),\n...         ],\n...         \"col\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     },\n...     schema={\"time\": pl.Time, \"col\": pl.String},\n... )\n&gt;&gt;&gt; frame\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 time         \u2506 col \u2502\n\u2502 ---          \u2506 --- \u2502\n\u2502 time         \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 00:00:01.890 \u2506 a   \u2502\n\u2502 00:01:01.890 \u2506 b   \u2502\n\u2502 01:01:01.890 \u2506 c   \u2502\n\u2502 00:19:19.890 \u2506 d   \u2502\n\u2502 19:19:19.890 \u2506 e   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 time         \u2506 col \u2506 second   \u2502\n\u2502 ---          \u2506 --- \u2506 ---      \u2502\n\u2502 time         \u2506 str \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 00:00:01.890 \u2506 a   \u2506 1.89     \u2502\n\u2502 00:01:01.890 \u2506 b   \u2506 61.89    \u2502\n\u2502 01:01:01.890 \u2506 c   \u2506 3661.89  \u2502\n\u2502 00:19:19.890 \u2506 d   \u2506 1159.89  \u2502\n\u2502 19:19:19.890 \u2506 e   \u2506 69559.89 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.TimeToSecondTransformer","title":"grizz.transformer.TimeToSecondTransformer","text":"<p>               Bases: <code>BaseIn1Out1Transformer</code></p> <p>Implement a transformer to convert a column with time values to seconds.</p> <p>Parameters:</p> Name Type Description Default <code>in_col</code> <code>str</code> <p>The input column with the time value to convert.</p> required <code>out_col</code> <code>str</code> <p>The output column with the time in seconds.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import datetime\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import TimeToSecond\n&gt;&gt;&gt; transformer = TimeToSecond(in_col=\"time\", out_col=\"second\")\n&gt;&gt;&gt; transformer\nTimeToSecondTransformer(in_col='time', out_col='second', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"time\": [\n...             datetime.time(0, 0, 1, 890000),\n...             datetime.time(0, 1, 1, 890000),\n...             datetime.time(1, 1, 1, 890000),\n...             datetime.time(0, 19, 19, 890000),\n...             datetime.time(19, 19, 19, 890000),\n...         ],\n...         \"col\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     },\n...     schema={\"time\": pl.Time, \"col\": pl.String},\n... )\n&gt;&gt;&gt; frame\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 time         \u2506 col \u2502\n\u2502 ---          \u2506 --- \u2502\n\u2502 time         \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 00:00:01.890 \u2506 a   \u2502\n\u2502 00:01:01.890 \u2506 b   \u2502\n\u2502 01:01:01.890 \u2506 c   \u2502\n\u2502 00:19:19.890 \u2506 d   \u2502\n\u2502 19:19:19.890 \u2506 e   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 time         \u2506 col \u2506 second   \u2502\n\u2502 ---          \u2506 --- \u2506 ---      \u2502\n\u2502 time         \u2506 str \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 00:00:01.890 \u2506 a   \u2506 1.89     \u2502\n\u2502 00:01:01.890 \u2506 b   \u2506 61.89    \u2502\n\u2502 01:01:01.890 \u2506 c   \u2506 3661.89  \u2502\n\u2502 00:19:19.890 \u2506 d   \u2506 1159.89  \u2502\n\u2502 19:19:19.890 \u2506 e   \u2506 69559.89 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ToDatetime","title":"grizz.transformer.ToDatetime","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to convert some columns to a <code>polars.Datetime</code> type.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to convert. <code>None</code> means all the columns.</p> <code>None</code> <code>format</code> <code>str | None</code> <p>Format to use for conversion. Refer to the chrono crate documentation for the full specification. Example: <code>\"%Y-%m-%d %H:%M:%S\"</code>. If set to <code>None</code> (default), the format is inferred from the data.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>to_datetime</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ToDatetime\n&gt;&gt;&gt; transformer = ToDatetime(columns=[\"col1\"])\n&gt;&gt;&gt; transformer\nToDatetimeTransformer(columns=('col1',), format=None, exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [\n...             \"2020-01-01 01:01:01\",\n...             \"2020-01-01 02:02:02\",\n...             \"2020-01-01 12:00:01\",\n...             \"2020-01-01 18:18:18\",\n...             \"2020-01-01 23:59:59\",\n...         ],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\n...             \"2020-01-01 11:11:11\",\n...             \"2020-02-01 12:12:12\",\n...             \"2020-03-01 13:13:13\",\n...             \"2020-04-01 08:08:08\",\n...             \"2020-05-01 23:59:59\",\n...         ],\n...     },\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1                \u2506 col2 \u2506 col3                \u2502\n\u2502 ---                 \u2506 ---  \u2506 ---                 \u2502\n\u2502 str                 \u2506 str  \u2506 str                 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-01-01 01:01:01 \u2506 1    \u2506 2020-01-01 11:11:11 \u2502\n\u2502 2020-01-01 02:02:02 \u2506 2    \u2506 2020-02-01 12:12:12 \u2502\n\u2502 2020-01-01 12:00:01 \u2506 3    \u2506 2020-03-01 13:13:13 \u2502\n\u2502 2020-01-01 18:18:18 \u2506 4    \u2506 2020-04-01 08:08:08 \u2502\n\u2502 2020-01-01 23:59:59 \u2506 5    \u2506 2020-05-01 23:59:59 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1                \u2506 col2 \u2506 col3                \u2502\n\u2502 ---                 \u2506 ---  \u2506 ---                 \u2502\n\u2502 datetime[\u03bcs]        \u2506 str  \u2506 str                 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-01-01 01:01:01 \u2506 1    \u2506 2020-01-01 11:11:11 \u2502\n\u2502 2020-01-01 02:02:02 \u2506 2    \u2506 2020-02-01 12:12:12 \u2502\n\u2502 2020-01-01 12:00:01 \u2506 3    \u2506 2020-03-01 13:13:13 \u2502\n\u2502 2020-01-01 18:18:18 \u2506 4    \u2506 2020-04-01 08:08:08 \u2502\n\u2502 2020-01-01 23:59:59 \u2506 5    \u2506 2020-05-01 23:59:59 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ToDatetimeTransformer","title":"grizz.transformer.ToDatetimeTransformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to convert some columns to a <code>polars.Datetime</code> type.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to convert. <code>None</code> means all the columns.</p> <code>None</code> <code>format</code> <code>str | None</code> <p>Format to use for conversion. Refer to the chrono crate documentation for the full specification. Example: <code>\"%Y-%m-%d %H:%M:%S\"</code>. If set to <code>None</code> (default), the format is inferred from the data.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>to_datetime</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ToDatetime\n&gt;&gt;&gt; transformer = ToDatetime(columns=[\"col1\"])\n&gt;&gt;&gt; transformer\nToDatetimeTransformer(columns=('col1',), format=None, exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [\n...             \"2020-01-01 01:01:01\",\n...             \"2020-01-01 02:02:02\",\n...             \"2020-01-01 12:00:01\",\n...             \"2020-01-01 18:18:18\",\n...             \"2020-01-01 23:59:59\",\n...         ],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\n...             \"2020-01-01 11:11:11\",\n...             \"2020-02-01 12:12:12\",\n...             \"2020-03-01 13:13:13\",\n...             \"2020-04-01 08:08:08\",\n...             \"2020-05-01 23:59:59\",\n...         ],\n...     },\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1                \u2506 col2 \u2506 col3                \u2502\n\u2502 ---                 \u2506 ---  \u2506 ---                 \u2502\n\u2502 str                 \u2506 str  \u2506 str                 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-01-01 01:01:01 \u2506 1    \u2506 2020-01-01 11:11:11 \u2502\n\u2502 2020-01-01 02:02:02 \u2506 2    \u2506 2020-02-01 12:12:12 \u2502\n\u2502 2020-01-01 12:00:01 \u2506 3    \u2506 2020-03-01 13:13:13 \u2502\n\u2502 2020-01-01 18:18:18 \u2506 4    \u2506 2020-04-01 08:08:08 \u2502\n\u2502 2020-01-01 23:59:59 \u2506 5    \u2506 2020-05-01 23:59:59 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1                \u2506 col2 \u2506 col3                \u2502\n\u2502 ---                 \u2506 ---  \u2506 ---                 \u2502\n\u2502 datetime[\u03bcs]        \u2506 str  \u2506 str                 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-01-01 01:01:01 \u2506 1    \u2506 2020-01-01 11:11:11 \u2502\n\u2502 2020-01-01 02:02:02 \u2506 2    \u2506 2020-02-01 12:12:12 \u2502\n\u2502 2020-01-01 12:00:01 \u2506 3    \u2506 2020-03-01 13:13:13 \u2502\n\u2502 2020-01-01 18:18:18 \u2506 4    \u2506 2020-04-01 08:08:08 \u2502\n\u2502 2020-01-01 23:59:59 \u2506 5    \u2506 2020-05-01 23:59:59 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ToTime","title":"grizz.transformer.ToTime","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to convert some columns to a <code>polars.Time</code> type.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to convert. <code>None</code> means all the columns.</p> required <code>format</code> <code>str | None</code> <p>Format to use for conversion. Refer to the chrono crate documentation for the full specification. Example: <code>\"%H:%M:%S\"</code>. If set to <code>None</code> (default), the format is inferred from the data.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>to_time</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ToTime\n&gt;&gt;&gt; transformer = ToTime(columns=[\"col1\"], format=\"%H:%M:%S\")\n&gt;&gt;&gt; transformer\nToTimeTransformer(columns=('col1',), format='%H:%M:%S', exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [\"01:01:01\", \"02:02:02\", \"12:00:01\", \"18:18:18\", \"23:59:59\"],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"01:01:01\", \"02:02:02\", \"12:00:01\", \"18:18:18\", \"23:59:59\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1     \u2506 col2 \u2506 col3     \u2502\n\u2502 ---      \u2506 ---  \u2506 ---      \u2502\n\u2502 str      \u2506 str  \u2506 str      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 01:01:01 \u2506 1    \u2506 01:01:01 \u2502\n\u2502 02:02:02 \u2506 2    \u2506 02:02:02 \u2502\n\u2502 12:00:01 \u2506 3    \u2506 12:00:01 \u2502\n\u2502 18:18:18 \u2506 4    \u2506 18:18:18 \u2502\n\u2502 23:59:59 \u2506 5    \u2506 23:59:59 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1     \u2506 col2 \u2506 col3     \u2502\n\u2502 ---      \u2506 ---  \u2506 ---      \u2502\n\u2502 time     \u2506 str  \u2506 str      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 01:01:01 \u2506 1    \u2506 01:01:01 \u2502\n\u2502 02:02:02 \u2506 2    \u2506 02:02:02 \u2502\n\u2502 12:00:01 \u2506 3    \u2506 12:00:01 \u2502\n\u2502 18:18:18 \u2506 4    \u2506 18:18:18 \u2502\n\u2502 23:59:59 \u2506 5    \u2506 23:59:59 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ToTimeTransformer","title":"grizz.transformer.ToTimeTransformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to convert some columns to a <code>polars.Time</code> type.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to convert. <code>None</code> means all the columns.</p> required <code>format</code> <code>str | None</code> <p>Format to use for conversion. Refer to the chrono crate documentation for the full specification. Example: <code>\"%H:%M:%S\"</code>. If set to <code>None</code> (default), the format is inferred from the data.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>to_time</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ToTime\n&gt;&gt;&gt; transformer = ToTime(columns=[\"col1\"], format=\"%H:%M:%S\")\n&gt;&gt;&gt; transformer\nToTimeTransformer(columns=('col1',), format='%H:%M:%S', exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [\"01:01:01\", \"02:02:02\", \"12:00:01\", \"18:18:18\", \"23:59:59\"],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"01:01:01\", \"02:02:02\", \"12:00:01\", \"18:18:18\", \"23:59:59\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1     \u2506 col2 \u2506 col3     \u2502\n\u2502 ---      \u2506 ---  \u2506 ---      \u2502\n\u2502 str      \u2506 str  \u2506 str      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 01:01:01 \u2506 1    \u2506 01:01:01 \u2502\n\u2502 02:02:02 \u2506 2    \u2506 02:02:02 \u2502\n\u2502 12:00:01 \u2506 3    \u2506 12:00:01 \u2502\n\u2502 18:18:18 \u2506 4    \u2506 18:18:18 \u2502\n\u2502 23:59:59 \u2506 5    \u2506 23:59:59 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1     \u2506 col2 \u2506 col3     \u2502\n\u2502 ---      \u2506 ---  \u2506 ---      \u2502\n\u2502 time     \u2506 str  \u2506 str      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 01:01:01 \u2506 1    \u2506 01:01:01 \u2502\n\u2502 02:02:02 \u2506 2    \u2506 02:02:02 \u2502\n\u2502 12:00:01 \u2506 3    \u2506 12:00:01 \u2502\n\u2502 18:18:18 \u2506 4    \u2506 18:18:18 \u2502\n\u2502 23:59:59 \u2506 5    \u2506 23:59:59 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.is_transformer_config","title":"grizz.transformer.is_transformer_config","text":"<pre><code>is_transformer_config(config: dict) -&gt; bool\n</code></pre> <p>Indicate if the input configuration is a configuration for a <code>BaseTransformer</code>.</p> <p>This function only checks if the value of the key  <code>_target_</code> is valid. It does not check the other values. If <code>_target_</code> indicates a function, the returned type hint is used to check the class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input configuration is a configuration for a <code>BaseTransformer</code> object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import is_transformer_config\n&gt;&gt;&gt; is_transformer_config(\n...     {\n...         \"_target_\": \"grizz.transformer.Cast\",\n...         \"columns\": (\"col1\", \"col3\"),\n...         \"dtype\": pl.Int32,\n...     }\n... )\nTrue\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.setup_transformer","title":"grizz.transformer.setup_transformer","text":"<pre><code>setup_transformer(\n    transformer: BaseTransformer | dict,\n) -&gt; BaseTransformer\n</code></pre> <p>Set up a <code>polars.DataFrame</code> transformer.</p> <p>The transformer is instantiated from its configuration by using the <code>BaseTransformer</code> factory function.</p> <p>Parameters:</p> Name Type Description Default <code>transformer</code> <code>BaseTransformer | dict</code> <p>Specifies a <code>polars.DataFrame</code> transformer or its configuration.</p> required <p>Returns:</p> Type Description <code>BaseTransformer</code> <p>An instantiated transformer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import setup_transformer\n&gt;&gt;&gt; transformer = setup_transformer(\n...     {\n...         \"_target_\": \"grizz.transformer.Cast\",\n...         \"columns\": (\"col1\", \"col3\"),\n...         \"dtype\": pl.Int32,\n...     }\n... )\n&gt;&gt;&gt; transformer\nCastTransformer(columns=('col1', 'col3'), dtype=Int32, exclude_columns=(), missing_policy='raise')\n</code></pre>"},{"location":"refs/utils/","title":"utils","text":""},{"location":"refs/utils/#grizz.utils","title":"grizz.utils","text":"<p>Contain utility functions.</p>"},{"location":"refs/utils/#grizz.utils.column","title":"grizz.utils.column","text":"<p>Contain DataFrame columns utility functions.</p>"},{"location":"refs/utils/#grizz.utils.column.check_column_exist_policy","title":"grizz.utils.column.check_column_exist_policy","text":"<pre><code>check_column_exist_policy(exist_policy: str) -&gt; None\n</code></pre> <p>Check the policy on how to handle existing columns.</p> <p>Parameters:</p> Name Type Description Default <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>exist_policy</code> is not <code>'ignore'</code>, <code>'warn'</code>, or <code>'raise'</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.column import check_column_exist_policy\n&gt;&gt;&gt; check_column_exist_policy(\"ignore\")\n</code></pre>"},{"location":"refs/utils/#grizz.utils.column.check_column_missing_policy","title":"grizz.utils.column.check_column_missing_policy","text":"<pre><code>check_column_missing_policy(missing_policy: str) -&gt; None\n</code></pre> <p>Check the policy on how to handle missing columns.</p> <p>Parameters:</p> Name Type Description Default <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>missing_policy</code> is not <code>'ignore'</code>, <code>'warn'</code>, or <code>'raise'</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.column import check_column_missing_policy\n&gt;&gt;&gt; check_column_missing_policy(\"ignore\")\n</code></pre>"},{"location":"refs/utils/#grizz.utils.column.check_existing_column","title":"grizz.utils.column.check_existing_column","text":"<pre><code>check_existing_column(\n    frame_or_cols: DataFrame | Sequence,\n    column: str,\n    exist_policy: str = \"raise\",\n) -&gt; None\n</code></pre> <p>Check if a column already exists.</p> <p>Parameters:</p> Name Type Description Default <code>frame_or_cols</code> <code>DataFrame | Sequence</code> <p>The DataFrame or its columns.</p> required <code>column</code> <code>str</code> <p>The column to check.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised the column already exists. If <code>'warn'</code>, a warning is raised if the column already exists and the existing column is overwritten. If <code>'ignore'</code>, the existing column is overwritten and no warning message appears.</p> <code>'raise'</code> <p>Raises:</p> Type Description <code>ColumnExistsError</code> <p>if at least one column already exists and <code>exist_policy='raise'</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.utils.column import check_existing_column\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...         \"col4\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; check_existing_column(frame, \"col1\", exist_policy=\"warn\")\n</code></pre>"},{"location":"refs/utils/#grizz.utils.column.check_existing_columns","title":"grizz.utils.column.check_existing_columns","text":"<pre><code>check_existing_columns(\n    frame_or_cols: DataFrame | Sequence,\n    columns: Sequence,\n    exist_policy: str = \"raise\",\n) -&gt; None\n</code></pre> <p>Check if some columns already exist.</p> <p>Parameters:</p> Name Type Description Default <code>frame_or_cols</code> <code>DataFrame | Sequence</code> <p>The DataFrame or its columns.</p> required <code>columns</code> <code>Sequence</code> <p>The columns to check.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <p>Raises:</p> Type Description <code>ColumnExistsError</code> <p>if at least one column already exists and <code>exist_policy='raise'</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.utils.column import check_existing_columns\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...         \"col4\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; check_existing_columns(frame, [\"col1\", \"col5\"], exist_policy=\"warn\")\n</code></pre>"},{"location":"refs/utils/#grizz.utils.column.check_missing_column","title":"grizz.utils.column.check_missing_column","text":"<pre><code>check_missing_column(\n    frame_or_cols: DataFrame | Sequence,\n    column: str,\n    missing_policy: str = \"raise\",\n) -&gt; None\n</code></pre> <p>Check if a column is missing.</p> <p>Parameters:</p> Name Type Description Default <code>frame_or_cols</code> <code>DataFrame | Sequence</code> <p>The DataFrame or its columns.</p> required <code>column</code> <code>str</code> <p>The column to check.</p> required <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if the column is missing. If <code>'warn'</code>, a warning is raised if the column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing column is ignored and no warning message appears.</p> <code>'raise'</code> <p>Raises:</p> Type Description <code>ColumnNotFoundError</code> <p>if the column is missing and <code>missing_policy='raise'</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.utils.column import check_missing_column\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...         \"col4\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; check_missing_column(frame, \"col1\", missing_policy=\"warn\")\n</code></pre>"},{"location":"refs/utils/#grizz.utils.column.check_missing_columns","title":"grizz.utils.column.check_missing_columns","text":"<pre><code>check_missing_columns(\n    frame_or_cols: DataFrame | Sequence,\n    columns: Sequence,\n    missing_policy: str = \"raise\",\n) -&gt; None\n</code></pre> <p>Check if some columns are missing.</p> <p>Parameters:</p> Name Type Description Default <code>frame_or_cols</code> <code>DataFrame | Sequence</code> <p>The DataFrame or its columns.</p> required <code>columns</code> <code>Sequence</code> <p>The columns to check.</p> required <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Raises:</p> Type Description <code>ColumnNotFoundError</code> <p>if at least one column is missing and <code>missing_policy='raise'</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.utils.column import check_missing_columns\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...         \"col4\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; check_missing_columns(frame, [\"col1\", \"col5\"], missing_policy=\"warn\")\n</code></pre>"},{"location":"refs/utils/#grizz.utils.column.find_common_columns","title":"grizz.utils.column.find_common_columns","text":"<pre><code>find_common_columns(\n    frame_or_cols: DataFrame | Sequence,\n    columns: Sequence[str],\n) -&gt; tuple[str, ...]\n</code></pre> <p>Find the common columns that are both in the DataFrame and the given columns.</p> <p>Parameters:</p> Name Type Description Default <code>frame_or_cols</code> <code>DataFrame | Sequence</code> <p>The DataFrame or its columns.</p> required <code>columns</code> <code>Sequence[str]</code> <p>The columns to check.</p> required <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>The columns i.e. the columns that are both in <code>columns</code> and <code>frame_or_cols</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.utils.column import find_common_columns\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; cols = find_common_columns(frame, columns=[\"col1\", \"col2\", \"col3\", \"col4\"])\n&gt;&gt;&gt; cols\n('col1', 'col2', 'col3')\n</code></pre>"},{"location":"refs/utils/#grizz.utils.column.find_missing_columns","title":"grizz.utils.column.find_missing_columns","text":"<pre><code>find_missing_columns(\n    frame_or_cols: DataFrame | Sequence,\n    columns: Sequence[str],\n) -&gt; tuple[str, ...]\n</code></pre> <p>Find the columns that are in the given columns but not in the DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>frame_or_cols</code> <code>DataFrame | Sequence</code> <p>The DataFrame or its columns.</p> required <code>columns</code> <code>Sequence[str]</code> <p>The columns to check.</p> required <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>The list of missing columns i.e. the columns that are in <code>columns</code> but not in <code>frame_or_cols</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.utils.column import find_missing_columns\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; cols = find_missing_columns(frame, columns=[\"col1\", \"col2\", \"col3\", \"col4\"])\n&gt;&gt;&gt; cols\n('col4',)\n</code></pre>"},{"location":"refs/utils/#grizz.utils.datetime","title":"grizz.utils.datetime","text":"<p>Contain utility functions for datetime and date objects.</p>"},{"location":"refs/utils/#grizz.utils.datetime.find_end_datetime","title":"grizz.utils.datetime.find_end_datetime","text":"<pre><code>find_end_datetime(\n    start: datetime | date,\n    interval: str | timedelta,\n    periods: int,\n) -&gt; datetime\n</code></pre> <p>Find the upper bound of the datetime range from the lower bound of the datetime range, the interval, and the number of periods.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>datetime | date</code> <p>The lower bound of the datetime range.</p> required <code>interval</code> <code>str | timedelta</code> <p>The interval of the range periods, specified as a Python timedelta object or using the Polars duration string language.</p> required <code>periods</code> <code>int</code> <p>The number of periods after the start.</p> required <p>Returns:</p> Type Description <code>datetime</code> <p>The upper bound of the datetime range.</p> Notes <p><code>interval</code> is created according to the following string     language:</p> <pre><code>- 1ns (1 nanosecond)\n- 1us (1 microsecond)\n- 1ms (1 millisecond)\n- 1s (1 second)\n- 1m (1 minute)\n- 1h (1 hour)\n- 1d (1 calendar day)\n- 1w (1 calendar week)\n</code></pre> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta, datetime, timezone\n&gt;&gt;&gt; from grizz.utils.datetime import find_end_datetime\n&gt;&gt;&gt; find_end_datetime(\n...     start=datetime(year=2020, month=5, day=12, hour=4, tzinfo=timezone.utc),\n...     interval=timedelta(hours=1),\n...     periods=42,\n... )\ndatetime.datetime(2020, 5, 13, 22, 0, tzinfo=datetime.timezone.utc)\n</code></pre>"},{"location":"refs/utils/#grizz.utils.datetime.to_datetime","title":"grizz.utils.datetime.to_datetime","text":"<pre><code>to_datetime(dt: datetime | date) -&gt; datetime\n</code></pre> <p>Convert a <code>date</code> object to a <code>datetime</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>datetime | date</code> <p>The <code>date</code> object to convert.</p> required <p>Returns:</p> Type Description <code>datetime</code> <p>The <code>datetime</code> object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, date, timezone\n&gt;&gt;&gt; from grizz.utils.datetime import to_datetime\n&gt;&gt;&gt; to_datetime(datetime(year=2020, month=5, day=12, hour=4, tzinfo=timezone.utc))\ndatetime.datetime(2020, 5, 12, 4, 0, tzinfo=datetime.timezone.utc)\n&gt;&gt;&gt; to_datetime(date(year=2020, month=5, day=12))\ndatetime.datetime(2020, 5, 12, 0, 0, tzinfo=datetime.timezone.utc)\n</code></pre>"},{"location":"refs/utils/#grizz.utils.factory","title":"grizz.utils.factory","text":"<p>Contain a function to instantiate an object from its configuration.</p>"},{"location":"refs/utils/#grizz.utils.factory.setup_object","title":"grizz.utils.factory.setup_object","text":"<pre><code>setup_object(obj_or_config: T | dict) -&gt; T\n</code></pre> <p>Set up an object from its configuration.</p> <p>Parameters:</p> Name Type Description Default <code>obj_or_config</code> <code>T | dict</code> <p>The object or its configuration.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The instantiated object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.factory import setup_object\n&gt;&gt;&gt; obj = setup_object({\"_target_\": \"collections.deque\", \"iterable\": [1, 2, 1, 3]})\n&gt;&gt;&gt; obj\ndeque([1, 2, 1, 3])\n&gt;&gt;&gt; setup_object(obj)  # Do nothing because the object is already instantiated\ndeque([1, 2, 1, 3])\n</code></pre>"},{"location":"refs/utils/#grizz.utils.format","title":"grizz.utils.format","text":"<p>Contain utility functions to format strings.</p>"},{"location":"refs/utils/#grizz.utils.format.human_byte","title":"grizz.utils.format.human_byte","text":"<pre><code>human_byte(size: float, decimal: int = 2) -&gt; str\n</code></pre> <p>Return a human-readable string representation of byte sizes.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>float</code> <p>The number of bytes.</p> required <code>decimal</code> <code>int</code> <p>The number of decimal digits.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>The human-readable string representation of byte sizes.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.format import human_byte\n&gt;&gt;&gt; human_byte(2)\n'2.00 B'\n&gt;&gt;&gt; human_byte(2048)\n'2.00 KB'\n&gt;&gt;&gt; human_byte(2097152)\n'2.00 MB'\n</code></pre>"},{"location":"refs/utils/#grizz.utils.format.str_col_diff","title":"grizz.utils.format.str_col_diff","text":"<pre><code>str_col_diff(orig: int, final: int) -&gt; str\n</code></pre> <p>Return a string that indicates the difference of columns.</p> <p>Parameters:</p> Name Type Description Default <code>orig</code> <code>int</code> <p>The original number of columns.</p> required <code>final</code> <code>int</code> <p>The final number of columns.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The generated string with the difference of columns.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.format import str_col_diff\n&gt;&gt;&gt; str_col_diff(100, 10)\n90/100 (90.0000 %) columns have been removed\n&gt;&gt;&gt; str_col_diff(100, 99)\n1/100 (1.0000 %) column has been removed\n</code></pre>"},{"location":"refs/utils/#grizz.utils.format.str_kwargs","title":"grizz.utils.format.str_kwargs","text":"<pre><code>str_kwargs(mapping: Mapping) -&gt; str\n</code></pre> <p>Return a string of the input mapping.</p> <p>This function is designed to be used in <code>__repr__</code> and <code>__str__</code> methods.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping</code> <p>The mapping.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The generated string.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.format import str_kwargs\n&gt;&gt;&gt; str_kwargs({\"key1\": 1})\n', key1=1'\n&gt;&gt;&gt; str_kwargs({\"key1\": 1, \"key2\": 2})\n', key1=1, key2=2'\n</code></pre>"},{"location":"refs/utils/#grizz.utils.format.str_row_diff","title":"grizz.utils.format.str_row_diff","text":"<pre><code>str_row_diff(orig: int, final: int) -&gt; str\n</code></pre> <p>Return a string that indicates the difference of rows.</p> <p>Parameters:</p> Name Type Description Default <code>orig</code> <code>int</code> <p>The original number of rows.</p> required <code>final</code> <code>int</code> <p>The final number of rows.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The generated string with the difference of rows.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.format import str_row_diff\n&gt;&gt;&gt; str_row_diff(100, 10)\n90/100 (90.0000 %) rows have been removed\n&gt;&gt;&gt; str_row_diff(100, 99)\n1/100 (1.0000 %) row has been removed\n</code></pre>"},{"location":"refs/utils/#grizz.utils.format.str_shape_diff","title":"grizz.utils.format.str_shape_diff","text":"<pre><code>str_shape_diff(\n    orig: tuple[int, int], final: tuple[int, int]\n) -&gt; str\n</code></pre> <p>Return a string that indicates the difference of DataFrame shapes.</p> <p>Parameters:</p> Name Type Description Default <code>orig</code> <code>tuple[int, int]</code> <p>The original shape.</p> required <code>final</code> <code>tuple[int, int]</code> <p>The final number of rows.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The generated string with the difference of DataFrame shapes.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.format import str_shape_diff\n&gt;&gt;&gt; str_shape_diff(orig=(100, 10), final=(80, 8))\nDataFrame shape: (100, 10) -&gt; (80, 8) | 20/100 (20.0000 %) rows have been removed |\n2/10 (20.0000 %) columns have been removed\n</code></pre>"},{"location":"refs/utils/#grizz.utils.imports","title":"grizz.utils.imports","text":"<p>Implement some utility functions to manage optional dependencies.</p>"},{"location":"refs/utils/#grizz.utils.imports.check_clickhouse_connect","title":"grizz.utils.imports.check_clickhouse_connect","text":"<pre><code>check_clickhouse_connect() -&gt; None\n</code></pre> <p>Check if the <code>clickhouse_connect</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>clickhouse_connect</code> package is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.imports import check_clickhouse_connect\n&gt;&gt;&gt; check_clickhouse_connect()\n</code></pre>"},{"location":"refs/utils/#grizz.utils.imports.check_colorlog","title":"grizz.utils.imports.check_colorlog","text":"<pre><code>check_colorlog() -&gt; None\n</code></pre> <p>Check if the <code>colorlog</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>colorlog</code> package is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.imports import check_colorlog\n&gt;&gt;&gt; check_colorlog()\n</code></pre>"},{"location":"refs/utils/#grizz.utils.imports.check_pyarrow","title":"grizz.utils.imports.check_pyarrow","text":"<pre><code>check_pyarrow() -&gt; None\n</code></pre> <p>Check if the <code>pyarrow</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>pyarrow</code> package is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.imports import check_pyarrow\n&gt;&gt;&gt; check_pyarrow()\n</code></pre>"},{"location":"refs/utils/#grizz.utils.imports.check_sklearn","title":"grizz.utils.imports.check_sklearn","text":"<pre><code>check_sklearn() -&gt; None\n</code></pre> <p>Check if the <code>sklearn</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>sklearn</code> package is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.imports import check_sklearn\n&gt;&gt;&gt; check_sklearn()\n</code></pre>"},{"location":"refs/utils/#grizz.utils.imports.check_tqdm","title":"grizz.utils.imports.check_tqdm","text":"<pre><code>check_tqdm() -&gt; None\n</code></pre> <p>Check if the <code>tqdm</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>tqdm</code> package is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.imports import check_tqdm\n&gt;&gt;&gt; check_tqdm()\n</code></pre>"},{"location":"refs/utils/#grizz.utils.imports.clickhouse_connect_available","title":"grizz.utils.imports.clickhouse_connect_available","text":"<pre><code>clickhouse_connect_available(\n    fn: Callable[..., Any]\n) -&gt; Callable[..., Any]\n</code></pre> <p>Implement a decorator to execute a function only if <code>clickhouse_connect</code> package is installed.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[..., Any]</code> <p>The function to execute.</p> required <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>A wrapper around <code>fn</code> if <code>clickhouse_connect</code> package is installed, otherwise <code>None</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.imports import clickhouse_connect_available\n&gt;&gt;&gt; @clickhouse_connect_available\n... def my_function(n: int = 0) -&gt; int:\n...     return 42 + n\n...\n&gt;&gt;&gt; my_function()\n</code></pre>"},{"location":"refs/utils/#grizz.utils.imports.colorlog_available","title":"grizz.utils.imports.colorlog_available","text":"<pre><code>colorlog_available(\n    fn: Callable[..., Any]\n) -&gt; Callable[..., Any]\n</code></pre> <p>Implement a decorator to execute a function only if <code>colorlog</code> package is installed.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[..., Any]</code> <p>The function to execute.</p> required <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>A wrapper around <code>fn</code> if <code>colorlog</code> package is installed, otherwise <code>None</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.imports import colorlog_available\n&gt;&gt;&gt; @colorlog_available\n... def my_function(n: int = 0) -&gt; int:\n...     return 42 + n\n...\n&gt;&gt;&gt; my_function()\n</code></pre>"},{"location":"refs/utils/#grizz.utils.imports.is_clickhouse_connect_available","title":"grizz.utils.imports.is_clickhouse_connect_available  <code>cached</code>","text":"<pre><code>is_clickhouse_connect_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>clickhouse_connect</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>clickhouse_connect</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.imports import is_clickhouse_connect_available\n&gt;&gt;&gt; is_clickhouse_connect_available()\n</code></pre>"},{"location":"refs/utils/#grizz.utils.imports.is_colorlog_available","title":"grizz.utils.imports.is_colorlog_available","text":"<pre><code>is_colorlog_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>colorlog</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>colorlog</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.imports import is_colorlog_available\n&gt;&gt;&gt; is_colorlog_available()\n</code></pre>"},{"location":"refs/utils/#grizz.utils.imports.is_pyarrow_available","title":"grizz.utils.imports.is_pyarrow_available  <code>cached</code>","text":"<pre><code>is_pyarrow_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>pyarrow</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>pyarrow</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.imports import is_pyarrow_available\n&gt;&gt;&gt; is_pyarrow_available()\n</code></pre>"},{"location":"refs/utils/#grizz.utils.imports.is_sklearn_available","title":"grizz.utils.imports.is_sklearn_available  <code>cached</code>","text":"<pre><code>is_sklearn_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>sklearn</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>sklearn</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.imports import is_sklearn_available\n&gt;&gt;&gt; is_sklearn_available()\n</code></pre>"},{"location":"refs/utils/#grizz.utils.imports.is_tqdm_available","title":"grizz.utils.imports.is_tqdm_available  <code>cached</code>","text":"<pre><code>is_tqdm_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>tqdm</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>tqdm</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.imports import is_tqdm_available\n&gt;&gt;&gt; is_tqdm_available()\n</code></pre>"},{"location":"refs/utils/#grizz.utils.imports.pyarrow_available","title":"grizz.utils.imports.pyarrow_available","text":"<pre><code>pyarrow_available(\n    fn: Callable[..., Any]\n) -&gt; Callable[..., Any]\n</code></pre> <p>Implement a decorator to execute a function only if <code>pyarrow</code> package is installed.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[..., Any]</code> <p>Specifies the function to execute.</p> required <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>A wrapper around <code>fn</code> if <code>pyarrow</code> package is installed, otherwise <code>None</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.imports import pyarrow_available\n&gt;&gt;&gt; @pyarrow_available\n... def my_function(n: int = 0) -&gt; int:\n...     return 42 + n\n...\n&gt;&gt;&gt; my_function()\n</code></pre>"},{"location":"refs/utils/#grizz.utils.imports.sklearn_available","title":"grizz.utils.imports.sklearn_available","text":"<pre><code>sklearn_available(\n    fn: Callable[..., Any]\n) -&gt; Callable[..., Any]\n</code></pre> <p>Implement a decorator to execute a function only if <code>sklearn</code> package is installed.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[..., Any]</code> <p>Specifies the function to execute.</p> required <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>A wrapper around <code>fn</code> if <code>sklearn</code> package is installed, otherwise <code>None</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.imports import sklearn_available\n&gt;&gt;&gt; @sklearn_available\n... def my_function(n: int = 0) -&gt; int:\n...     return 42 + n\n...\n&gt;&gt;&gt; my_function()\n</code></pre>"},{"location":"refs/utils/#grizz.utils.imports.tqdm_available","title":"grizz.utils.imports.tqdm_available","text":"<pre><code>tqdm_available(\n    fn: Callable[..., Any]\n) -&gt; Callable[..., Any]\n</code></pre> <p>Implement a decorator to execute a function only if <code>tqdm</code> package is installed.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[..., Any]</code> <p>Specifies the function to execute.</p> required <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>A wrapper around <code>fn</code> if <code>tqdm</code> package is installed, otherwise <code>None</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.imports import tqdm_available\n&gt;&gt;&gt; @tqdm_available\n... def my_function(n: int = 0) -&gt; int:\n...     return 42 + n\n...\n&gt;&gt;&gt; my_function()\n</code></pre>"},{"location":"refs/utils/#grizz.utils.interval","title":"grizz.utils.interval","text":"<p>Contain interval utility functions.</p>"},{"location":"refs/utils/#grizz.utils.interval.find_time_unit","title":"grizz.utils.interval.find_time_unit","text":"<pre><code>find_time_unit(interval: str) -&gt; str\n</code></pre> <p>Find the time unit associated to a <code>polars</code> interval.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>str</code> <p>The <code>polars</code> interval to analyze.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The found time unit.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if no valid time unit can be found.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.interval import find_time_unit\n&gt;&gt;&gt; find_time_unit(\"3d12h4m\")\nm\n&gt;&gt;&gt; find_time_unit(\"3y5mo\")\nmo\n</code></pre>"},{"location":"refs/utils/#grizz.utils.interval.interval_to_strftime_format","title":"grizz.utils.interval.interval_to_strftime_format","text":"<pre><code>interval_to_strftime_format(interval: str) -&gt; str\n</code></pre> <p>Return the default strftime format for a given interval.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>str</code> <p>The <code>polars</code> interval to analyze.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The default strftime format.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.interval import interval_to_strftime_format\n&gt;&gt;&gt; interval_to_strftime_format(\"1h\")\n%Y-%m-%d %H:%M\n&gt;&gt;&gt; interval_to_strftime_format(\"3y1mo\")\n%Y-%m\n</code></pre>"},{"location":"refs/utils/#grizz.utils.interval.interval_to_timedelta","title":"grizz.utils.interval.interval_to_timedelta","text":"<pre><code>interval_to_timedelta(interval: str) -&gt; timedelta\n</code></pre> <p>Convert a interval to a timedelta object.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>str</code> <p>The input interval.</p> required <p>Returns:</p> Type Description <code>timedelta</code> <p>The timedelta object generated from the interval.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.interval import interval_to_timedelta\n&gt;&gt;&gt; interval_to_timedelta(\"5d1h42m\")\ndatetime.timedelta(days=5, seconds=6120)\n</code></pre>"},{"location":"refs/utils/#grizz.utils.interval.time_unit_to_strftime_format","title":"grizz.utils.interval.time_unit_to_strftime_format","text":"<pre><code>time_unit_to_strftime_format(time_unit: str) -&gt; str\n</code></pre> <p>Return the default strftime format for a given time unit.</p> <p>Parameters:</p> Name Type Description Default <code>time_unit</code> <code>str</code> <p>The time unit.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The default strftime format.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.interval import time_unit_to_strftime_format\n&gt;&gt;&gt; time_unit_to_strftime_format(\"h\")\n%Y-%m-%d %H:%M\n&gt;&gt;&gt; time_unit_to_strftime_format(\"mo\")\n%Y-%m\n</code></pre>"},{"location":"refs/utils/#grizz.utils.noop","title":"grizz.utils.noop","text":"<p>Contain no-op functions.</p>"},{"location":"refs/utils/#grizz.utils.noop.tqdm","title":"grizz.utils.noop.tqdm","text":"<pre><code>tqdm(\n    iterable: Iterable, *args: Any, **kwargs: Any\n) -&gt; Iterable\n</code></pre> <p>Implement a no-op tqdm progressbar that is used when tqdm is not installed.</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>Iterable</code> <p>Iterable to decorate with a progressbar.</p> required <code>*args</code> <code>Any</code> <p>Positional arbitrary arguments.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arbitrary arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Iterable</code> <p>The input iterable.</p>"},{"location":"refs/utils/#grizz.utils.path","title":"grizz.utils.path","text":"<p>Contain utility functions to manage paths.</p>"},{"location":"refs/utils/#grizz.utils.path.find_files","title":"grizz.utils.path.find_files","text":"<pre><code>find_files(\n    path: Path | str,\n    filter_fn: Callable[[Path], bool],\n    recursive: bool = True,\n) -&gt; list[Path]\n</code></pre> <p>Find the path of all the tar files in a given path.</p> <p>This function does not check if a path is a symbolic link so be careful if you are using a path with symbolic links.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The path where to look for the parquet files.</p> required <code>filter_fn</code> <code>Callable[[Path], bool]</code> <p>The path filtering function. The function should return <code>True</code> for the path to find, and <code>False</code> otherwise.</p> required <code>recursive</code> <code>bool</code> <p>Indicate if it should also check the sub-folders.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[Path]</code> <p>The tuple of path of parquet files.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from grizz.utils.path import find_files\n&gt;&gt;&gt; find_files(Path(\"something\"), filter_fn=lambda path: path.name.endswith(\".txt\"))\n[...]\n</code></pre>"},{"location":"refs/utils/#grizz.utils.path.find_parquet_files","title":"grizz.utils.path.find_parquet_files","text":"<pre><code>find_parquet_files(\n    path: Path | str, recursive: bool = True\n) -&gt; list[Path]\n</code></pre> <p>Find the path of all the parquet files in a given path.</p> <p>This function does not check if a path is a symbolic link so be careful if you are using a path with symbolic links.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The path where to look for the parquet files.</p> required <code>recursive</code> <code>bool</code> <p>Specifies if it should also check the sub-folders.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[Path]</code> <p>The list of parquet files.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from grizz.utils.path import find_parquet_files\n&gt;&gt;&gt; find_parquet_files(Path(\"something\"))\n[...]\n</code></pre>"},{"location":"refs/utils/#grizz.utils.path.human_file_size","title":"grizz.utils.path.human_file_size","text":"<pre><code>human_file_size(path: Path | str, decimal: int = 2) -&gt; str\n</code></pre> <p>Get a human-readable representation of a file size.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The path to the file.</p> required <code>decimal</code> <code>int</code> <p>The number of decimal digits.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>The file size in a human-readable format.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.path import human_file_size\n&gt;&gt;&gt; human_file_size(\"README.md\")\n'...B'\n</code></pre>"},{"location":"refs/utils/#grizz.utils.path.sanitize_path","title":"grizz.utils.path.sanitize_path","text":"<pre><code>sanitize_path(path: Path | str) -&gt; Path\n</code></pre> <p>Sanitize a given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The path to sanitize.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>The sanitized path.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from grizz.utils.path import sanitize_path\n&gt;&gt;&gt; sanitize_path(\"something\")\nPosixPath('.../something')\n&gt;&gt;&gt; sanitize_path(\"\")\nPosixPath('...')\n&gt;&gt;&gt; sanitize_path(Path(\"something\"))\nPosixPath('.../something')\n&gt;&gt;&gt; sanitize_path(Path(\"something/./../\"))\nPosixPath('...')\n</code></pre>"}]}