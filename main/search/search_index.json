{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p><code>grizz</code> is a light library to ingest and transform data in polars DataFrame. <code>grizz</code> uses an object-oriented strategy, where ingestors and transformers are building blocks that can be combined together. <code>grizz</code> can be extend to add custom DataFrame ingestors and transformers. For example, the following example shows how to change the casting of some columns.</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Cast\n&gt;&gt;&gt; transformer = Cast(columns=[\"col1\", \"col3\"], dtype=pl.Int32)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i32  \u2506 str  \u2506 i32  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"#api-stability","title":"API stability","text":"<p> While <code>grizz</code> is in development stage, no API is guaranteed to be stable from one release to the next. In fact, it is very likely that the API will change multiple times before a stable 1.0.0 release. In practice, this means that upgrading <code>grizz</code> to a new version will possibly break any code that was using the old version of <code>grizz</code>.</p>"},{"location":"#license","title":"License","text":"<p><code>grizz</code> is licensed under BSD 3-Clause \"New\" or \"Revised\" license available in LICENSE file.</p>"},{"location":"get_started/","title":"Get Started","text":"<p>It is highly recommended to install in a virtual environment to keep your system in order.</p>"},{"location":"get_started/#installing-with-pip-recommended","title":"Installing with <code>pip</code> (recommended)","text":"<p>The following command installs the latest version of the library:</p> <pre><code>pip install grizz\n</code></pre> <p>To make the package as slim as possible, only the packages required to use <code>grizz</code> are installed. It is possible to install all the optional dependencies by running the following command:</p> <pre><code>pip install 'grizz[all]'\n</code></pre>"},{"location":"get_started/#installing-from-source","title":"Installing from source","text":"<p>To install <code>grizz</code> from source, you can follow the steps below. First, you will need to install <code>poetry</code>. <code>poetry</code> is used to manage and install the dependencies. If <code>poetry</code> is already installed on your machine, you can skip this step. There are several ways to install <code>poetry</code> so you can use the one that you prefer. You can check the <code>poetry</code> installation by running the following command:</p> <pre><code>poetry --version\n</code></pre> <p>Then, you can clone the git repository:</p> <pre><code>git clone git@github.com:durandtibo/grizz.git\n</code></pre> <p>It is recommended to create a Python 3.8+ virtual environment. This step is optional so you can skip it. To create a virtual environment, you can use the following command:</p> <pre><code>make conda\n</code></pre> <p>It automatically creates a conda virtual environment. When the virtual environment is created, you can activate it with the following command:</p> <pre><code>conda activate grizz\n</code></pre> <p>This example uses <code>conda</code> to create a virtual environment, but you can use other tools or configurations. Then, you should install the required package to use <code>grizz</code> with the following command:</p> <pre><code>make install\n</code></pre> <p>This command will install all the required packages. You can also use this command to update the required packages. This command will check if there is a more recent package available and will install it. Finally, you can test the installation with the following command:</p> <pre><code>make unit-test-cov\n</code></pre>"},{"location":"refs/exporter/","title":"exporter","text":""},{"location":"refs/exporter/#grizz.exporter","title":"grizz.exporter","text":"<p>Contain DataFrame exporters.</p>"},{"location":"refs/exporter/#grizz.exporter.BaseExporter","title":"grizz.exporter.BaseExporter","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to implement a DataFrame exporter.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.exporter import ParquetExporter\n&gt;&gt;&gt; exporter = ParquetExporter(path=\"/path/to/frame.parquet\")\n&gt;&gt;&gt; exporter\nParquetExporter(path=/path/to/frame.parquet)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; exporter.export(frame)  # doctest: +SKIP\n</code></pre>"},{"location":"refs/exporter/#grizz.exporter.BaseExporter.equal","title":"grizz.exporter.BaseExporter.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any, equal_nan: bool = False) -&gt; bool\n</code></pre> <p>Indicate if two exporter objects are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The other object to compare.</p> required <code>equal_nan</code> <code>bool</code> <p>Whether to compare NaN's as equal. If <code>True</code>, NaN's in both objects will be considered equal.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two exporters are equal, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from grizz.exporter import CsvExporter\n&gt;&gt;&gt; obj1 = CsvExporter(path=\"/path/to/frame.csv\")\n&gt;&gt;&gt; obj2 = CsvExporter(path=\"/path/to/frame.csv\")\n&gt;&gt;&gt; obj3 = CsvExporter(path=\"/path/to/frame2.csv\")\n&gt;&gt;&gt; obj1.equal(obj2)\nTrue\n&gt;&gt;&gt; obj1.equal(obj3)\nFalse\n</code></pre>"},{"location":"refs/exporter/#grizz.exporter.BaseExporter.export","title":"grizz.exporter.BaseExporter.export  <code>abstractmethod</code>","text":"<pre><code>export(frame: DataFrame) -&gt; None\n</code></pre> <p>Export a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to export.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.exporter import ParquetExporter\n&gt;&gt;&gt; exporter = ParquetExporter(path=\"/path/to/frame.parquet\")\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; exporter.export(frame)  # doctest: +SKIP\n</code></pre>"},{"location":"refs/exporter/#grizz.exporter.CsvExporter","title":"grizz.exporter.CsvExporter","text":"<p>               Bases: <code>BaseExporter</code></p> <p>Implement a CSV DataFrame exporter.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The path to the csv file to ingest.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for <code>polars.DataFrame.write_csv</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.exporter import CsvExporter\n&gt;&gt;&gt; exporter = CsvExporter(path=\"/path/to/frame.csv\")\n&gt;&gt;&gt; exporter\nCsvExporter(path=/path/to/frame.csv)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; exporter.export(frame)  # doctest: +SKIP\n</code></pre>"},{"location":"refs/exporter/#grizz.exporter.InMemoryExporter","title":"grizz.exporter.InMemoryExporter","text":"<p>               Bases: <code>BaseExporter</code>, <code>BaseIngestor</code></p> <p>Implement an in-memory DataFrame exporter and ingestor.</p> Notes <p>This exporter is both exporter and ingestor as the object     stores the DataFrame.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.exporter import InMemoryExporter\n&gt;&gt;&gt; exporter = InMemoryExporter()\n&gt;&gt;&gt; exporter\nInMemoryExporter(frame=None)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; exporter.export(frame)\n&gt;&gt;&gt; df = exporter.ingest()\n&gt;&gt;&gt; df\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/exporter/#grizz.exporter.ParquetExporter","title":"grizz.exporter.ParquetExporter","text":"<p>               Bases: <code>BaseExporter</code></p> <p>Implement a parquet DataFrame exporter.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The path to the parquet file to ingest.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for <code>polars.DataFrame.write_parquet</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.exporter import ParquetExporter\n&gt;&gt;&gt; exporter = ParquetExporter(path=\"/path/to/frame.parquet\")\n&gt;&gt;&gt; exporter\nParquetExporter(path=/path/to/frame.parquet)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; exporter.export(frame)  # doctest: +SKIP\n</code></pre>"},{"location":"refs/exporter/#grizz.exporter.TransformExporter","title":"grizz.exporter.TransformExporter","text":"<p>               Bases: <code>BaseExporter</code></p> <p>Implement an exporter that transforms the DataFrame before to export it.</p> <p>Parameters:</p> Name Type Description Default <code>transformer</code> <code>BaseTransformer | dict</code> <p>The <code>polars.DataFrame</code> transformer or its configuration.</p> required <code>exporter</code> <code>BaseExporter | dict</code> <p>The DataFrame exporter or its configuration.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.exporter import TransformExporter, ParquetExporter\n&gt;&gt;&gt; from grizz.transformer import Cast\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; exporter = TransformExporter(\n...     transformer=Cast(columns=[\"col1\", \"col3\"], dtype=pl.Float32),\n...     exporter=ParquetExporter(path=\"/path/to/frame.parquet\"),\n... )\n&gt;&gt;&gt; exporter\nTransformExporter(\n  (transformer): CastTransformer(columns=('col1', 'col3'), exclude_columns=(), missing_policy='raise', dtype=Float32)\n  (exporter): ParquetExporter(path=/path/to/frame.parquet)\n)\n&gt;&gt;&gt; exporter.export(frame)  # doctest: +SKIP\n</code></pre>"},{"location":"refs/exporter/#grizz.exporter.is_exporter_config","title":"grizz.exporter.is_exporter_config","text":"<pre><code>is_exporter_config(config: dict) -&gt; bool\n</code></pre> <p>Indicate if the input configuration is a configuration for a <code>BaseExporter</code>.</p> <p>This function only checks if the value of the key  <code>_target_</code> is valid. It does not check the other values. If <code>_target_</code> indicates a function, the returned type hint is used to check the class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input configuration is a configuration for a <code>BaseExporter</code> object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.exporter import is_exporter_config\n&gt;&gt;&gt; is_exporter_config(\n...     {\"_target_\": \"grizz.exporter.ParquetExporter\", \"path\": \"/path/to/data.parquet\"}\n... )\nTrue\n</code></pre>"},{"location":"refs/exporter/#grizz.exporter.setup_exporter","title":"grizz.exporter.setup_exporter","text":"<pre><code>setup_exporter(\n    exporter: BaseExporter | dict,\n) -&gt; BaseExporter\n</code></pre> <p>Set up an exporter.</p> <p>The exporter is instantiated from its configuration by using the <code>BaseExporter</code> factory function.</p> <p>Parameters:</p> Name Type Description Default <code>exporter</code> <code>BaseExporter | dict</code> <p>A exporter or its configuration.</p> required <p>Returns:</p> Type Description <code>BaseExporter</code> <p>An instantiated exporter.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.exporter import setup_exporter\n&gt;&gt;&gt; exporter = setup_exporter(\n...     {\"_target_\": \"grizz.exporter.ParquetExporter\", \"path\": \"/path/to/data.parquet\"}\n... )\n&gt;&gt;&gt; exporter\nParquetExporter(path=/path/to/data.parquet)\n</code></pre>"},{"location":"refs/ingestor/","title":"ingestor","text":""},{"location":"refs/ingestor/#grizz.ingestor","title":"grizz.ingestor","text":"<p>Contain DataFrame ingestors.</p>"},{"location":"refs/ingestor/#grizz.ingestor.BaseIngestor","title":"grizz.ingestor.BaseIngestor","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to implement a DataFrame ingestor.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.ingestor import ParquetFileIngestor\n&gt;&gt;&gt; ingestor = ParquetFileIngestor(path=\"/path/to/frame.parquet\")\n&gt;&gt;&gt; ingestor\nParquetFileIngestor(source=/path/to/frame.parquet)\n&gt;&gt;&gt; frame = ingestor.ingest()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/ingestor/#grizz.ingestor.BaseIngestor.equal","title":"grizz.ingestor.BaseIngestor.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any, equal_nan: bool = False) -&gt; bool\n</code></pre> <p>Indicate if two ingestor objects are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The other object to compare.</p> required <code>equal_nan</code> <code>bool</code> <p>Whether to compare NaN's as equal. If <code>True</code>, NaN's in both objects will be considered equal.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two ingestors are equal, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.ingestor import CsvIngestor\n&gt;&gt;&gt; obj1 = CsvIngestor(path=\"/path/to/frame.csv\")\n&gt;&gt;&gt; obj2 = CsvIngestor(path=\"/path/to/frame.csv\")\n&gt;&gt;&gt; obj3 = CsvIngestor(path=\"/path/to/frame2.csv\")\n&gt;&gt;&gt; obj1.equal(obj2)\nTrue\n&gt;&gt;&gt; obj1.equal(obj3)\nFalse\n</code></pre>"},{"location":"refs/ingestor/#grizz.ingestor.BaseIngestor.ingest","title":"grizz.ingestor.BaseIngestor.ingest  <code>abstractmethod</code>","text":"<pre><code>ingest() -&gt; DataFrame\n</code></pre> <p>Ingest a DataFrame.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The ingested DataFrame.</p> <p>Raises:</p> Type Description <code>DataFrameNotFoundError</code> <p>if the DataFrame cannot be ingested.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.ingestor import ParquetFileIngestor\n&gt;&gt;&gt; ingestor = ParquetFileIngestor(path=\"/path/to/frame.parquet\")\n&gt;&gt;&gt; frame = ingestor.ingest()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/ingestor/#grizz.ingestor.CacheIngestor","title":"grizz.ingestor.CacheIngestor","text":"<p>               Bases: <code>BaseIngestor</code></p> <p>Implement an ingestor that attempts the fast ingestor first, falling back to the slow ingestor if needed.</p> <p>Internally, this ingestor attempts to load the DataFrame using the fast ingestor. If a <code>DataFrameNotFoundError</code> is raised, it falls back to the slow ingestor, then exports the DataFrame for ingestion by the fast ingestor during the next cycle.</p> <p>Parameters:</p> Name Type Description Default <code>fast_ingestor</code> <code>BaseIngestor | dict</code> <p>The fast DataFrame ingestor or its configuration.</p> required <code>slow_ingestor</code> <code>BaseIngestor | dict</code> <p>The slow DataFrame ingestor or its configuration.</p> required <code>exporter</code> <code>BaseExporter | dict</code> <p>The DataFrame exporter or its configuration. The DataFrame exporter is responsible for storing the output of the slower DataFrame ingestor, allowing it to be ingested by the faster DataFrame ingestor during the next ingestion cycle.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.ingestor import CacheIngestor, Ingestor\n&gt;&gt;&gt; from grizz.exporter import InMemoryExporter\n&gt;&gt;&gt; slow_ingestor = Ingestor(\n...     pl.DataFrame(\n...         {\n...             \"col1\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...             \"col2\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...             \"col3\": [1.2, 2.2, 3.2, 4.2, 5.2],\n...         }\n...     )\n... )\n&gt;&gt;&gt; exporter_ingestor = InMemoryExporter()\n&gt;&gt;&gt; ingestor = CacheIngestor(\n...     fast_ingestor=exporter_ingestor,\n...     slow_ingestor=slow_ingestor,\n...     exporter=exporter_ingestor,\n... )\n&gt;&gt;&gt; ingestor\nCacheIngestor(\n  (fast_ingestor): InMemoryExporter(frame=None)\n  (slow_ingestor): Ingestor(shape=(5, 3))\n  (exporter): InMemoryExporter(frame=None)\n)\n&gt;&gt;&gt; frame = ingestor.ingest()\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 str  \u2506 str  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 a    \u2506 1.2  \u2502\n\u2502 2    \u2506 b    \u2506 2.2  \u2502\n\u2502 3    \u2506 c    \u2506 3.2  \u2502\n\u2502 4    \u2506 d    \u2506 4.2  \u2502\n\u2502 5    \u2506 e    \u2506 5.2  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/ingestor/#grizz.ingestor.ClickHouseArrowIngestor","title":"grizz.ingestor.ClickHouseArrowIngestor","text":"<p>               Bases: <code>BaseIngestor</code></p> <p>Implement a ClickHouse DataFrame ingestor that uses Arrow.</p> <p>This ingestor requires <code>clickhouse_connect</code> and <code>pyarrow</code>.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query to get the data.</p> required <code>client</code> <code>Client | dict</code> <p>The ClickHouse client or its configuration. Please check the documentation of <code>clickhouse_connect.get_client</code> to get more information.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.ingestor import ClickHouseArrowIngestor\n&gt;&gt;&gt; import clickhouse_connect\n&gt;&gt;&gt; client = clickhouse_connect.get_client()  # doctest: +SKIP\n&gt;&gt;&gt; ingestor = ClickHouseArrowIngestor(query=\"\", client=client)  # doctest: +SKIP\n&gt;&gt;&gt; frame = ingestor.ingest()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/ingestor/#grizz.ingestor.CsvIngestor","title":"grizz.ingestor.CsvIngestor","text":"<p>               Bases: <code>BaseIngestor</code></p> <p>Implement a CSV DataFrame ingestor.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The path to the CSV file to ingest.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for <code>polars.read_csv</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.ingestor import CsvIngestor\n&gt;&gt;&gt; ingestor = CsvIngestor(path=\"/path/to/frame.csv\")\n&gt;&gt;&gt; ingestor\nCsvIngestor(path=/path/to/frame.csv)\n&gt;&gt;&gt; frame = ingestor.ingest()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/ingestor/#grizz.ingestor.Ingestor","title":"grizz.ingestor.Ingestor","text":"<p>               Bases: <code>BaseIngestor</code></p> <p>Implement a simple DataFrame ingestor.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to ingest.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.ingestor import Ingestor\n&gt;&gt;&gt; ingestor = Ingestor(\n...     frame=pl.DataFrame(\n...         {\n...             \"col1\": [1, 2, 3, 4, 5],\n...             \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...             \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...             \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...         }\n...     )\n... )\n&gt;&gt;&gt; ingestor\nIngestor(shape=(5, 4))\n&gt;&gt;&gt; frame = ingestor.ingest()\n</code></pre>"},{"location":"refs/ingestor/#grizz.ingestor.JoinIngestor","title":"grizz.ingestor.JoinIngestor","text":"<p>               Bases: <code>BaseIngestor</code></p> <p>Implement an ingestor that joins the output of multiple ingestors.</p> <p>Parameters:</p> Name Type Description Default <code>ingestors</code> <code>Sequence[BaseIngestor | dict]</code> <p>The list of ingestors.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for <code>polars.DataFrame.join</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.ingestor import JoinIngestor, Ingestor\n&gt;&gt;&gt; ingestor1 = Ingestor(\n...     frame=pl.DataFrame(\n...         {\n...             \"col\": [1, 2, 3, 4, 5],\n...             \"col1\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...             \"col2\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...         }\n...     )\n... )\n&gt;&gt;&gt; ingestor2 = Ingestor(\n...     frame=pl.DataFrame(\n...         {\n...             \"col\": [1, 2, 3, 5],\n...             \"col3\": [-1, -2, -3, -5],\n...         }\n...     )\n... )\n&gt;&gt;&gt; ingestor3 = Ingestor(\n...     frame=pl.DataFrame(\n...         {\n...             \"col\": [1, 2, 3, 4, 5],\n...             \"col4\": [1.1, 2.2, 3.3, 4.4, 5.5],\n...             \"col5\": [\"1.1\", \"2.2\", \"3.3\", \"4.4\", \"5.5\"],\n...         }\n...     )\n... )\n&gt;&gt;&gt; ingestor = JoinIngestor([ingestor1, ingestor2, ingestor3], on=\"col\", how=\"inner\")\n&gt;&gt;&gt; ingestor\nJoinIngestor(\n  (ingestors):\n    (0): Ingestor(shape=(5, 3))\n    (1): Ingestor(shape=(4, 2))\n    (2): Ingestor(shape=(5, 3))\n  (kwargs): on='col', how='inner'\n)\n&gt;&gt;&gt; frame = ingestor.ingest()\n&gt;&gt;&gt; frame\nshape: (4, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col \u2506 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col5 \u2502\n\u2502 --- \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64 \u2506 str  \u2506 str  \u2506 i64  \u2506 f64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 1    \u2506 a    \u2506 -1   \u2506 1.1  \u2506 1.1  \u2502\n\u2502 2   \u2506 2    \u2506 b    \u2506 -2   \u2506 2.2  \u2506 2.2  \u2502\n\u2502 3   \u2506 3    \u2506 c    \u2506 -3   \u2506 3.3  \u2506 3.3  \u2502\n\u2502 5   \u2506 5    \u2506 e    \u2506 -5   \u2506 5.5  \u2506 5.5  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/ingestor/#grizz.ingestor.ParquetFileIngestor","title":"grizz.ingestor.ParquetFileIngestor","text":"<p>               Bases: <code>ParquetIngestor</code></p> <p>Implement a parquet file ingestor.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The path to the parquet file to ingest.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for <code>polars.read_parquet</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.ingestor import ParquetFileIngestor\n&gt;&gt;&gt; ingestor = ParquetFileIngestor(path=\"/path/to/frame.parquet\")\n&gt;&gt;&gt; ingestor\nParquetFileIngestor(source=/path/to/frame.parquet)\n&gt;&gt;&gt; frame = ingestor.ingest()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/ingestor/#grizz.ingestor.ParquetIngestor","title":"grizz.ingestor.ParquetIngestor","text":"<p>               Bases: <code>BaseIngestor</code></p> <p>Implement a parquet ingestor.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>FileSource</code> <p>The source to the parquet data to ingest.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments for <code>polars.read_parquet</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.ingestor import ParquetIngestor\n&gt;&gt;&gt; ingestor = ParquetIngestor(source=\"/path/to/frame.parquet\")\n&gt;&gt;&gt; ingestor\nParquetIngestor(source=/path/to/frame.parquet)\n&gt;&gt;&gt; frame = ingestor.ingest()  # doctest: +SKIP\n</code></pre>"},{"location":"refs/ingestor/#grizz.ingestor.TransformIngestor","title":"grizz.ingestor.TransformIngestor","text":"<p>               Bases: <code>BaseIngestor</code></p> <p>Implement an ingestor that also transforms the DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>ingestor</code> <code>BaseIngestor | dict</code> <p>The base ingestor.</p> required <code>transformer</code> <code>BaseTransformer | dict</code> <p>The <code>polars.DataFrame</code> transformer or its configuration.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.ingestor import TransformIngestor, Ingestor\n&gt;&gt;&gt; from grizz.transformer import Cast\n&gt;&gt;&gt; ingestor = TransformIngestor(\n...     ingestor=Ingestor(\n...         pl.DataFrame(\n...             {\n...                 \"col1\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...                 \"col2\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...                 \"col3\": [1.2, 2.2, 3.2, 4.2, 5.2],\n...             }\n...         )\n...     ),\n...     transformer=Cast(columns=[\"col1\", \"col3\"], dtype=pl.Float32),\n... )\n&gt;&gt;&gt; ingestor\nTransformIngestor(\n  (ingestor): Ingestor(shape=(5, 3))\n  (transformer): CastTransformer(columns=('col1', 'col3'), exclude_columns=(), missing_policy='raise', dtype=Float32)\n)\n&gt;&gt;&gt; frame = ingestor.ingest()\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 f32  \u2506 str  \u2506 f32  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0  \u2506 a    \u2506 1.2  \u2502\n\u2502 2.0  \u2506 b    \u2506 2.2  \u2502\n\u2502 3.0  \u2506 c    \u2506 3.2  \u2502\n\u2502 4.0  \u2506 d    \u2506 4.2  \u2502\n\u2502 5.0  \u2506 e    \u2506 5.2  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/ingestor/#grizz.ingestor.is_ingestor_config","title":"grizz.ingestor.is_ingestor_config","text":"<pre><code>is_ingestor_config(config: dict) -&gt; bool\n</code></pre> <p>Indicate if the input configuration is a configuration for a <code>BaseIngestor</code>.</p> <p>This function only checks if the value of the key  <code>_target_</code> is valid. It does not check the other values. If <code>_target_</code> indicates a function, the returned type hint is used to check the class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input configuration is a configuration for a <code>BaseIngestor</code> object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.ingestor import is_ingestor_config\n&gt;&gt;&gt; is_ingestor_config(\n...     {\"_target_\": \"grizz.ingestor.CsvIngestor\", \"path\": \"/path/to/data.csv\"}\n... )\nTrue\n</code></pre>"},{"location":"refs/ingestor/#grizz.ingestor.setup_ingestor","title":"grizz.ingestor.setup_ingestor","text":"<pre><code>setup_ingestor(\n    ingestor: BaseIngestor | dict,\n) -&gt; BaseIngestor\n</code></pre> <p>Set up an ingestor.</p> <p>The ingestor is instantiated from its configuration by using the <code>BaseIngestor</code> factory function.</p> <p>Parameters:</p> Name Type Description Default <code>ingestor</code> <code>BaseIngestor | dict</code> <p>An ingestor or its configuration.</p> required <p>Returns:</p> Type Description <code>BaseIngestor</code> <p>An instantiated ingestor.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.ingestor import setup_ingestor\n&gt;&gt;&gt; ingestor = setup_ingestor(\n...     {\"_target_\": \"grizz.ingestor.CsvIngestor\", \"path\": \"/path/to/data.csv\"}\n... )\n&gt;&gt;&gt; ingestor\nCsvIngestor(path=/path/to/data.csv)\n</code></pre>"},{"location":"refs/transformer/","title":"transformer","text":""},{"location":"refs/transformer/#grizz.transformer","title":"grizz.transformer","text":"<p>Contain <code>polars.DataFrame</code> transformers.</p>"},{"location":"refs/transformer/#grizz.transformer.AbsDiffHorizontal","title":"grizz.transformer.AbsDiffHorizontal","text":"<p>               Bases: <code>BaseIn2Out1Transformer</code></p> <p>Implement a transformer to compute the absolute difference between two columns.</p> <p>Internally, this tranformer computes: <code>out = abs(in1 - in2)</code></p> <p>Parameters:</p> Name Type Description Default <code>in1_col</code> <code>str</code> <p>The first input column name.</p> required <code>in2_col</code> <code>str</code> <p>The second input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import AbsDiffHorizontal\n&gt;&gt;&gt; transformer = AbsDiffHorizontal(in1_col=\"col1\", in2_col=\"col2\", out_col=\"diff\")\n&gt;&gt;&gt; transformer\nAbsDiffHorizontalTransformer(in1_col='col1', in2_col='col2', out_col='diff', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [5, 4, 3, 2, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 diff \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2506 4    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2506 2    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506 0    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2506 2    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2506 4    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.AbsDiffHorizontalTransformer","title":"grizz.transformer.AbsDiffHorizontalTransformer","text":"<p>               Bases: <code>BaseIn2Out1Transformer</code></p> <p>Implement a transformer to compute the absolute difference between two columns.</p> <p>Internally, this tranformer computes: <code>out = abs(in1 - in2)</code></p> <p>Parameters:</p> Name Type Description Default <code>in1_col</code> <code>str</code> <p>The first input column name.</p> required <code>in2_col</code> <code>str</code> <p>The second input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import AbsDiffHorizontal\n&gt;&gt;&gt; transformer = AbsDiffHorizontal(in1_col=\"col1\", in2_col=\"col2\", out_col=\"diff\")\n&gt;&gt;&gt; transformer\nAbsDiffHorizontalTransformer(in1_col='col1', in2_col='col2', out_col='diff', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [5, 4, 3, 2, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 diff \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2506 4    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2506 2    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506 0    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2506 2    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2506 4    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.BaseArgTransformer","title":"grizz.transformer.BaseArgTransformer","text":"<p>               Bases: <code>BaseTransformer</code></p> <p>Define a base class to implement transformers with custom arguments.</p>"},{"location":"refs/transformer/#grizz.transformer.BaseArgTransformer.get_args","title":"grizz.transformer.BaseArgTransformer.get_args  <code>abstractmethod</code>","text":"<pre><code>get_args() -&gt; dict\n</code></pre> <p>Get the arguments of the transformer.</p> <p>Returns:</p> Type Description <code>dict</code> <p>The arguments of the transformer.</p>"},{"location":"refs/transformer/#grizz.transformer.BaseIn1Out1Transformer","title":"grizz.transformer.BaseIn1Out1Transformer","text":"<p>               Bases: <code>BaseArgTransformer</code></p> <p>Define a base class to implement <code>polars.DataFrame</code> transformers that takes one input column and generate one output column.</p> <p>Parameters:</p> Name Type Description Default <code>in_col</code> <code>str</code> <p>The input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code>"},{"location":"refs/transformer/#grizz.transformer.BaseIn2Out1Transformer","title":"grizz.transformer.BaseIn2Out1Transformer","text":"<p>               Bases: <code>BaseArgTransformer</code></p> <p>Define a base class to implement <code>polars.DataFrame</code> transformers that takes two input columns and generate one output column.</p> <p>Parameters:</p> Name Type Description Default <code>in1_col</code> <code>str</code> <p>The first input column name.</p> required <code>in2_col</code> <code>str</code> <p>The second input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import AbsDiffHorizontal\n&gt;&gt;&gt; transformer = AbsDiffHorizontal(in1_col=\"col1\", in2_col=\"col2\", out_col=\"diff\")\n&gt;&gt;&gt; transformer\nAbsDiffHorizontalTransformer(in1_col='col1', in2_col='col2', out_col='diff', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [5, 4, 3, 2, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 diff \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2506 4    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2506 2    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506 0    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2506 2    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2506 4    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.BaseInNOut1Transformer","title":"grizz.transformer.BaseInNOut1Transformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Define a base class to implement <code>polars.DataFrame</code> transformers that generate a single output column by using multiple input columns.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to prepare. If <code>None</code>, it processes all the columns.</p> required <code>out_col</code> <code>str</code> <p>The output column.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ConcatColumns\n&gt;&gt;&gt; transformer = ConcatColumns(columns=[\"col1\", \"col2\", \"col3\"], out_col=\"col\")\n&gt;&gt;&gt; transformer\nConcatColumnsTransformer(columns=('col1', 'col2', 'col3'), out_col='col', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [11, 12, 13, 14, 15],\n...         \"col2\": [21, 22, 23, 24, 25],\n...         \"col3\": [31, 32, 33, 34, 35],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11   \u2506 21   \u2506 31   \u2506 a    \u2502\n\u2502 12   \u2506 22   \u2506 32   \u2506 b    \u2502\n\u2502 13   \u2506 23   \u2506 33   \u2506 c    \u2502\n\u2502 14   \u2506 24   \u2506 34   \u2506 d    \u2502\n\u2502 15   \u2506 25   \u2506 35   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.fit_transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col          \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---          \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2506 list[i64]    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11   \u2506 21   \u2506 31   \u2506 a    \u2506 [11, 21, 31] \u2502\n\u2502 12   \u2506 22   \u2506 32   \u2506 b    \u2506 [12, 22, 32] \u2502\n\u2502 13   \u2506 23   \u2506 33   \u2506 c    \u2506 [13, 23, 33] \u2502\n\u2502 14   \u2506 24   \u2506 34   \u2506 d    \u2506 [14, 24, 34] \u2502\n\u2502 15   \u2506 25   \u2506 35   \u2506 e    \u2506 [15, 25, 35] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.BaseInNOutNTransformer","title":"grizz.transformer.BaseInNOutNTransformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Define a base class to implement <code>polars.DataFrame</code> transformers that has N input columns and N output columns.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to prepare. If <code>None</code>, it processes all the columns.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the output columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the output columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ConcatColumns\n&gt;&gt;&gt; transformer = ConcatColumns(columns=[\"col1\", \"col2\", \"col3\"], out_col=\"col\")\n&gt;&gt;&gt; transformer\nConcatColumnsTransformer(columns=('col1', 'col2', 'col3'), out_col='col', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [11, 12, 13, 14, 15],\n...         \"col2\": [21, 22, 23, 24, 25],\n...         \"col3\": [31, 32, 33, 34, 35],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11   \u2506 21   \u2506 31   \u2506 a    \u2502\n\u2502 12   \u2506 22   \u2506 32   \u2506 b    \u2502\n\u2502 13   \u2506 23   \u2506 33   \u2506 c    \u2502\n\u2502 14   \u2506 24   \u2506 34   \u2506 d    \u2502\n\u2502 15   \u2506 25   \u2506 35   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.fit_transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col          \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---          \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2506 list[i64]    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11   \u2506 21   \u2506 31   \u2506 a    \u2506 [11, 21, 31] \u2502\n\u2502 12   \u2506 22   \u2506 32   \u2506 b    \u2506 [12, 22, 32] \u2502\n\u2502 13   \u2506 23   \u2506 33   \u2506 c    \u2506 [13, 23, 33] \u2502\n\u2502 14   \u2506 24   \u2506 34   \u2506 d    \u2506 [14, 24, 34] \u2502\n\u2502 15   \u2506 25   \u2506 35   \u2506 e    \u2506 [15, 25, 35] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.BaseInNTransformer","title":"grizz.transformer.BaseInNTransformer","text":"<p>               Bases: <code>BaseArgTransformer</code></p> <p>Define a base class to implement <code>polars.DataFrame</code> transformers that transform DataFrames by using multiple input columns.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to prepare. If <code>None</code>, it processes all the columns.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import StripChars\n&gt;&gt;&gt; transformer = StripChars(columns=[\"col2\", \"col3\"])\n&gt;&gt;&gt; transformer\nStripCharsTransformer(columns=('col2', 'col3'), exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...         \"col4\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3  \u2506 col4  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---   \u2506 ---   \u2502\n\u2502 i64  \u2506 str  \u2506 str   \u2506 str   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 a     \u2506 a     \u2502\n\u2502 2    \u2506 2    \u2506  b    \u2506  b    \u2502\n\u2502 3    \u2506 3    \u2506   c   \u2506   c   \u2502\n\u2502 4    \u2506 4    \u2506 d     \u2506 d     \u2502\n\u2502 5    \u2506 5    \u2506 e     \u2506 e     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 a    \u2506 a     \u2502\n\u2502 2    \u2506 2    \u2506 b    \u2506  b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506   c   \u2502\n\u2502 4    \u2506 4    \u2506 d    \u2506 d     \u2502\n\u2502 5    \u2506 5    \u2506 e    \u2506 e     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.BaseInNTransformer.find_columns","title":"grizz.transformer.BaseInNTransformer.find_columns","text":"<pre><code>find_columns(frame: DataFrame) -&gt; tuple[str, ...]\n</code></pre> <p>Find the columns to transform.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The input DataFrame. Sometimes the columns to transform are found by analyzing the input DataFrame.</p> required <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>The columns to transform.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import StripChars\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...         \"col4\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; transformer = StripChars(columns=[\"col2\", \"col3\"])\n&gt;&gt;&gt; transformer.find_columns(frame)\n('col2', 'col3')\n&gt;&gt;&gt; transformer = StripChars()\n&gt;&gt;&gt; transformer.find_columns(frame)\n('col1', 'col2', 'col3', 'col4')\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.BaseInNTransformer.find_common_columns","title":"grizz.transformer.BaseInNTransformer.find_common_columns","text":"<pre><code>find_common_columns(frame: DataFrame) -&gt; tuple[str, ...]\n</code></pre> <p>Find the common columns between the DataFrame columns and the input columns.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The input DataFrame. Sometimes the columns to transform are found by analyzing the input DataFrame.</p> required <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>The common columns.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import StripChars\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...         \"col4\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; transformer = StripChars(columns=[\"col2\", \"col3\", \"col5\"])\n&gt;&gt;&gt; transformer.find_common_columns(frame)\n('col2', 'col3')\n&gt;&gt;&gt; transformer = StripChars()\n&gt;&gt;&gt; transformer.find_common_columns(frame)\n('col1', 'col2', 'col3', 'col4')\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.BaseInNTransformer.find_missing_columns","title":"grizz.transformer.BaseInNTransformer.find_missing_columns","text":"<pre><code>find_missing_columns(frame: DataFrame) -&gt; tuple[str, ...]\n</code></pre> <p>Find the missing columns.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The input DataFrame. Sometimes the columns to transform are found by analyzing the input DataFrame.</p> required <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>The missing columns.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import StripChars\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...         \"col4\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; transformer = StripChars(columns=[\"col2\", \"col3\", \"col5\"])\n&gt;&gt;&gt; transformer.find_missing_columns(frame)\n('col5',)\n&gt;&gt;&gt; transformer = StripChars()\n&gt;&gt;&gt; transformer.find_missing_columns(frame)\n()\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.BaseTransformer","title":"grizz.transformer.BaseTransformer","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to transform a <code>polars.DataFrame</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Cast\n&gt;&gt;&gt; transformer = Cast(columns=[\"col1\", \"col3\"], dtype=pl.Int32)\n&gt;&gt;&gt; transformer\nCastTransformer(columns=('col1', 'col3'), exclude_columns=(), missing_policy='raise', dtype=Int32)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i32  \u2506 str  \u2506 i32  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.BaseTransformer.equal","title":"grizz.transformer.BaseTransformer.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any, equal_nan: bool = False) -&gt; bool\n</code></pre> <p>Indicate if two objects are equal or not.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The other object to compare.</p> required <code>equal_nan</code> <code>bool</code> <p>Whether to compare NaN's as equal. If <code>True</code>, NaN's in both objects will be considered equal.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two are equal, otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Cast\n&gt;&gt;&gt; obj1 = Cast(columns=[\"col1\", \"col3\"], dtype=pl.Int32)\n&gt;&gt;&gt; obj2 = Cast(columns=[\"col1\", \"col3\"], dtype=pl.Int32)\n&gt;&gt;&gt; obj3 = Cast(columns=[\"col2\", \"col3\"], dtype=pl.Float32)\n&gt;&gt;&gt; obj1.equal(obj2)\nTrue\n&gt;&gt;&gt; obj1.equal(obj3)\nFalse\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.BaseTransformer.fit","title":"grizz.transformer.BaseTransformer.fit  <code>abstractmethod</code>","text":"<pre><code>fit(frame: DataFrame) -&gt; None\n</code></pre> <p>Fit to the data in the <code>polars.DataFrame</code>.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The <code>polars.DataFrame</code> to fit.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Cast\n&gt;&gt;&gt; transformer = Cast(columns=[\"col1\", \"col3\"], dtype=pl.Int32)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; transformer.fit(frame)\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i32  \u2506 str  \u2506 i32  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.BaseTransformer.fit_transform","title":"grizz.transformer.BaseTransformer.fit_transform  <code>abstractmethod</code>","text":"<pre><code>fit_transform(frame: DataFrame) -&gt; None\n</code></pre> <p>Fit to the data, then transform it.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The <code>polars.DataFrame</code> to fit.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The transformed DataFrame.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Cast\n&gt;&gt;&gt; transformer = Cast(columns=[\"col1\", \"col3\"], dtype=pl.Int32)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.fit_transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i32  \u2506 str  \u2506 i32  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.BaseTransformer.transform","title":"grizz.transformer.BaseTransformer.transform  <code>abstractmethod</code>","text":"<pre><code>transform(frame: DataFrame) -&gt; DataFrame\n</code></pre> <p>Transform the data in the <code>polars.DataFrame</code>.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The <code>polars.DataFrame</code> to transform.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>The transformed DataFrame.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Cast\n&gt;&gt;&gt; transformer = Cast(columns=[\"col1\", \"col3\"], dtype=pl.Int32)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i32  \u2506 str  \u2506 i32  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.Binarizer","title":"grizz.transformer.Binarizer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to binarize data according to a threshold.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to scale. <code>None</code> means all the columns.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the copied columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the copied columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>sklearn.preprocessing.Binarizer</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Binarizer\n&gt;&gt;&gt; transformer = Binarizer(\n...     columns=[\"col1\", \"col3\"], prefix=\"\", suffix=\"_out\", threshold=1.5\n... )\n&gt;&gt;&gt; transformer\nBinarizerTransformer(columns=('col1', 'col3'), exclude_columns=(), missing_policy='raise', exist_policy='raise', prefix='', suffix='_out', threshold=1.5)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [0, 1, 2, 3, 4, 5],\n...         \"col2\": [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [5, 4, 3, 2, 1, 0],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (6, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0    \u2506 0    \u2506 5    \u2506 a    \u2502\n\u2502 1    \u2506 1    \u2506 4    \u2506 b    \u2502\n\u2502 2    \u2506 2    \u2506 3    \u2506 c    \u2502\n\u2502 3    \u2506 3    \u2506 2    \u2506 d    \u2502\n\u2502 4    \u2506 4    \u2506 1    \u2506 e    \u2502\n\u2502 5    \u2506 5    \u2506 0    \u2506 f    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n&gt;&gt;&gt; out = transformer.fit_transform(frame)\n&gt;&gt;&gt; out\nshape: (6, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out \u2506 col3_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2506 i64      \u2506 i64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0    \u2506 0    \u2506 5    \u2506 a    \u2506 0        \u2506 1        \u2502\n\u2502 1    \u2506 1    \u2506 4    \u2506 b    \u2506 0        \u2506 1        \u2502\n\u2502 2    \u2506 2    \u2506 3    \u2506 c    \u2506 1        \u2506 1        \u2502\n\u2502 3    \u2506 3    \u2506 2    \u2506 d    \u2506 1        \u2506 1        \u2502\n\u2502 4    \u2506 4    \u2506 1    \u2506 e    \u2506 1        \u2506 0        \u2502\n\u2502 5    \u2506 5    \u2506 0    \u2506 f    \u2506 1        \u2506 0        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.BinarizerTransformer","title":"grizz.transformer.BinarizerTransformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to binarize data according to a threshold.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to scale. <code>None</code> means all the columns.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the copied columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the copied columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>sklearn.preprocessing.Binarizer</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Binarizer\n&gt;&gt;&gt; transformer = Binarizer(\n...     columns=[\"col1\", \"col3\"], prefix=\"\", suffix=\"_out\", threshold=1.5\n... )\n&gt;&gt;&gt; transformer\nBinarizerTransformer(columns=('col1', 'col3'), exclude_columns=(), missing_policy='raise', exist_policy='raise', prefix='', suffix='_out', threshold=1.5)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [0, 1, 2, 3, 4, 5],\n...         \"col2\": [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [5, 4, 3, 2, 1, 0],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (6, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0    \u2506 0    \u2506 5    \u2506 a    \u2502\n\u2502 1    \u2506 1    \u2506 4    \u2506 b    \u2502\n\u2502 2    \u2506 2    \u2506 3    \u2506 c    \u2502\n\u2502 3    \u2506 3    \u2506 2    \u2506 d    \u2502\n\u2502 4    \u2506 4    \u2506 1    \u2506 e    \u2502\n\u2502 5    \u2506 5    \u2506 0    \u2506 f    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n&gt;&gt;&gt; out = transformer.fit_transform(frame)\n&gt;&gt;&gt; out\nshape: (6, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out \u2506 col3_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2506 i64      \u2506 i64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0    \u2506 0    \u2506 5    \u2506 a    \u2506 0        \u2506 1        \u2502\n\u2502 1    \u2506 1    \u2506 4    \u2506 b    \u2506 0        \u2506 1        \u2502\n\u2502 2    \u2506 2    \u2506 3    \u2506 c    \u2506 1        \u2506 1        \u2502\n\u2502 3    \u2506 3    \u2506 2    \u2506 d    \u2506 1        \u2506 1        \u2502\n\u2502 4    \u2506 4    \u2506 1    \u2506 e    \u2506 1        \u2506 0        \u2502\n\u2502 5    \u2506 5    \u2506 0    \u2506 f    \u2506 1        \u2506 0        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.Cast","title":"grizz.transformer.Cast","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to convert some columns to a new data type.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to convert. <code>None</code> means all the columns.</p> required <code>dtype</code> <code>type[DataType]</code> <p>The target data type.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>cast</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Cast\n&gt;&gt;&gt; transformer = Cast(columns=[\"col1\", \"col3\"], dtype=pl.Int32)\n&gt;&gt;&gt; transformer\nCastTransformer(columns=('col1', 'col3'), exclude_columns=(), missing_policy='raise', dtype=Int32)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i32  \u2506 str  \u2506 i32  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.CastTransformer","title":"grizz.transformer.CastTransformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to convert some columns to a new data type.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to convert. <code>None</code> means all the columns.</p> required <code>dtype</code> <code>type[DataType]</code> <p>The target data type.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>cast</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Cast\n&gt;&gt;&gt; transformer = Cast(columns=[\"col1\", \"col3\"], dtype=pl.Int32)\n&gt;&gt;&gt; transformer\nCastTransformer(columns=('col1', 'col3'), exclude_columns=(), missing_policy='raise', dtype=Int32)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i32  \u2506 str  \u2506 i32  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.CategoricalCast","title":"grizz.transformer.CategoricalCast","text":"<p>               Bases: <code>BaseIn1Out1Transformer</code></p> <p>Implement a transformer to convert a column to categorical data type.</p> <p>Parameters:</p> Name Type Description Default <code>in_col</code> <code>str</code> <p>The input column name to cast.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>polars.Categorical</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import CategoricalCast\n&gt;&gt;&gt; transformer = CategoricalCast(in_col=\"col1\", out_col=\"out\")\n&gt;&gt;&gt; transformer\nCategoricalCastTransformer(in_col='col1', out_col='out', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...         \"col2\": [1.0, 2.0, 3.0, 4.0, 5.0],\n...     },\n...     schema={\"col1\": pl.String, \"col2\": pl.Float64},\n... )\n&gt;&gt;&gt; frame\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2502\n\u2502 ---  \u2506 ---  \u2502\n\u2502 str  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a    \u2506 1.0  \u2502\n\u2502 b    \u2506 2.0  \u2502\n\u2502 c    \u2506 3.0  \u2502\n\u2502 d    \u2506 4.0  \u2502\n\u2502 e    \u2506 5.0  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 out \u2502\n\u2502 ---  \u2506 ---  \u2506 --- \u2502\n\u2502 str  \u2506 f64  \u2506 cat \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a    \u2506 1.0  \u2506 a   \u2502\n\u2502 b    \u2506 2.0  \u2506 b   \u2502\n\u2502 c    \u2506 3.0  \u2506 c   \u2502\n\u2502 d    \u2506 4.0  \u2506 d   \u2502\n\u2502 e    \u2506 5.0  \u2506 e   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.CategoricalCastTransformer","title":"grizz.transformer.CategoricalCastTransformer","text":"<p>               Bases: <code>BaseIn1Out1Transformer</code></p> <p>Implement a transformer to convert a column to categorical data type.</p> <p>Parameters:</p> Name Type Description Default <code>in_col</code> <code>str</code> <p>The input column name to cast.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>polars.Categorical</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import CategoricalCast\n&gt;&gt;&gt; transformer = CategoricalCast(in_col=\"col1\", out_col=\"out\")\n&gt;&gt;&gt; transformer\nCategoricalCastTransformer(in_col='col1', out_col='out', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...         \"col2\": [1.0, 2.0, 3.0, 4.0, 5.0],\n...     },\n...     schema={\"col1\": pl.String, \"col2\": pl.Float64},\n... )\n&gt;&gt;&gt; frame\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2502\n\u2502 ---  \u2506 ---  \u2502\n\u2502 str  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a    \u2506 1.0  \u2502\n\u2502 b    \u2506 2.0  \u2502\n\u2502 c    \u2506 3.0  \u2502\n\u2502 d    \u2506 4.0  \u2502\n\u2502 e    \u2506 5.0  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 out \u2502\n\u2502 ---  \u2506 ---  \u2506 --- \u2502\n\u2502 str  \u2506 f64  \u2506 cat \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a    \u2506 1.0  \u2506 a   \u2502\n\u2502 b    \u2506 2.0  \u2506 b   \u2502\n\u2502 c    \u2506 3.0  \u2506 c   \u2502\n\u2502 d    \u2506 4.0  \u2506 d   \u2502\n\u2502 e    \u2506 5.0  \u2506 e   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ColumnClose","title":"grizz.transformer.ColumnClose","text":"<p>               Bases: <code>BaseIn2Out1Transformer</code></p> <p>Implement a transformer to compute a column that indicates if the values of two columns are element-wise equal within a tolerance.</p> <p>The output column contains <code>True</code> if two columns are element-wise equal within a tolerance. Internally, this tranformer computes: <code>out = (|actual - expected| &lt;= atol + rtol * |expected|)</code></p> <p>Parameters:</p> Name Type Description Default <code>actual</code> <code>str</code> <p>The actual input column name. This column must be a numeric column.</p> required <code>expected</code> <code>str</code> <p>The expected input column name. This column must be a numeric column.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>atol</code> <code>float</code> <p>The absolute tolerance parameter.</p> <code>1e-08</code> <code>rtol</code> <code>float</code> <p>The relative tolerance parameter.</p> <code>1e-05</code> <code>equal_nan</code> <code>bool</code> <p>Whether to compare NaN's as equal. If <code>True</code>, NaN's in <code>actual</code> will be considered equal to NaN's in <code>expected</code> in the output column.</p> <code>False</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ColumnClose\n&gt;&gt;&gt; transformer = ColumnClose(actual=\"col1\", expected=\"col2\", out_col=\"out\")\n&gt;&gt;&gt; transformer\nColumnCloseTransformer(actual='col1', expected='col2', out_col='out', atol=1e-08, rtol=1e-05, equal_nan=False, exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [5, 4, 3, 2, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 out   \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2506 false \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2506 false \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506 true  \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2506 false \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2506 false \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ColumnCloseTransformer","title":"grizz.transformer.ColumnCloseTransformer","text":"<p>               Bases: <code>BaseIn2Out1Transformer</code></p> <p>Implement a transformer to compute a column that indicates if the values of two columns are element-wise equal within a tolerance.</p> <p>The output column contains <code>True</code> if two columns are element-wise equal within a tolerance. Internally, this tranformer computes: <code>out = (|actual - expected| &lt;= atol + rtol * |expected|)</code></p> <p>Parameters:</p> Name Type Description Default <code>actual</code> <code>str</code> <p>The actual input column name. This column must be a numeric column.</p> required <code>expected</code> <code>str</code> <p>The expected input column name. This column must be a numeric column.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>atol</code> <code>float</code> <p>The absolute tolerance parameter.</p> <code>1e-08</code> <code>rtol</code> <code>float</code> <p>The relative tolerance parameter.</p> <code>1e-05</code> <code>equal_nan</code> <code>bool</code> <p>Whether to compare NaN's as equal. If <code>True</code>, NaN's in <code>actual</code> will be considered equal to NaN's in <code>expected</code> in the output column.</p> <code>False</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ColumnClose\n&gt;&gt;&gt; transformer = ColumnClose(actual=\"col1\", expected=\"col2\", out_col=\"out\")\n&gt;&gt;&gt; transformer\nColumnCloseTransformer(actual='col1', expected='col2', out_col='out', atol=1e-08, rtol=1e-05, equal_nan=False, exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [5, 4, 3, 2, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 out   \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2506 false \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2506 false \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506 true  \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2506 false \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2506 false \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ColumnEqual","title":"grizz.transformer.ColumnEqual","text":"<p>               Bases: <code>BaseColumnComparatorTransformer</code></p> <p>Implement a transformer that computes the equal operation between two columns (<code>in1 == in2</code>).</p> <p>Parameters:</p> Name Type Description Default <code>in1_col</code> <code>str</code> <p>The first input column name.</p> required <code>in2_col</code> <code>str</code> <p>The second input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ColumnEqual\n&gt;&gt;&gt; transformer = ColumnEqual(in1_col=\"col1\", in2_col=\"col2\", out_col=\"out\")\n&gt;&gt;&gt; transformer\nColumnEqualTransformer(in1_col='col1', in2_col='col2', out_col='out', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [5, 4, 3, 2, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 out   \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2506 false \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2506 false \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506 true  \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2506 false \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2506 false \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ColumnEqualMissing","title":"grizz.transformer.ColumnEqualMissing","text":"<p>               Bases: <code>BaseColumnComparatorTransformer</code></p> <p>Implement a transformer that computes the equal operation between two columns (<code>in1 == in2</code>), where null values are not propagated.</p> <p>Parameters:</p> Name Type Description Default <code>in1_col</code> <code>str</code> <p>The first input column name.</p> required <code>in2_col</code> <code>str</code> <p>The second input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ColumnEqualMissing\n&gt;&gt;&gt; transformer = ColumnEqualMissing(in1_col=\"col1\", in2_col=\"col2\", out_col=\"out\")\n&gt;&gt;&gt; transformer\nColumnEqualMissingTransformer(in1_col='col1', in2_col='col2', out_col='out', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [5, 4, 3, 2, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 out   \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2506 false \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2506 false \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506 true  \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2506 false \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2506 false \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ColumnEqualMissingTransformer","title":"grizz.transformer.ColumnEqualMissingTransformer","text":"<p>               Bases: <code>BaseColumnComparatorTransformer</code></p> <p>Implement a transformer that computes the equal operation between two columns (<code>in1 == in2</code>), where null values are not propagated.</p> <p>Parameters:</p> Name Type Description Default <code>in1_col</code> <code>str</code> <p>The first input column name.</p> required <code>in2_col</code> <code>str</code> <p>The second input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ColumnEqualMissing\n&gt;&gt;&gt; transformer = ColumnEqualMissing(in1_col=\"col1\", in2_col=\"col2\", out_col=\"out\")\n&gt;&gt;&gt; transformer\nColumnEqualMissingTransformer(in1_col='col1', in2_col='col2', out_col='out', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [5, 4, 3, 2, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 out   \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2506 false \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2506 false \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506 true  \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2506 false \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2506 false \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ColumnEqualTransformer","title":"grizz.transformer.ColumnEqualTransformer","text":"<p>               Bases: <code>BaseColumnComparatorTransformer</code></p> <p>Implement a transformer that computes the equal operation between two columns (<code>in1 == in2</code>).</p> <p>Parameters:</p> Name Type Description Default <code>in1_col</code> <code>str</code> <p>The first input column name.</p> required <code>in2_col</code> <code>str</code> <p>The second input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ColumnEqual\n&gt;&gt;&gt; transformer = ColumnEqual(in1_col=\"col1\", in2_col=\"col2\", out_col=\"out\")\n&gt;&gt;&gt; transformer\nColumnEqualTransformer(in1_col='col1', in2_col='col2', out_col='out', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [5, 4, 3, 2, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 out   \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2506 false \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2506 false \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506 true  \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2506 false \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2506 false \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ColumnGreater","title":"grizz.transformer.ColumnGreater","text":"<p>               Bases: <code>BaseColumnComparatorTransformer</code></p> <p>Implement a transformer that computes the greater than operation between two columns (<code>in1 &gt; in2</code>).</p> <p>Parameters:</p> Name Type Description Default <code>in1_col</code> <code>str</code> <p>The first input column name.</p> required <code>in2_col</code> <code>str</code> <p>The second input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ColumnGreater\n&gt;&gt;&gt; transformer = ColumnGreater(in1_col=\"col1\", in2_col=\"col2\", out_col=\"out\")\n&gt;&gt;&gt; transformer\nColumnGreaterTransformer(in1_col='col1', in2_col='col2', out_col='out', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [5, 4, 3, 2, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 out   \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2506 false \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2506 false \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506 false \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2506 true  \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2506 true  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ColumnGreaterEqual","title":"grizz.transformer.ColumnGreaterEqual","text":"<p>               Bases: <code>BaseColumnComparatorTransformer</code></p> <p>Implement a transformer that computes the greater than or equal operation between two columns (<code>in1 &gt;= in2</code>).</p> <p>Parameters:</p> Name Type Description Default <code>in1_col</code> <code>str</code> <p>The first input column name.</p> required <code>in2_col</code> <code>str</code> <p>The second input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ColumnGreaterEqual\n&gt;&gt;&gt; transformer = ColumnGreaterEqual(in1_col=\"col1\", in2_col=\"col2\", out_col=\"out\")\n&gt;&gt;&gt; transformer\nColumnGreaterEqualTransformer(in1_col='col1', in2_col='col2', out_col='out', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [5, 4, 3, 2, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 out   \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2506 false \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2506 false \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506 true  \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2506 true  \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2506 true  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ColumnGreaterEqualTransformer","title":"grizz.transformer.ColumnGreaterEqualTransformer","text":"<p>               Bases: <code>BaseColumnComparatorTransformer</code></p> <p>Implement a transformer that computes the greater than or equal operation between two columns (<code>in1 &gt;= in2</code>).</p> <p>Parameters:</p> Name Type Description Default <code>in1_col</code> <code>str</code> <p>The first input column name.</p> required <code>in2_col</code> <code>str</code> <p>The second input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ColumnGreaterEqual\n&gt;&gt;&gt; transformer = ColumnGreaterEqual(in1_col=\"col1\", in2_col=\"col2\", out_col=\"out\")\n&gt;&gt;&gt; transformer\nColumnGreaterEqualTransformer(in1_col='col1', in2_col='col2', out_col='out', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [5, 4, 3, 2, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 out   \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2506 false \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2506 false \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506 true  \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2506 true  \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2506 true  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ColumnGreaterTransformer","title":"grizz.transformer.ColumnGreaterTransformer","text":"<p>               Bases: <code>BaseColumnComparatorTransformer</code></p> <p>Implement a transformer that computes the greater than operation between two columns (<code>in1 &gt; in2</code>).</p> <p>Parameters:</p> Name Type Description Default <code>in1_col</code> <code>str</code> <p>The first input column name.</p> required <code>in2_col</code> <code>str</code> <p>The second input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ColumnGreater\n&gt;&gt;&gt; transformer = ColumnGreater(in1_col=\"col1\", in2_col=\"col2\", out_col=\"out\")\n&gt;&gt;&gt; transformer\nColumnGreaterTransformer(in1_col='col1', in2_col='col2', out_col='out', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [5, 4, 3, 2, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 out   \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2506 false \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2506 false \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506 false \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2506 true  \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2506 true  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ColumnLower","title":"grizz.transformer.ColumnLower","text":"<p>               Bases: <code>BaseColumnComparatorTransformer</code></p> <p>Implement a transformer that computes the lower than operation between two columns (<code>in1 &lt; in2</code>).</p> <p>Parameters:</p> Name Type Description Default <code>in1_col</code> <code>str</code> <p>The first input column name.</p> required <code>in2_col</code> <code>str</code> <p>The second input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ColumnLower\n&gt;&gt;&gt; transformer = ColumnLower(in1_col=\"col1\", in2_col=\"col2\", out_col=\"out\")\n&gt;&gt;&gt; transformer\nColumnLowerTransformer(in1_col='col1', in2_col='col2', out_col='out', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [5, 4, 3, 2, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 out   \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2506 true  \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2506 true  \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506 false \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2506 false \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2506 false \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ColumnLowerEqual","title":"grizz.transformer.ColumnLowerEqual","text":"<p>               Bases: <code>BaseColumnComparatorTransformer</code></p> <p>Implement a transformer that computes the lower than or equal operation between two columns (<code>in1 &lt;= in2</code>).</p> <p>Parameters:</p> Name Type Description Default <code>in1_col</code> <code>str</code> <p>The first input column name.</p> required <code>in2_col</code> <code>str</code> <p>The second input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ColumnLowerEqual\n&gt;&gt;&gt; transformer = ColumnLowerEqual(in1_col=\"col1\", in2_col=\"col2\", out_col=\"out\")\n&gt;&gt;&gt; transformer\nColumnLowerEqualTransformer(in1_col='col1', in2_col='col2', out_col='out', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [5, 4, 3, 2, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 out   \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2506 true  \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2506 true  \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506 true  \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2506 false \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2506 false \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ColumnLowerEqualTransformer","title":"grizz.transformer.ColumnLowerEqualTransformer","text":"<p>               Bases: <code>BaseColumnComparatorTransformer</code></p> <p>Implement a transformer that computes the lower than or equal operation between two columns (<code>in1 &lt;= in2</code>).</p> <p>Parameters:</p> Name Type Description Default <code>in1_col</code> <code>str</code> <p>The first input column name.</p> required <code>in2_col</code> <code>str</code> <p>The second input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ColumnLowerEqual\n&gt;&gt;&gt; transformer = ColumnLowerEqual(in1_col=\"col1\", in2_col=\"col2\", out_col=\"out\")\n&gt;&gt;&gt; transformer\nColumnLowerEqualTransformer(in1_col='col1', in2_col='col2', out_col='out', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [5, 4, 3, 2, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 out   \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2506 true  \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2506 true  \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506 true  \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2506 false \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2506 false \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ColumnLowerTransformer","title":"grizz.transformer.ColumnLowerTransformer","text":"<p>               Bases: <code>BaseColumnComparatorTransformer</code></p> <p>Implement a transformer that computes the lower than operation between two columns (<code>in1 &lt; in2</code>).</p> <p>Parameters:</p> Name Type Description Default <code>in1_col</code> <code>str</code> <p>The first input column name.</p> required <code>in2_col</code> <code>str</code> <p>The second input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ColumnLower\n&gt;&gt;&gt; transformer = ColumnLower(in1_col=\"col1\", in2_col=\"col2\", out_col=\"out\")\n&gt;&gt;&gt; transformer\nColumnLowerTransformer(in1_col='col1', in2_col='col2', out_col='out', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [5, 4, 3, 2, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 out   \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2506 true  \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2506 true  \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506 false \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2506 false \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2506 false \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ColumnNotEqual","title":"grizz.transformer.ColumnNotEqual","text":"<p>               Bases: <code>BaseColumnComparatorTransformer</code></p> <p>Implement a transformer that computes the not equal operation between two columns (<code>in1 != in2</code>).</p> <p>Parameters:</p> Name Type Description Default <code>in1_col</code> <code>str</code> <p>The first input column name.</p> required <code>in2_col</code> <code>str</code> <p>The second input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ColumnNotEqual\n&gt;&gt;&gt; transformer = ColumnNotEqual(in1_col=\"col1\", in2_col=\"col2\", out_col=\"out\")\n&gt;&gt;&gt; transformer\nColumnNotEqualTransformer(in1_col='col1', in2_col='col2', out_col='out', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [5, 4, 3, 2, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 out   \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2506 true  \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2506 true  \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506 false \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2506 true  \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2506 true  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ColumnNotEqualMissing","title":"grizz.transformer.ColumnNotEqualMissing","text":"<p>               Bases: <code>BaseColumnComparatorTransformer</code></p> <p>Implement a transformer that computes the not equal operation between two columns (<code>in1 != in2</code>), where null values are not propagated.</p> <p>Parameters:</p> Name Type Description Default <code>in1_col</code> <code>str</code> <p>The first input column name.</p> required <code>in2_col</code> <code>str</code> <p>The second input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ColumnNotEqualMissing\n&gt;&gt;&gt; transformer = ColumnNotEqualMissing(in1_col=\"col1\", in2_col=\"col2\", out_col=\"out\")\n&gt;&gt;&gt; transformer\nColumnNotEqualMissingTransformer(in1_col='col1', in2_col='col2', out_col='out', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [5, 4, 3, 2, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 out   \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2506 true  \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2506 true  \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506 false \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2506 true  \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2506 true  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ColumnNotEqualMissingTransformer","title":"grizz.transformer.ColumnNotEqualMissingTransformer","text":"<p>               Bases: <code>BaseColumnComparatorTransformer</code></p> <p>Implement a transformer that computes the not equal operation between two columns (<code>in1 != in2</code>), where null values are not propagated.</p> <p>Parameters:</p> Name Type Description Default <code>in1_col</code> <code>str</code> <p>The first input column name.</p> required <code>in2_col</code> <code>str</code> <p>The second input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ColumnNotEqualMissing\n&gt;&gt;&gt; transformer = ColumnNotEqualMissing(in1_col=\"col1\", in2_col=\"col2\", out_col=\"out\")\n&gt;&gt;&gt; transformer\nColumnNotEqualMissingTransformer(in1_col='col1', in2_col='col2', out_col='out', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [5, 4, 3, 2, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 out   \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2506 true  \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2506 true  \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506 false \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2506 true  \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2506 true  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ColumnNotEqualTransformer","title":"grizz.transformer.ColumnNotEqualTransformer","text":"<p>               Bases: <code>BaseColumnComparatorTransformer</code></p> <p>Implement a transformer that computes the not equal operation between two columns (<code>in1 != in2</code>).</p> <p>Parameters:</p> Name Type Description Default <code>in1_col</code> <code>str</code> <p>The first input column name.</p> required <code>in2_col</code> <code>str</code> <p>The second input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ColumnNotEqual\n&gt;&gt;&gt; transformer = ColumnNotEqual(in1_col=\"col1\", in2_col=\"col2\", out_col=\"out\")\n&gt;&gt;&gt; transformer\nColumnNotEqualTransformer(in1_col='col1', in2_col='col2', out_col='out', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [5, 4, 3, 2, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 out   \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2506 true  \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2506 true  \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506 false \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2506 true  \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2506 true  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ColumnSelection","title":"grizz.transformer.ColumnSelection","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a <code>polars.DataFrame</code> transformer to select a subset of columns.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to keep.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ColumnSelection\n&gt;&gt;&gt; transformer = ColumnSelection(columns=[\"col1\", \"col2\"])\n&gt;&gt;&gt; transformer\nColumnSelectionTransformer(columns=('col1', 'col2'), exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [\"2020-1-1\", \"2020-1-2\", \"2020-1-31\", \"2020-12-31\", None],\n...         \"col2\": [1, 2, 3, 4, 5],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\n    shape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1       \u2506 col2 \u2502\n\u2502 ---        \u2506 ---  \u2502\n\u2502 str        \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-1-1   \u2506 1    \u2502\n\u2502 2020-1-2   \u2506 2    \u2502\n\u2502 2020-1-31  \u2506 3    \u2502\n\u2502 2020-12-31 \u2506 4    \u2502\n\u2502 null       \u2506 5    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ColumnSelectionTransformer","title":"grizz.transformer.ColumnSelectionTransformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a <code>polars.DataFrame</code> transformer to select a subset of columns.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to keep.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ColumnSelection\n&gt;&gt;&gt; transformer = ColumnSelection(columns=[\"col1\", \"col2\"])\n&gt;&gt;&gt; transformer\nColumnSelectionTransformer(columns=('col1', 'col2'), exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [\"2020-1-1\", \"2020-1-2\", \"2020-1-31\", \"2020-12-31\", None],\n...         \"col2\": [1, 2, 3, 4, 5],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\n    shape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1       \u2506 col2 \u2502\n\u2502 ---        \u2506 ---  \u2502\n\u2502 str        \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-1-1   \u2506 1    \u2502\n\u2502 2020-1-2   \u2506 2    \u2502\n\u2502 2020-1-31  \u2506 3    \u2502\n\u2502 2020-12-31 \u2506 4    \u2502\n\u2502 null       \u2506 5    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ConcatColumns","title":"grizz.transformer.ConcatColumns","text":"<p>               Bases: <code>BaseInNOut1Transformer</code></p> <p>Implement a transformer to concatenate columns into a new column.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to concatenate. The columns should have the same type or compatible types. If <code>None</code>, it processes all the columns.</p> required <code>out_col</code> <code>str</code> <p>The output column.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ConcatColumns\n&gt;&gt;&gt; transformer = ConcatColumns(columns=[\"col1\", \"col2\", \"col3\"], out_col=\"out\")\n&gt;&gt;&gt; transformer\nConcatColumnsTransformer(columns=('col1', 'col2', 'col3'), out_col='out', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [11, 12, 13, 14, 15],\n...         \"col2\": [21, 22, 23, 24, 25],\n...         \"col3\": [31, 32, 33, 34, 35],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11   \u2506 21   \u2506 31   \u2506 a    \u2502\n\u2502 12   \u2506 22   \u2506 32   \u2506 b    \u2502\n\u2502 13   \u2506 23   \u2506 33   \u2506 c    \u2502\n\u2502 14   \u2506 24   \u2506 34   \u2506 d    \u2502\n\u2502 15   \u2506 25   \u2506 35   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 out          \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---          \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2506 list[i64]    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11   \u2506 21   \u2506 31   \u2506 a    \u2506 [11, 21, 31] \u2502\n\u2502 12   \u2506 22   \u2506 32   \u2506 b    \u2506 [12, 22, 32] \u2502\n\u2502 13   \u2506 23   \u2506 33   \u2506 c    \u2506 [13, 23, 33] \u2502\n\u2502 14   \u2506 24   \u2506 34   \u2506 d    \u2506 [14, 24, 34] \u2502\n\u2502 15   \u2506 25   \u2506 35   \u2506 e    \u2506 [15, 25, 35] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ConcatColumnsTransformer","title":"grizz.transformer.ConcatColumnsTransformer","text":"<p>               Bases: <code>BaseInNOut1Transformer</code></p> <p>Implement a transformer to concatenate columns into a new column.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to concatenate. The columns should have the same type or compatible types. If <code>None</code>, it processes all the columns.</p> required <code>out_col</code> <code>str</code> <p>The output column.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ConcatColumns\n&gt;&gt;&gt; transformer = ConcatColumns(columns=[\"col1\", \"col2\", \"col3\"], out_col=\"out\")\n&gt;&gt;&gt; transformer\nConcatColumnsTransformer(columns=('col1', 'col2', 'col3'), out_col='out', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [11, 12, 13, 14, 15],\n...         \"col2\": [21, 22, 23, 24, 25],\n...         \"col3\": [31, 32, 33, 34, 35],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11   \u2506 21   \u2506 31   \u2506 a    \u2502\n\u2502 12   \u2506 22   \u2506 32   \u2506 b    \u2502\n\u2502 13   \u2506 23   \u2506 33   \u2506 c    \u2502\n\u2502 14   \u2506 24   \u2506 34   \u2506 d    \u2502\n\u2502 15   \u2506 25   \u2506 35   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 out          \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---          \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2506 list[i64]    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11   \u2506 21   \u2506 31   \u2506 a    \u2506 [11, 21, 31] \u2502\n\u2502 12   \u2506 22   \u2506 32   \u2506 b    \u2506 [12, 22, 32] \u2502\n\u2502 13   \u2506 23   \u2506 33   \u2506 c    \u2506 [13, 23, 33] \u2502\n\u2502 14   \u2506 24   \u2506 34   \u2506 d    \u2506 [14, 24, 34] \u2502\n\u2502 15   \u2506 25   \u2506 35   \u2506 e    \u2506 [15, 25, 35] \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.CopyColumn","title":"grizz.transformer.CopyColumn","text":"<p>               Bases: <code>BaseIn1Out1Transformer</code></p> <p>Implement a <code>polars.DataFrame</code> to copy a column.</p> <p>Parameters:</p> Name Type Description Default <code>in_col</code> <code>str</code> <p>The input column name i.e. the column to copy.</p> required <code>out_col</code> <code>str</code> <p>The output column name i.e. the copied column.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import CopyColumn\n&gt;&gt;&gt; transformer = CopyColumn(in_col=\"col1\", out_col=\"out\")\n&gt;&gt;&gt; transformer\nCopyColumnTransformer(in_col='col1', out_col='out', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 --- \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2506 1   \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2506 2   \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2506 3   \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2506 4   \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2506 5   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.CopyColumnTransformer","title":"grizz.transformer.CopyColumnTransformer","text":"<p>               Bases: <code>BaseIn1Out1Transformer</code></p> <p>Implement a <code>polars.DataFrame</code> to copy a column.</p> <p>Parameters:</p> Name Type Description Default <code>in_col</code> <code>str</code> <p>The input column name i.e. the column to copy.</p> required <code>out_col</code> <code>str</code> <p>The output column name i.e. the copied column.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import CopyColumn\n&gt;&gt;&gt; transformer = CopyColumn(in_col=\"col1\", out_col=\"out\")\n&gt;&gt;&gt; transformer\nCopyColumnTransformer(in_col='col1', out_col='out', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 --- \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2506 1   \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2506 2   \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2506 3   \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2506 4   \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2506 5   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.CopyColumns","title":"grizz.transformer.CopyColumns","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to copy some columns.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to copy. <code>None</code> means all the columns.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the copied columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the copied columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import CopyColumns\n&gt;&gt;&gt; transformer = CopyColumns(columns=[\"col1\", \"col3\"], prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nCopyColumnsTransformer(columns=('col1', 'col3'), exclude_columns=(), missing_policy='raise', exist_policy='raise', prefix='', suffix='_out')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out \u2506 col3_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2506 i64      \u2506 str      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2506 1        \u2506 1        \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2506 2        \u2506 2        \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2506 3        \u2506 3        \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2506 4        \u2506 4        \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2506 5        \u2506 5        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.CopyColumnsTransformer","title":"grizz.transformer.CopyColumnsTransformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to copy some columns.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to copy. <code>None</code> means all the columns.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the copied columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the copied columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import CopyColumns\n&gt;&gt;&gt; transformer = CopyColumns(columns=[\"col1\", \"col3\"], prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nCopyColumnsTransformer(columns=('col1', 'col3'), exclude_columns=(), missing_policy='raise', exist_policy='raise', prefix='', suffix='_out')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out \u2506 col3_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2506 i64      \u2506 str      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2506 1        \u2506 1        \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2506 2        \u2506 2        \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2506 3        \u2506 3        \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2506 4        \u2506 4        \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2506 5        \u2506 5        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.DecimalCast","title":"grizz.transformer.DecimalCast","text":"<p>               Bases: <code>CastTransformer</code></p> <p>Implement a transformer to convert columns of type decimal to a new data type.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to convert. <code>None</code> means all the columns.</p> required <code>dtype</code> <code>type[DataType]</code> <p>The target data type.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>cast</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import DecimalCast\n&gt;&gt;&gt; transformer = DecimalCast(columns=[\"col1\", \"col2\"], dtype=pl.Float32)\n&gt;&gt;&gt; transformer\nDecimalCastTransformer(columns=('col1', 'col2'), exclude_columns=(), missing_policy='raise', dtype=Float32)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [1.0, 2.0, 3.0, 4.0, 5.0],\n...         \"col3\": [1.0, 2.0, 3.0, 4.0, 5.0],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     },\n...     schema={\n...         \"col1\": pl.Int64,\n...         \"col2\": pl.Decimal,\n...         \"col3\": pl.Decimal,\n...         \"col4\": pl.String,\n...     },\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2         \u2506 col3         \u2506 col4 \u2502\n\u2502 ---  \u2506 ---          \u2506 ---          \u2506 ---  \u2502\n\u2502 i64  \u2506 decimal[*,0] \u2506 decimal[*,0] \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1            \u2506 1            \u2506 a    \u2502\n\u2502 2    \u2506 2            \u2506 2            \u2506 b    \u2502\n\u2502 3    \u2506 3            \u2506 3            \u2506 c    \u2502\n\u2502 4    \u2506 4            \u2506 4            \u2506 d    \u2502\n\u2502 5    \u2506 5            \u2506 5            \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3         \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---          \u2506 ---  \u2502\n\u2502 i64  \u2506 f32  \u2506 decimal[*,0] \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.0  \u2506 1            \u2506 a    \u2502\n\u2502 2    \u2506 2.0  \u2506 2            \u2506 b    \u2502\n\u2502 3    \u2506 3.0  \u2506 3            \u2506 c    \u2502\n\u2502 4    \u2506 4.0  \u2506 4            \u2506 d    \u2502\n\u2502 5    \u2506 5.0  \u2506 5            \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.DecimalCastTransformer","title":"grizz.transformer.DecimalCastTransformer","text":"<p>               Bases: <code>CastTransformer</code></p> <p>Implement a transformer to convert columns of type decimal to a new data type.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to convert. <code>None</code> means all the columns.</p> required <code>dtype</code> <code>type[DataType]</code> <p>The target data type.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>cast</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import DecimalCast\n&gt;&gt;&gt; transformer = DecimalCast(columns=[\"col1\", \"col2\"], dtype=pl.Float32)\n&gt;&gt;&gt; transformer\nDecimalCastTransformer(columns=('col1', 'col2'), exclude_columns=(), missing_policy='raise', dtype=Float32)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [1.0, 2.0, 3.0, 4.0, 5.0],\n...         \"col3\": [1.0, 2.0, 3.0, 4.0, 5.0],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     },\n...     schema={\n...         \"col1\": pl.Int64,\n...         \"col2\": pl.Decimal,\n...         \"col3\": pl.Decimal,\n...         \"col4\": pl.String,\n...     },\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2         \u2506 col3         \u2506 col4 \u2502\n\u2502 ---  \u2506 ---          \u2506 ---          \u2506 ---  \u2502\n\u2502 i64  \u2506 decimal[*,0] \u2506 decimal[*,0] \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1            \u2506 1            \u2506 a    \u2502\n\u2502 2    \u2506 2            \u2506 2            \u2506 b    \u2502\n\u2502 3    \u2506 3            \u2506 3            \u2506 c    \u2502\n\u2502 4    \u2506 4            \u2506 4            \u2506 d    \u2502\n\u2502 5    \u2506 5            \u2506 5            \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3         \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---          \u2506 ---  \u2502\n\u2502 i64  \u2506 f32  \u2506 decimal[*,0] \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.0  \u2506 1            \u2506 a    \u2502\n\u2502 2    \u2506 2.0  \u2506 2            \u2506 b    \u2502\n\u2502 3    \u2506 3.0  \u2506 3            \u2506 c    \u2502\n\u2502 4    \u2506 4.0  \u2506 4            \u2506 d    \u2502\n\u2502 5    \u2506 5.0  \u2506 5            \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.Diff","title":"grizz.transformer.Diff","text":"<p>               Bases: <code>BaseIn1Out1Transformer</code></p> <p>Implement a transformer to compute the first discrete difference between shifted items.</p> <p>Parameters:</p> Name Type Description Default <code>in_col</code> <code>str</code> <p>The input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>shift</code> <code>int</code> <p>The number of slots to shift.</p> <code>1</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Diff\n&gt;&gt;&gt; transformer = Diff(in_col=\"col1\", out_col=\"diff\")\n&gt;&gt;&gt; transformer\nDiffTransformer(in_col='col1', out_col='diff', exist_policy='raise', missing_policy='raise', shift=1)\n&gt;&gt;&gt; frame = pl.DataFrame({\"col1\": [1, 2, 3, 4, 5], \"col2\": [\"a\", \"b\", \"c\", \"d\", \"e\"]})\n&gt;&gt;&gt; frame\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2502\n\u2502 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 a    \u2502\n\u2502 2    \u2506 b    \u2502\n\u2502 3    \u2506 c    \u2502\n\u2502 4    \u2506 d    \u2502\n\u2502 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 diff \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 a    \u2506 null \u2502\n\u2502 2    \u2506 b    \u2506 1    \u2502\n\u2502 3    \u2506 c    \u2506 1    \u2502\n\u2502 4    \u2506 d    \u2506 1    \u2502\n\u2502 5    \u2506 e    \u2506 1    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.DiffHorizontal","title":"grizz.transformer.DiffHorizontal","text":"<p>               Bases: <code>BaseIn2Out1Transformer</code></p> <p>Implement a transformer to compute the difference between two columns.</p> <p>Internally, this tranformer computes: <code>out = in1 - in2</code></p> <p>Parameters:</p> Name Type Description Default <code>in1_col</code> <code>str</code> <p>The first input column name.</p> required <code>in2_col</code> <code>str</code> <p>The second input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import DiffHorizontal\n&gt;&gt;&gt; transformer = DiffHorizontal(in1_col=\"col1\", in2_col=\"col2\", out_col=\"diff\")\n&gt;&gt;&gt; transformer\nDiffHorizontalTransformer(in1_col='col1', in2_col='col2', out_col='diff', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [5, 4, 3, 2, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 diff \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2506 -4   \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2506 -2   \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506 0    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2506 2    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2506 4    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.DiffHorizontalTransformer","title":"grizz.transformer.DiffHorizontalTransformer","text":"<p>               Bases: <code>BaseIn2Out1Transformer</code></p> <p>Implement a transformer to compute the difference between two columns.</p> <p>Internally, this tranformer computes: <code>out = in1 - in2</code></p> <p>Parameters:</p> Name Type Description Default <code>in1_col</code> <code>str</code> <p>The first input column name.</p> required <code>in2_col</code> <code>str</code> <p>The second input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import DiffHorizontal\n&gt;&gt;&gt; transformer = DiffHorizontal(in1_col=\"col1\", in2_col=\"col2\", out_col=\"diff\")\n&gt;&gt;&gt; transformer\nDiffHorizontalTransformer(in1_col='col1', in2_col='col2', out_col='diff', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [5, 4, 3, 2, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 diff \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5    \u2506 a    \u2506 -4   \u2502\n\u2502 2    \u2506 4    \u2506 b    \u2506 -2   \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506 0    \u2502\n\u2502 4    \u2506 2    \u2506 d    \u2506 2    \u2502\n\u2502 5    \u2506 1    \u2506 e    \u2506 4    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.DiffTransformer","title":"grizz.transformer.DiffTransformer","text":"<p>               Bases: <code>BaseIn1Out1Transformer</code></p> <p>Implement a transformer to compute the first discrete difference between shifted items.</p> <p>Parameters:</p> Name Type Description Default <code>in_col</code> <code>str</code> <p>The input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>shift</code> <code>int</code> <p>The number of slots to shift.</p> <code>1</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Diff\n&gt;&gt;&gt; transformer = Diff(in_col=\"col1\", out_col=\"diff\")\n&gt;&gt;&gt; transformer\nDiffTransformer(in_col='col1', out_col='diff', exist_policy='raise', missing_policy='raise', shift=1)\n&gt;&gt;&gt; frame = pl.DataFrame({\"col1\": [1, 2, 3, 4, 5], \"col2\": [\"a\", \"b\", \"c\", \"d\", \"e\"]})\n&gt;&gt;&gt; frame\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2502\n\u2502 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 a    \u2502\n\u2502 2    \u2506 b    \u2502\n\u2502 3    \u2506 c    \u2502\n\u2502 4    \u2506 d    \u2502\n\u2502 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 diff \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 a    \u2506 null \u2502\n\u2502 2    \u2506 b    \u2506 1    \u2502\n\u2502 3    \u2506 c    \u2506 1    \u2502\n\u2502 4    \u2506 d    \u2506 1    \u2502\n\u2502 5    \u2506 e    \u2506 1    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.DropDuplicate","title":"grizz.transformer.DropDuplicate","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to drop duplicate rows.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to check. If set to <code>None</code> (default), use all columns.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>unique</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import DropDuplicate\n&gt;&gt;&gt; transformer = DropDuplicate(keep=\"first\", maintain_order=True)\n&gt;&gt;&gt; transformer\nDropDuplicateTransformer(columns=None, exclude_columns=(), missing_policy='raise', keep='first', maintain_order=True)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 1],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"1\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"1\", \"1\"],\n...         \"col4\": [\"a\", \"a\", \"a\", \"a\", \"a\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 a    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 a    \u2502\n\u2502 4    \u2506 4    \u2506 1    \u2506 a    \u2502\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (4, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 a    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 a    \u2502\n\u2502 4    \u2506 4    \u2506 1    \u2506 a    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.DropDuplicateTransformer","title":"grizz.transformer.DropDuplicateTransformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to drop duplicate rows.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to check. If set to <code>None</code> (default), use all columns.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>unique</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import DropDuplicate\n&gt;&gt;&gt; transformer = DropDuplicate(keep=\"first\", maintain_order=True)\n&gt;&gt;&gt; transformer\nDropDuplicateTransformer(columns=None, exclude_columns=(), missing_policy='raise', keep='first', maintain_order=True)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 1],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"1\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"1\", \"1\"],\n...         \"col4\": [\"a\", \"a\", \"a\", \"a\", \"a\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 a    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 a    \u2502\n\u2502 4    \u2506 4    \u2506 1    \u2506 a    \u2502\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (4, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 a    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 a    \u2502\n\u2502 4    \u2506 4    \u2506 1    \u2506 a    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.DropNanColumn","title":"grizz.transformer.DropNanColumn","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to remove the columns that have too many NaN values.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to convert. <code>None</code> means all the columns.</p> <code>None</code> <code>threshold</code> <code>float</code> <p>The maximum percentage of NaN values to keep columns. If the proportion of NaN vallues is greater or equal to this threshold value, the column is removed. If set to <code>1.0</code>, it removes all the columns that have only NaN values.</p> <code>1.0</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>drop</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import DropNanColumn\n&gt;&gt;&gt; transformer = DropNanColumn()\n&gt;&gt;&gt; transformer\nDropNanColumnTransformer(columns=None, exclude_columns=(), missing_policy='raise', threshold=1.0)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1.0, 2.0, 3.0, 4.0, float(\"nan\")],\n...         \"col2\": [1.0, float(\"nan\"), 3.0, float(\"nan\"), 5.0],\n...         \"col3\": [float(\"nan\"), float(\"nan\"), float(\"nan\"), float(\"nan\"), float(\"nan\")],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 f64  \u2506 f64  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0  \u2506 1.0  \u2506 NaN  \u2502\n\u2502 2.0  \u2506 NaN  \u2506 NaN  \u2502\n\u2502 3.0  \u2506 3.0  \u2506 NaN  \u2502\n\u2502 4.0  \u2506 NaN  \u2506 NaN  \u2502\n\u2502 NaN  \u2506 5.0  \u2506 NaN  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2502\n\u2502 ---  \u2506 ---  \u2502\n\u2502 f64  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0  \u2506 1.0  \u2502\n\u2502 2.0  \u2506 NaN  \u2502\n\u2502 3.0  \u2506 3.0  \u2502\n\u2502 4.0  \u2506 NaN  \u2502\n\u2502 NaN  \u2506 5.0  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.DropNanColumnTransformer","title":"grizz.transformer.DropNanColumnTransformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to remove the columns that have too many NaN values.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to convert. <code>None</code> means all the columns.</p> <code>None</code> <code>threshold</code> <code>float</code> <p>The maximum percentage of NaN values to keep columns. If the proportion of NaN vallues is greater or equal to this threshold value, the column is removed. If set to <code>1.0</code>, it removes all the columns that have only NaN values.</p> <code>1.0</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>drop</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import DropNanColumn\n&gt;&gt;&gt; transformer = DropNanColumn()\n&gt;&gt;&gt; transformer\nDropNanColumnTransformer(columns=None, exclude_columns=(), missing_policy='raise', threshold=1.0)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1.0, 2.0, 3.0, 4.0, float(\"nan\")],\n...         \"col2\": [1.0, float(\"nan\"), 3.0, float(\"nan\"), 5.0],\n...         \"col3\": [float(\"nan\"), float(\"nan\"), float(\"nan\"), float(\"nan\"), float(\"nan\")],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 f64  \u2506 f64  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0  \u2506 1.0  \u2506 NaN  \u2502\n\u2502 2.0  \u2506 NaN  \u2506 NaN  \u2502\n\u2502 3.0  \u2506 3.0  \u2506 NaN  \u2502\n\u2502 4.0  \u2506 NaN  \u2506 NaN  \u2502\n\u2502 NaN  \u2506 5.0  \u2506 NaN  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2502\n\u2502 ---  \u2506 ---  \u2502\n\u2502 f64  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0  \u2506 1.0  \u2502\n\u2502 2.0  \u2506 NaN  \u2502\n\u2502 3.0  \u2506 3.0  \u2502\n\u2502 4.0  \u2506 NaN  \u2502\n\u2502 NaN  \u2506 5.0  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.DropNanRow","title":"grizz.transformer.DropNanRow","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to drop all rows that contain NaN values.</p> <p>Note that all the values in the row need to be NaN to drop the row.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to check. If set to <code>None</code> (default), use all columns.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import DropNanRow\n&gt;&gt;&gt; transformer = DropNanRow()\n&gt;&gt;&gt; transformer\nDropNanRowTransformer(columns=None, exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1.0, 2.0, 3.0, 4.0, float(\"nan\")],\n...         \"col2\": [1.0, float(\"nan\"), 3.0, float(\"nan\"), float(\"nan\")],\n...         \"col3\": [float(\"nan\"), float(\"nan\"), float(\"nan\"), float(\"nan\"), float(\"nan\")],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 f64  \u2506 f64  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0  \u2506 1.0  \u2506 NaN  \u2502\n\u2502 2.0  \u2506 NaN  \u2506 NaN  \u2502\n\u2502 3.0  \u2506 3.0  \u2506 NaN  \u2502\n\u2502 4.0  \u2506 NaN  \u2506 NaN  \u2502\n\u2502 NaN  \u2506 NaN  \u2506 NaN  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (4, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 f64  \u2506 f64  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0  \u2506 1.0  \u2506 NaN  \u2502\n\u2502 2.0  \u2506 NaN  \u2506 NaN  \u2502\n\u2502 3.0  \u2506 3.0  \u2506 NaN  \u2502\n\u2502 4.0  \u2506 NaN  \u2506 NaN  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.DropNanRowTransformer","title":"grizz.transformer.DropNanRowTransformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to drop all rows that contain NaN values.</p> <p>Note that all the values in the row need to be NaN to drop the row.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to check. If set to <code>None</code> (default), use all columns.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import DropNanRow\n&gt;&gt;&gt; transformer = DropNanRow()\n&gt;&gt;&gt; transformer\nDropNanRowTransformer(columns=None, exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1.0, 2.0, 3.0, 4.0, float(\"nan\")],\n...         \"col2\": [1.0, float(\"nan\"), 3.0, float(\"nan\"), float(\"nan\")],\n...         \"col3\": [float(\"nan\"), float(\"nan\"), float(\"nan\"), float(\"nan\"), float(\"nan\")],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 f64  \u2506 f64  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0  \u2506 1.0  \u2506 NaN  \u2502\n\u2502 2.0  \u2506 NaN  \u2506 NaN  \u2502\n\u2502 3.0  \u2506 3.0  \u2506 NaN  \u2502\n\u2502 4.0  \u2506 NaN  \u2506 NaN  \u2502\n\u2502 NaN  \u2506 NaN  \u2506 NaN  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (4, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 f64  \u2506 f64  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0  \u2506 1.0  \u2506 NaN  \u2502\n\u2502 2.0  \u2506 NaN  \u2506 NaN  \u2502\n\u2502 3.0  \u2506 3.0  \u2506 NaN  \u2502\n\u2502 4.0  \u2506 NaN  \u2506 NaN  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.DropNullColumn","title":"grizz.transformer.DropNullColumn","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to remove the columns that have too many null values.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to convert. <code>None</code> means all the columns.</p> <code>None</code> <code>threshold</code> <code>float</code> <p>The maximum percentage of null values to keep columns. If the proportion of null vallues is greater or equal to this threshold value, the column is removed. If set to <code>1.0</code>, it removes all the columns that have only null values.</p> <code>1.0</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>drop</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import DropNullColumn\n&gt;&gt;&gt; transformer = DropNullColumn()\n&gt;&gt;&gt; transformer\nDropNullColumnTransformer(columns=None, exclude_columns=(), missing_policy='raise', threshold=1.0)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [\"2020-1-1\", \"2020-1-2\", \"2020-1-31\", \"2020-12-31\", None],\n...         \"col2\": [1, None, 3, None, 5],\n...         \"col3\": [None, None, None, None, None],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1       \u2506 col2 \u2506 col3 \u2502\n\u2502 ---        \u2506 ---  \u2506 ---  \u2502\n\u2502 str        \u2506 i64  \u2506 null \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-1-1   \u2506 1    \u2506 null \u2502\n\u2502 2020-1-2   \u2506 null \u2506 null \u2502\n\u2502 2020-1-31  \u2506 3    \u2506 null \u2502\n\u2502 2020-12-31 \u2506 null \u2506 null \u2502\n\u2502 null       \u2506 5    \u2506 null \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1       \u2506 col2 \u2502\n\u2502 ---        \u2506 ---  \u2502\n\u2502 str        \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-1-1   \u2506 1    \u2502\n\u2502 2020-1-2   \u2506 null \u2502\n\u2502 2020-1-31  \u2506 3    \u2502\n\u2502 2020-12-31 \u2506 null \u2502\n\u2502 null       \u2506 5    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.DropNullColumnTransformer","title":"grizz.transformer.DropNullColumnTransformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to remove the columns that have too many null values.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to convert. <code>None</code> means all the columns.</p> <code>None</code> <code>threshold</code> <code>float</code> <p>The maximum percentage of null values to keep columns. If the proportion of null vallues is greater or equal to this threshold value, the column is removed. If set to <code>1.0</code>, it removes all the columns that have only null values.</p> <code>1.0</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>drop</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import DropNullColumn\n&gt;&gt;&gt; transformer = DropNullColumn()\n&gt;&gt;&gt; transformer\nDropNullColumnTransformer(columns=None, exclude_columns=(), missing_policy='raise', threshold=1.0)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [\"2020-1-1\", \"2020-1-2\", \"2020-1-31\", \"2020-12-31\", None],\n...         \"col2\": [1, None, 3, None, 5],\n...         \"col3\": [None, None, None, None, None],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1       \u2506 col2 \u2506 col3 \u2502\n\u2502 ---        \u2506 ---  \u2506 ---  \u2502\n\u2502 str        \u2506 i64  \u2506 null \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-1-1   \u2506 1    \u2506 null \u2502\n\u2502 2020-1-2   \u2506 null \u2506 null \u2502\n\u2502 2020-1-31  \u2506 3    \u2506 null \u2502\n\u2502 2020-12-31 \u2506 null \u2506 null \u2502\n\u2502 null       \u2506 5    \u2506 null \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1       \u2506 col2 \u2502\n\u2502 ---        \u2506 ---  \u2502\n\u2502 str        \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-1-1   \u2506 1    \u2502\n\u2502 2020-1-2   \u2506 null \u2502\n\u2502 2020-1-31  \u2506 3    \u2502\n\u2502 2020-12-31 \u2506 null \u2502\n\u2502 null       \u2506 5    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.DropNullRow","title":"grizz.transformer.DropNullRow","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to drop all rows that contain null values.</p> <p>Note that all the values in the row need to be null to drop the row.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to check. If set to <code>None</code> (default), use all columns.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import DropNullRow\n&gt;&gt;&gt; transformer = DropNullRow()\n&gt;&gt;&gt; transformer\nDropNullRowTransformer(columns=None, exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [\"2020-1-1\", \"2020-1-2\", \"2020-1-31\", \"2020-12-31\", None],\n...         \"col2\": [1, None, 3, None, None],\n...         \"col3\": [None, None, None, None, None],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1       \u2506 col2 \u2506 col3 \u2502\n\u2502 ---        \u2506 ---  \u2506 ---  \u2502\n\u2502 str        \u2506 i64  \u2506 null \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-1-1   \u2506 1    \u2506 null \u2502\n\u2502 2020-1-2   \u2506 null \u2506 null \u2502\n\u2502 2020-1-31  \u2506 3    \u2506 null \u2502\n\u2502 2020-12-31 \u2506 null \u2506 null \u2502\n\u2502 null       \u2506 null \u2506 null \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (4, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1       \u2506 col2 \u2506 col3 \u2502\n\u2502 ---        \u2506 ---  \u2506 ---  \u2502\n\u2502 str        \u2506 i64  \u2506 null \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-1-1   \u2506 1    \u2506 null \u2502\n\u2502 2020-1-2   \u2506 null \u2506 null \u2502\n\u2502 2020-1-31  \u2506 3    \u2506 null \u2502\n\u2502 2020-12-31 \u2506 null \u2506 null \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.DropNullRowTransformer","title":"grizz.transformer.DropNullRowTransformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to drop all rows that contain null values.</p> <p>Note that all the values in the row need to be null to drop the row.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to check. If set to <code>None</code> (default), use all columns.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import DropNullRow\n&gt;&gt;&gt; transformer = DropNullRow()\n&gt;&gt;&gt; transformer\nDropNullRowTransformer(columns=None, exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [\"2020-1-1\", \"2020-1-2\", \"2020-1-31\", \"2020-12-31\", None],\n...         \"col2\": [1, None, 3, None, None],\n...         \"col3\": [None, None, None, None, None],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1       \u2506 col2 \u2506 col3 \u2502\n\u2502 ---        \u2506 ---  \u2506 ---  \u2502\n\u2502 str        \u2506 i64  \u2506 null \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-1-1   \u2506 1    \u2506 null \u2502\n\u2502 2020-1-2   \u2506 null \u2506 null \u2502\n\u2502 2020-1-31  \u2506 3    \u2506 null \u2502\n\u2502 2020-12-31 \u2506 null \u2506 null \u2502\n\u2502 null       \u2506 null \u2506 null \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (4, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1       \u2506 col2 \u2506 col3 \u2502\n\u2502 ---        \u2506 ---  \u2506 ---  \u2502\n\u2502 str        \u2506 i64  \u2506 null \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-1-1   \u2506 1    \u2506 null \u2502\n\u2502 2020-1-2   \u2506 null \u2506 null \u2502\n\u2502 2020-1-31  \u2506 3    \u2506 null \u2502\n\u2502 2020-12-31 \u2506 null \u2506 null \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.Equal","title":"grizz.transformer.Equal","text":"<p>               Bases: <code>BaseComparatorTransformer</code></p> <p>Implements a transformer that computes the equal operation.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to compare. <code>None</code> means all the columns.</p> required <code>target</code> <code>Any</code> <p>The target value to compare with.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the output columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the output columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Equal\n&gt;&gt;&gt; transformer = Equal(columns=[\"col1\", \"col3\"], target=3, prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nEqualTransformer(columns=('col1', 'col3'), target=3, prefix='', suffix='_out', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [10, 20, 30, 40, 50],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out \u2506 col3_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2506 bool     \u2506 bool     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2506 false    \u2506 false    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2506 false    \u2506 false    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2506 true     \u2506 false    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2506 false    \u2506 false    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2506 false    \u2506 false    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.EqualMissing","title":"grizz.transformer.EqualMissing","text":"<p>               Bases: <code>BaseComparatorTransformer</code></p> <p>Implements a transformer that computes the equal operation where null values are not propagated.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to compare. <code>None</code> means all the columns.</p> required <code>target</code> <code>Any</code> <p>The target value to compare with.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the output columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the output columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import EqualMissing\n&gt;&gt;&gt; transformer = EqualMissing(columns=[\"col1\", \"col3\"], target=3, prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nEqualMissingTransformer(columns=('col1', 'col3'), target=3, prefix='', suffix='_out', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [10, 20, 30, 40, 50],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out \u2506 col3_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2506 bool     \u2506 bool     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2506 false    \u2506 false    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2506 false    \u2506 false    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2506 true     \u2506 false    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2506 false    \u2506 false    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2506 false    \u2506 false    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.EqualMissingTransformer","title":"grizz.transformer.EqualMissingTransformer","text":"<p>               Bases: <code>BaseComparatorTransformer</code></p> <p>Implements a transformer that computes the equal operation where null values are not propagated.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to compare. <code>None</code> means all the columns.</p> required <code>target</code> <code>Any</code> <p>The target value to compare with.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the output columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the output columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import EqualMissing\n&gt;&gt;&gt; transformer = EqualMissing(columns=[\"col1\", \"col3\"], target=3, prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nEqualMissingTransformer(columns=('col1', 'col3'), target=3, prefix='', suffix='_out', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [10, 20, 30, 40, 50],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out \u2506 col3_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2506 bool     \u2506 bool     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2506 false    \u2506 false    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2506 false    \u2506 false    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2506 true     \u2506 false    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2506 false    \u2506 false    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2506 false    \u2506 false    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.EqualTransformer","title":"grizz.transformer.EqualTransformer","text":"<p>               Bases: <code>BaseComparatorTransformer</code></p> <p>Implements a transformer that computes the equal operation.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to compare. <code>None</code> means all the columns.</p> required <code>target</code> <code>Any</code> <p>The target value to compare with.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the output columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the output columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Equal\n&gt;&gt;&gt; transformer = Equal(columns=[\"col1\", \"col3\"], target=3, prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nEqualTransformer(columns=('col1', 'col3'), target=3, prefix='', suffix='_out', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [10, 20, 30, 40, 50],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out \u2506 col3_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2506 bool     \u2506 bool     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2506 false    \u2506 false    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2506 false    \u2506 false    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2506 true     \u2506 false    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2506 false    \u2506 false    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2506 false    \u2506 false    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.FillNan","title":"grizz.transformer.FillNan","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to fill NaN values.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to prepare. If <code>None</code>, it processes all the columns of type string.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>fill_nan</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import FillNan\n&gt;&gt;&gt; transformer = FillNan(columns=[\"col1\", \"col4\"], value=100)\n&gt;&gt;&gt; transformer\nFillNanTransformer(columns=('col1', 'col4'), exclude_columns=(), missing_policy='raise', value=100)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, None],\n...         \"col2\": [1.2, 2.2, 3.2, 4.2, float(\"nan\")],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", None],\n...         \"col4\": [1.2, float(\"nan\"), 3.2, None, 5.2],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 f64  \u2506 str  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.2  \u2506 a    \u2506 1.2  \u2502\n\u2502 2    \u2506 2.2  \u2506 b    \u2506 NaN  \u2502\n\u2502 3    \u2506 3.2  \u2506 c    \u2506 3.2  \u2502\n\u2502 4    \u2506 4.2  \u2506 d    \u2506 null \u2502\n\u2502 null \u2506 NaN  \u2506 null \u2506 5.2  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 f64  \u2506 str  \u2506 f64   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.2  \u2506 a    \u2506 1.2   \u2502\n\u2502 2    \u2506 2.2  \u2506 b    \u2506 100.0 \u2502\n\u2502 3    \u2506 3.2  \u2506 c    \u2506 3.2   \u2502\n\u2502 4    \u2506 4.2  \u2506 d    \u2506 null  \u2502\n\u2502 null \u2506 NaN  \u2506 null \u2506 5.2   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.FillNanTransformer","title":"grizz.transformer.FillNanTransformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to fill NaN values.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to prepare. If <code>None</code>, it processes all the columns of type string.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>fill_nan</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import FillNan\n&gt;&gt;&gt; transformer = FillNan(columns=[\"col1\", \"col4\"], value=100)\n&gt;&gt;&gt; transformer\nFillNanTransformer(columns=('col1', 'col4'), exclude_columns=(), missing_policy='raise', value=100)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, None],\n...         \"col2\": [1.2, 2.2, 3.2, 4.2, float(\"nan\")],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", None],\n...         \"col4\": [1.2, float(\"nan\"), 3.2, None, 5.2],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 f64  \u2506 str  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.2  \u2506 a    \u2506 1.2  \u2502\n\u2502 2    \u2506 2.2  \u2506 b    \u2506 NaN  \u2502\n\u2502 3    \u2506 3.2  \u2506 c    \u2506 3.2  \u2502\n\u2502 4    \u2506 4.2  \u2506 d    \u2506 null \u2502\n\u2502 null \u2506 NaN  \u2506 null \u2506 5.2  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 f64  \u2506 str  \u2506 f64   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.2  \u2506 a    \u2506 1.2   \u2502\n\u2502 2    \u2506 2.2  \u2506 b    \u2506 100.0 \u2502\n\u2502 3    \u2506 3.2  \u2506 c    \u2506 3.2   \u2502\n\u2502 4    \u2506 4.2  \u2506 d    \u2506 null  \u2502\n\u2502 null \u2506 NaN  \u2506 null \u2506 5.2   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.FillNull","title":"grizz.transformer.FillNull","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to fill null values.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to prepare. If <code>None</code>, it processes all the columns of type string.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>fill_null</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import FillNull\n&gt;&gt;&gt; transformer = FillNull(columns=[\"col1\", \"col4\"], value=100)\n&gt;&gt;&gt; transformer\nFillNullTransformer(columns=('col1', 'col4'), exclude_columns=(), missing_policy='raise', value=100)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, None],\n...         \"col2\": [1.2, 2.2, 3.2, 4.2, None],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", None],\n...         \"col4\": [1.2, float(\"nan\"), 3.2, None, 5.2],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 f64  \u2506 str  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.2  \u2506 a    \u2506 1.2  \u2502\n\u2502 2    \u2506 2.2  \u2506 b    \u2506 NaN  \u2502\n\u2502 3    \u2506 3.2  \u2506 c    \u2506 3.2  \u2502\n\u2502 4    \u2506 4.2  \u2506 d    \u2506 null \u2502\n\u2502 null \u2506 null \u2506 null \u2506 5.2  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 f64  \u2506 str  \u2506 f64   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.2  \u2506 a    \u2506 1.2   \u2502\n\u2502 2    \u2506 2.2  \u2506 b    \u2506 NaN   \u2502\n\u2502 3    \u2506 3.2  \u2506 c    \u2506 3.2   \u2502\n\u2502 4    \u2506 4.2  \u2506 d    \u2506 100.0 \u2502\n\u2502 100  \u2506 null \u2506 null \u2506 5.2   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.FillNullTransformer","title":"grizz.transformer.FillNullTransformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to fill null values.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to prepare. If <code>None</code>, it processes all the columns of type string.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>fill_null</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import FillNull\n&gt;&gt;&gt; transformer = FillNull(columns=[\"col1\", \"col4\"], value=100)\n&gt;&gt;&gt; transformer\nFillNullTransformer(columns=('col1', 'col4'), exclude_columns=(), missing_policy='raise', value=100)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, None],\n...         \"col2\": [1.2, 2.2, 3.2, 4.2, None],\n...         \"col3\": [\"a\", \"b\", \"c\", \"d\", None],\n...         \"col4\": [1.2, float(\"nan\"), 3.2, None, 5.2],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 f64  \u2506 str  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.2  \u2506 a    \u2506 1.2  \u2502\n\u2502 2    \u2506 2.2  \u2506 b    \u2506 NaN  \u2502\n\u2502 3    \u2506 3.2  \u2506 c    \u2506 3.2  \u2502\n\u2502 4    \u2506 4.2  \u2506 d    \u2506 null \u2502\n\u2502 null \u2506 null \u2506 null \u2506 5.2  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 f64  \u2506 str  \u2506 f64   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.2  \u2506 a    \u2506 1.2   \u2502\n\u2502 2    \u2506 2.2  \u2506 b    \u2506 NaN   \u2502\n\u2502 3    \u2506 3.2  \u2506 c    \u2506 3.2   \u2502\n\u2502 4    \u2506 4.2  \u2506 d    \u2506 100.0 \u2502\n\u2502 100  \u2506 null \u2506 null \u2506 5.2   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.FilterCardinality","title":"grizz.transformer.FilterCardinality","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to filter based on the cardinality (i.e. number of unique values) in each column.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to use to filter based on the number of unique values. If <code>None</code>, it processes all the columns of type string.</p> <code>None</code> <code>n_min</code> <code>int</code> <p>The minimal cardinality (included).</p> <code>0</code> <code>n_max</code> <code>int</code> <p>The maximal cardinality (excluded).</p> <code>float('inf')</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import FilterCardinality\n&gt;&gt;&gt; transformer = FilterCardinality(columns=[\"col1\", \"col2\", \"col3\"], n_min=2, n_max=5)\n&gt;&gt;&gt; transformer\nFilterCardinalityTransformer(columns=('col1', 'col2', 'col3'), exclude_columns=(), missing_policy='raise', n_min=2, n_max=5)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [1, 1, 1, 1, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"a\", \"b\"],\n...         \"col4\": [1.2, float(\"nan\"), 3.2, None, 5.2],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 a    \u2506 1.2  \u2502\n\u2502 2    \u2506 1    \u2506 b    \u2506 NaN  \u2502\n\u2502 3    \u2506 1    \u2506 c    \u2506 3.2  \u2502\n\u2502 4    \u2506 1    \u2506 a    \u2506 null \u2502\n\u2502 5    \u2506 1    \u2506 b    \u2506 5.2  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2502\n\u2502 str  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a    \u2506 1.2  \u2502\n\u2502 b    \u2506 NaN  \u2502\n\u2502 c    \u2506 3.2  \u2502\n\u2502 a    \u2506 null \u2502\n\u2502 b    \u2506 5.2  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.FilterCardinalityTransformer","title":"grizz.transformer.FilterCardinalityTransformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to filter based on the cardinality (i.e. number of unique values) in each column.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to use to filter based on the number of unique values. If <code>None</code>, it processes all the columns of type string.</p> <code>None</code> <code>n_min</code> <code>int</code> <p>The minimal cardinality (included).</p> <code>0</code> <code>n_max</code> <code>int</code> <p>The maximal cardinality (excluded).</p> <code>float('inf')</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import FilterCardinality\n&gt;&gt;&gt; transformer = FilterCardinality(columns=[\"col1\", \"col2\", \"col3\"], n_min=2, n_max=5)\n&gt;&gt;&gt; transformer\nFilterCardinalityTransformer(columns=('col1', 'col2', 'col3'), exclude_columns=(), missing_policy='raise', n_min=2, n_max=5)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [1, 1, 1, 1, 1],\n...         \"col3\": [\"a\", \"b\", \"c\", \"a\", \"b\"],\n...         \"col4\": [1.2, float(\"nan\"), 3.2, None, 5.2],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 str  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 a    \u2506 1.2  \u2502\n\u2502 2    \u2506 1    \u2506 b    \u2506 NaN  \u2502\n\u2502 3    \u2506 1    \u2506 c    \u2506 3.2  \u2502\n\u2502 4    \u2506 1    \u2506 a    \u2506 null \u2502\n\u2502 5    \u2506 1    \u2506 b    \u2506 5.2  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2502\n\u2502 str  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a    \u2506 1.2  \u2502\n\u2502 b    \u2506 NaN  \u2502\n\u2502 c    \u2506 3.2  \u2502\n\u2502 a    \u2506 null \u2502\n\u2502 b    \u2506 5.2  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.FirstRow","title":"grizz.transformer.FirstRow","text":"<p>               Bases: <code>BaseArgTransformer</code></p> <p>Implement a transformer that select the first <code>n</code> rows.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import FirstRow\n&gt;&gt;&gt; transformer = FirstRow(n=3)\n&gt;&gt;&gt; transformer\nFirstRowTransformer(n=3)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (3, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.FirstRowTransformer","title":"grizz.transformer.FirstRowTransformer","text":"<p>               Bases: <code>BaseArgTransformer</code></p> <p>Implement a transformer that select the first <code>n</code> rows.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import FirstRow\n&gt;&gt;&gt; transformer = FirstRow(n=3)\n&gt;&gt;&gt; transformer\nFirstRowTransformer(n=3)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (3, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.FloatCast","title":"grizz.transformer.FloatCast","text":"<p>               Bases: <code>CastTransformer</code></p> <p>Implement a transformer to convert columns of type float to a new data type.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to convert. <code>None</code> means all the columns.</p> required <code>dtype</code> <code>type[DataType]</code> <p>The target data type.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>cast</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import FloatCast\n&gt;&gt;&gt; transformer = FloatCast(columns=[\"col1\", \"col2\"], dtype=pl.Int32)\n&gt;&gt;&gt; transformer\nFloatCastTransformer(columns=('col1', 'col2'), exclude_columns=(), missing_policy='raise', dtype=Int32)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [1.0, 2.0, 3.0, 4.0, 5.0],\n...         \"col3\": [1.0, 2.0, 3.0, 4.0, 5.0],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     },\n...     schema={\n...         \"col1\": pl.Int64,\n...         \"col2\": pl.Float64,\n...         \"col3\": pl.Float64,\n...         \"col4\": pl.String,\n...     },\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 f64  \u2506 f64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.0  \u2506 1.0  \u2506 a    \u2502\n\u2502 2    \u2506 2.0  \u2506 2.0  \u2506 b    \u2502\n\u2502 3    \u2506 3.0  \u2506 3.0  \u2506 c    \u2502\n\u2502 4    \u2506 4.0  \u2506 4.0  \u2506 d    \u2502\n\u2502 5    \u2506 5.0  \u2506 5.0  \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i32  \u2506 f64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1.0  \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2.0  \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3.0  \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4.0  \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5.0  \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.FloatCastTransformer","title":"grizz.transformer.FloatCastTransformer","text":"<p>               Bases: <code>CastTransformer</code></p> <p>Implement a transformer to convert columns of type float to a new data type.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to convert. <code>None</code> means all the columns.</p> required <code>dtype</code> <code>type[DataType]</code> <p>The target data type.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>cast</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import FloatCast\n&gt;&gt;&gt; transformer = FloatCast(columns=[\"col1\", \"col2\"], dtype=pl.Int32)\n&gt;&gt;&gt; transformer\nFloatCastTransformer(columns=('col1', 'col2'), exclude_columns=(), missing_policy='raise', dtype=Int32)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [1.0, 2.0, 3.0, 4.0, 5.0],\n...         \"col3\": [1.0, 2.0, 3.0, 4.0, 5.0],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     },\n...     schema={\n...         \"col1\": pl.Int64,\n...         \"col2\": pl.Float64,\n...         \"col3\": pl.Float64,\n...         \"col4\": pl.String,\n...     },\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 f64  \u2506 f64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.0  \u2506 1.0  \u2506 a    \u2502\n\u2502 2    \u2506 2.0  \u2506 2.0  \u2506 b    \u2502\n\u2502 3    \u2506 3.0  \u2506 3.0  \u2506 c    \u2502\n\u2502 4    \u2506 4.0  \u2506 4.0  \u2506 d    \u2502\n\u2502 5    \u2506 5.0  \u2506 5.0  \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i32  \u2506 f64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1.0  \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2.0  \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3.0  \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4.0  \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5.0  \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.Function","title":"grizz.transformer.Function","text":"<p>               Bases: <code>BaseArgTransformer</code></p> <p>Implement a transformer that is a wrapper around a function to transform the DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[DataFrame], DataFrame]</code> <p>The function to transform the DataFrame.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import FunctionTransformer\n&gt;&gt;&gt; transformer = FunctionTransformer(\n...     func=lambda frame: frame.filter(pl.col(\"col1\").is_in({2, 4}))\n... )\n&gt;&gt;&gt; transformer\nFunctionTransformer(func=&lt;function &lt;lambda&gt; at 0x...&gt;)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (2, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.FunctionTransformer","title":"grizz.transformer.FunctionTransformer","text":"<p>               Bases: <code>BaseArgTransformer</code></p> <p>Implement a transformer that is a wrapper around a function to transform the DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[DataFrame], DataFrame]</code> <p>The function to transform the DataFrame.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import FunctionTransformer\n&gt;&gt;&gt; transformer = FunctionTransformer(\n...     func=lambda frame: frame.filter(pl.col(\"col1\").is_in({2, 4}))\n... )\n&gt;&gt;&gt; transformer\nFunctionTransformer(func=&lt;function &lt;lambda&gt; at 0x...&gt;)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (2, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.Greater","title":"grizz.transformer.Greater","text":"<p>               Bases: <code>BaseComparatorTransformer</code></p> <p>Implements a transformer that computes the greater than operation.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to compare. <code>None</code> means all the columns.</p> required <code>target</code> <code>Any</code> <p>The target value to compare with.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the output columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the output columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Greater\n&gt;&gt;&gt; transformer = Greater(columns=[\"col1\", \"col3\"], target=4.2, prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nGreaterTransformer(columns=('col1', 'col3'), target=4.2, prefix='', suffix='_out', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [10, 20, 30, 40, 50],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out \u2506 col3_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2506 bool     \u2506 bool     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2506 false    \u2506 true     \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2506 false    \u2506 true     \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2506 false    \u2506 true     \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2506 false    \u2506 true     \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2506 true     \u2506 true     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.GreaterEqual","title":"grizz.transformer.GreaterEqual","text":"<p>               Bases: <code>BaseComparatorTransformer</code></p> <p>Implements a transformer that computes the greater than or equal operation.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to compare. <code>None</code> means all the columns.</p> required <code>target</code> <code>Any</code> <p>The target value to compare with.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the output columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the output columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import GreaterEqual\n&gt;&gt;&gt; transformer = GreaterEqual(\n...     columns=[\"col1\", \"col3\"], target=4.2, prefix=\"\", suffix=\"_out\"\n... )\n&gt;&gt;&gt; transformer\nGreaterEqualTransformer(columns=('col1', 'col3'), target=4.2, prefix='', suffix='_out', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [10, 20, 30, 40, 50],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out \u2506 col3_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2506 bool     \u2506 bool     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2506 false    \u2506 true     \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2506 false    \u2506 true     \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2506 false    \u2506 true     \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2506 false    \u2506 true     \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2506 true     \u2506 true     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.GreaterEqualTransformer","title":"grizz.transformer.GreaterEqualTransformer","text":"<p>               Bases: <code>BaseComparatorTransformer</code></p> <p>Implements a transformer that computes the greater than or equal operation.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to compare. <code>None</code> means all the columns.</p> required <code>target</code> <code>Any</code> <p>The target value to compare with.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the output columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the output columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import GreaterEqual\n&gt;&gt;&gt; transformer = GreaterEqual(\n...     columns=[\"col1\", \"col3\"], target=4.2, prefix=\"\", suffix=\"_out\"\n... )\n&gt;&gt;&gt; transformer\nGreaterEqualTransformer(columns=('col1', 'col3'), target=4.2, prefix='', suffix='_out', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [10, 20, 30, 40, 50],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out \u2506 col3_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2506 bool     \u2506 bool     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2506 false    \u2506 true     \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2506 false    \u2506 true     \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2506 false    \u2506 true     \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2506 false    \u2506 true     \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2506 true     \u2506 true     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.GreaterTransformer","title":"grizz.transformer.GreaterTransformer","text":"<p>               Bases: <code>BaseComparatorTransformer</code></p> <p>Implements a transformer that computes the greater than operation.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to compare. <code>None</code> means all the columns.</p> required <code>target</code> <code>Any</code> <p>The target value to compare with.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the output columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the output columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Greater\n&gt;&gt;&gt; transformer = Greater(columns=[\"col1\", \"col3\"], target=4.2, prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nGreaterTransformer(columns=('col1', 'col3'), target=4.2, prefix='', suffix='_out', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [10, 20, 30, 40, 50],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out \u2506 col3_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2506 bool     \u2506 bool     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2506 false    \u2506 true     \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2506 false    \u2506 true     \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2506 false    \u2506 true     \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2506 false    \u2506 true     \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2506 true     \u2506 true     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.IntegerCast","title":"grizz.transformer.IntegerCast","text":"<p>               Bases: <code>CastTransformer</code></p> <p>Implement a transformer to convert columns of type integer to a new data type.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to convert. <code>None</code> means all the columns.</p> required <code>dtype</code> <code>type[DataType]</code> <p>The target data type.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>cast</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import IntegerCast\n&gt;&gt;&gt; transformer = IntegerCast(columns=[\"col1\", \"col2\"], dtype=pl.Float32)\n&gt;&gt;&gt; transformer\nIntegerCastTransformer(columns=('col1', 'col2'), exclude_columns=(), missing_policy='raise', dtype=Float32)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [1.0, 2.0, 3.0, 4.0, 5.0],\n...         \"col3\": [1, 2, 3, 4, 5],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     },\n...     schema={\n...         \"col1\": pl.Int64,\n...         \"col2\": pl.Float64,\n...         \"col3\": pl.Int64,\n...         \"col4\": pl.String,\n...     },\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 f64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.0  \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2.0  \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3.0  \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4.0  \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5.0  \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 f32  \u2506 f64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0  \u2506 1.0  \u2506 1    \u2506 a    \u2502\n\u2502 2.0  \u2506 2.0  \u2506 2    \u2506 b    \u2502\n\u2502 3.0  \u2506 3.0  \u2506 3    \u2506 c    \u2502\n\u2502 4.0  \u2506 4.0  \u2506 4    \u2506 d    \u2502\n\u2502 5.0  \u2506 5.0  \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.IntegerCastTransformer","title":"grizz.transformer.IntegerCastTransformer","text":"<p>               Bases: <code>CastTransformer</code></p> <p>Implement a transformer to convert columns of type integer to a new data type.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to convert. <code>None</code> means all the columns.</p> required <code>dtype</code> <code>type[DataType]</code> <p>The target data type.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>cast</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import IntegerCast\n&gt;&gt;&gt; transformer = IntegerCast(columns=[\"col1\", \"col2\"], dtype=pl.Float32)\n&gt;&gt;&gt; transformer\nIntegerCastTransformer(columns=('col1', 'col2'), exclude_columns=(), missing_policy='raise', dtype=Float32)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [1.0, 2.0, 3.0, 4.0, 5.0],\n...         \"col3\": [1, 2, 3, 4, 5],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     },\n...     schema={\n...         \"col1\": pl.Int64,\n...         \"col2\": pl.Float64,\n...         \"col3\": pl.Int64,\n...         \"col4\": pl.String,\n...     },\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 f64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.0  \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2.0  \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3.0  \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4.0  \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5.0  \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 f32  \u2506 f64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0  \u2506 1.0  \u2506 1    \u2506 a    \u2502\n\u2502 2.0  \u2506 2.0  \u2506 2    \u2506 b    \u2502\n\u2502 3.0  \u2506 3.0  \u2506 3    \u2506 c    \u2502\n\u2502 4.0  \u2506 4.0  \u2506 4    \u2506 d    \u2502\n\u2502 5.0  \u2506 5.0  \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.JsonDecode","title":"grizz.transformer.JsonDecode","text":"<p>               Bases: <code>BaseInNOutNTransformer</code></p> <p>Implement a transformer to parse string values as JSON.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to parse. <code>None</code> means all the columns.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the copied columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the copied columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>dtype</code> <p>The dtype to cast the extracted value to. If <code>None</code>, the dtype will be inferred from the JSON value.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import JsonDecode\n&gt;&gt;&gt; transformer = JsonDecode(columns=[\"col1\", \"col3\"], prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nJsonDecodeTransformer(columns=('col1', 'col3'), exclude_columns=(), exist_policy='raise', missing_policy='raise', prefix='', suffix='_out')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [\"[1, 2]\", \"[2]\", \"[1, 2, 3]\", \"[4, 5]\", \"[5, 4]\"],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"['1', '2']\", \"['2']\", \"['1', '2', '3']\", \"['4', '5']\", \"['5', '4']\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1      \u2506 col2 \u2506 col3            \u2506 col4 \u2502\n\u2502 ---       \u2506 ---  \u2506 ---             \u2506 ---  \u2502\n\u2502 str       \u2506 str  \u2506 str             \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 [1, 2]    \u2506 1    \u2506 ['1', '2']      \u2506 a    \u2502\n\u2502 [2]       \u2506 2    \u2506 ['2']           \u2506 b    \u2502\n\u2502 [1, 2, 3] \u2506 3    \u2506 ['1', '2', '3'] \u2506 c    \u2502\n\u2502 [4, 5]    \u2506 4    \u2506 ['4', '5']      \u2506 d    \u2502\n\u2502 [5, 4]    \u2506 5    \u2506 ['5', '4']      \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1      \u2506 col2 \u2506 col3            \u2506 col4 \u2506 col1_out  \u2506 col3_out        \u2502\n\u2502 ---       \u2506 ---  \u2506 ---             \u2506 ---  \u2506 ---       \u2506 ---             \u2502\n\u2502 str       \u2506 str  \u2506 str             \u2506 str  \u2506 list[i64] \u2506 list[str]       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 [1, 2]    \u2506 1    \u2506 ['1', '2']      \u2506 a    \u2506 [1, 2]    \u2506 [\"1\", \"2\"]      \u2502\n\u2502 [2]       \u2506 2    \u2506 ['2']           \u2506 b    \u2506 [2]       \u2506 [\"2\"]           \u2502\n\u2502 [1, 2, 3] \u2506 3    \u2506 ['1', '2', '3'] \u2506 c    \u2506 [1, 2, 3] \u2506 [\"1\", \"2\", \"3\"] \u2502\n\u2502 [4, 5]    \u2506 4    \u2506 ['4', '5']      \u2506 d    \u2506 [4, 5]    \u2506 [\"4\", \"5\"]      \u2502\n\u2502 [5, 4]    \u2506 5    \u2506 ['5', '4']      \u2506 e    \u2506 [5, 4]    \u2506 [\"5\", \"4\"]      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.JsonDecodeTransformer","title":"grizz.transformer.JsonDecodeTransformer","text":"<p>               Bases: <code>BaseInNOutNTransformer</code></p> <p>Implement a transformer to parse string values as JSON.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to parse. <code>None</code> means all the columns.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the copied columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the copied columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>dtype</code> <p>The dtype to cast the extracted value to. If <code>None</code>, the dtype will be inferred from the JSON value.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import JsonDecode\n&gt;&gt;&gt; transformer = JsonDecode(columns=[\"col1\", \"col3\"], prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nJsonDecodeTransformer(columns=('col1', 'col3'), exclude_columns=(), exist_policy='raise', missing_policy='raise', prefix='', suffix='_out')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [\"[1, 2]\", \"[2]\", \"[1, 2, 3]\", \"[4, 5]\", \"[5, 4]\"],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"['1', '2']\", \"['2']\", \"['1', '2', '3']\", \"['4', '5']\", \"['5', '4']\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1      \u2506 col2 \u2506 col3            \u2506 col4 \u2502\n\u2502 ---       \u2506 ---  \u2506 ---             \u2506 ---  \u2502\n\u2502 str       \u2506 str  \u2506 str             \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 [1, 2]    \u2506 1    \u2506 ['1', '2']      \u2506 a    \u2502\n\u2502 [2]       \u2506 2    \u2506 ['2']           \u2506 b    \u2502\n\u2502 [1, 2, 3] \u2506 3    \u2506 ['1', '2', '3'] \u2506 c    \u2502\n\u2502 [4, 5]    \u2506 4    \u2506 ['4', '5']      \u2506 d    \u2502\n\u2502 [5, 4]    \u2506 5    \u2506 ['5', '4']      \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1      \u2506 col2 \u2506 col3            \u2506 col4 \u2506 col1_out  \u2506 col3_out        \u2502\n\u2502 ---       \u2506 ---  \u2506 ---             \u2506 ---  \u2506 ---       \u2506 ---             \u2502\n\u2502 str       \u2506 str  \u2506 str             \u2506 str  \u2506 list[i64] \u2506 list[str]       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 [1, 2]    \u2506 1    \u2506 ['1', '2']      \u2506 a    \u2506 [1, 2]    \u2506 [\"1\", \"2\"]      \u2502\n\u2502 [2]       \u2506 2    \u2506 ['2']           \u2506 b    \u2506 [2]       \u2506 [\"2\"]           \u2502\n\u2502 [1, 2, 3] \u2506 3    \u2506 ['1', '2', '3'] \u2506 c    \u2506 [1, 2, 3] \u2506 [\"1\", \"2\", \"3\"] \u2502\n\u2502 [4, 5]    \u2506 4    \u2506 ['4', '5']      \u2506 d    \u2506 [4, 5]    \u2506 [\"4\", \"5\"]      \u2502\n\u2502 [5, 4]    \u2506 5    \u2506 ['5', '4']      \u2506 e    \u2506 [5, 4]    \u2506 [\"5\", \"4\"]      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.LabelEncoder","title":"grizz.transformer.LabelEncoder","text":"<p>               Bases: <code>BaseIn1Out1Transformer</code></p> <p>Implement a <code>polars.DataFrame</code> to encode the labels in a given column.</p> <p>Parameters:</p> Name Type Description Default <code>in_col</code> <code>str</code> <p>The input column name i.e. the column with the label to encode.</p> required <code>out_col</code> <code>str</code> <p>The output column name i.e. the column with encoded labels.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import LabelEncoderTransformer\n&gt;&gt;&gt; transformer = LabelEncoderTransformer(in_col=\"col1\", out_col=\"out\")\n&gt;&gt;&gt; transformer\nLabelEncoderTransformer(in_col='col1', out_col='out', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2502\n\u2502 ---  \u2506 ---  \u2502\n\u2502 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a    \u2506 1    \u2502\n\u2502 b    \u2506 2    \u2502\n\u2502 c    \u2506 3    \u2502\n\u2502 d    \u2506 4    \u2502\n\u2502 e    \u2506 5    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.fit_transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 out \u2502\n\u2502 ---  \u2506 ---  \u2506 --- \u2502\n\u2502 str  \u2506 str  \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a    \u2506 1    \u2506 0   \u2502\n\u2502 b    \u2506 2    \u2506 1   \u2502\n\u2502 c    \u2506 3    \u2506 2   \u2502\n\u2502 d    \u2506 4    \u2506 3   \u2502\n\u2502 e    \u2506 5    \u2506 4   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.LabelEncoderTransformer","title":"grizz.transformer.LabelEncoderTransformer","text":"<p>               Bases: <code>BaseIn1Out1Transformer</code></p> <p>Implement a <code>polars.DataFrame</code> to encode the labels in a given column.</p> <p>Parameters:</p> Name Type Description Default <code>in_col</code> <code>str</code> <p>The input column name i.e. the column with the label to encode.</p> required <code>out_col</code> <code>str</code> <p>The output column name i.e. the column with encoded labels.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import LabelEncoderTransformer\n&gt;&gt;&gt; transformer = LabelEncoderTransformer(in_col=\"col1\", out_col=\"out\")\n&gt;&gt;&gt; transformer\nLabelEncoderTransformer(in_col='col1', out_col='out', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2502\n\u2502 ---  \u2506 ---  \u2502\n\u2502 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a    \u2506 1    \u2502\n\u2502 b    \u2506 2    \u2502\n\u2502 c    \u2506 3    \u2502\n\u2502 d    \u2506 4    \u2502\n\u2502 e    \u2506 5    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.fit_transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 out \u2502\n\u2502 ---  \u2506 ---  \u2506 --- \u2502\n\u2502 str  \u2506 str  \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a    \u2506 1    \u2506 0   \u2502\n\u2502 b    \u2506 2    \u2506 1   \u2502\n\u2502 c    \u2506 3    \u2506 2   \u2502\n\u2502 d    \u2506 4    \u2506 3   \u2502\n\u2502 e    \u2506 5    \u2506 4   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.Lower","title":"grizz.transformer.Lower","text":"<p>               Bases: <code>BaseComparatorTransformer</code></p> <p>Implements a transformer that computes the lower operation.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to compare. <code>None</code> means all the columns.</p> required <code>target</code> <code>Any</code> <p>The target value to compare with.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the output columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the output columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Lower\n&gt;&gt;&gt; transformer = Lower(columns=[\"col1\", \"col3\"], target=4.2, prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nLowerTransformer(columns=('col1', 'col3'), target=4.2, prefix='', suffix='_out', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [10, 20, 30, 40, 50],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out \u2506 col3_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2506 bool     \u2506 bool     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2506 true     \u2506 false    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2506 true     \u2506 false    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2506 true     \u2506 false    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2506 true     \u2506 false    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2506 false    \u2506 false    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.LowerEqual","title":"grizz.transformer.LowerEqual","text":"<p>               Bases: <code>BaseComparatorTransformer</code></p> <p>Implements a transformer that computes the lower than or equal operation.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to compare. <code>None</code> means all the columns.</p> required <code>target</code> <code>Any</code> <p>The target value to compare with.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the output columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the output columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import LowerEqual\n&gt;&gt;&gt; transformer = LowerEqual(columns=[\"col1\", \"col3\"], target=4.2, prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nLowerEqualTransformer(columns=('col1', 'col3'), target=4.2, prefix='', suffix='_out', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [10, 20, 30, 40, 50],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out \u2506 col3_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2506 bool     \u2506 bool     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2506 true     \u2506 false    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2506 true     \u2506 false    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2506 true     \u2506 false    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2506 true     \u2506 false    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2506 false    \u2506 false    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.LowerEqualTransformer","title":"grizz.transformer.LowerEqualTransformer","text":"<p>               Bases: <code>BaseComparatorTransformer</code></p> <p>Implements a transformer that computes the lower than or equal operation.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to compare. <code>None</code> means all the columns.</p> required <code>target</code> <code>Any</code> <p>The target value to compare with.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the output columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the output columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import LowerEqual\n&gt;&gt;&gt; transformer = LowerEqual(columns=[\"col1\", \"col3\"], target=4.2, prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nLowerEqualTransformer(columns=('col1', 'col3'), target=4.2, prefix='', suffix='_out', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [10, 20, 30, 40, 50],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out \u2506 col3_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2506 bool     \u2506 bool     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2506 true     \u2506 false    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2506 true     \u2506 false    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2506 true     \u2506 false    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2506 true     \u2506 false    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2506 false    \u2506 false    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.LowerTransformer","title":"grizz.transformer.LowerTransformer","text":"<p>               Bases: <code>BaseComparatorTransformer</code></p> <p>Implements a transformer that computes the lower operation.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to compare. <code>None</code> means all the columns.</p> required <code>target</code> <code>Any</code> <p>The target value to compare with.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the output columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the output columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Lower\n&gt;&gt;&gt; transformer = Lower(columns=[\"col1\", \"col3\"], target=4.2, prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nLowerTransformer(columns=('col1', 'col3'), target=4.2, prefix='', suffix='_out', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [10, 20, 30, 40, 50],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out \u2506 col3_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2506 bool     \u2506 bool     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2506 true     \u2506 false    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2506 true     \u2506 false    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2506 true     \u2506 false    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2506 true     \u2506 false    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2506 false    \u2506 false    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.MaxAbsScaler","title":"grizz.transformer.MaxAbsScaler","text":"<p>               Bases: <code>BaseInNOutNTransformer</code></p> <p>Implement a transformer to scale columns by the maximum absolute value of each column.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to scale. <code>None</code> means all the columns.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the copied columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the copied columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>propagate_nulls</code> <code>bool</code> <p>If set to <code>True</code>, the <code>None</code> values are propagated after the transformation. If <code>False</code>, the <code>None</code> values are replaced by NaNs.</p> <code>True</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import MaxAbsScaler\n&gt;&gt;&gt; transformer = MaxAbsScaler(columns=[\"col1\", \"col3\"], prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nMaxAbsScalerTransformer(columns=('col1', 'col3'), exclude_columns=(), exist_policy='raise', missing_policy='raise', prefix='', suffix='_out', propagate_nulls=True)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [10, 20, 30, 40, 50],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.fit_transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out \u2506 col3_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2506 f64      \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2506 0.2      \u2506 0.2      \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2506 0.4      \u2506 0.4      \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2506 0.6      \u2506 0.6      \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2506 0.8      \u2506 0.8      \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2506 1.0      \u2506 1.0      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.MaxAbsScalerTransformer","title":"grizz.transformer.MaxAbsScalerTransformer","text":"<p>               Bases: <code>BaseInNOutNTransformer</code></p> <p>Implement a transformer to scale columns by the maximum absolute value of each column.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to scale. <code>None</code> means all the columns.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the copied columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the copied columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>propagate_nulls</code> <code>bool</code> <p>If set to <code>True</code>, the <code>None</code> values are propagated after the transformation. If <code>False</code>, the <code>None</code> values are replaced by NaNs.</p> <code>True</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import MaxAbsScaler\n&gt;&gt;&gt; transformer = MaxAbsScaler(columns=[\"col1\", \"col3\"], prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nMaxAbsScalerTransformer(columns=('col1', 'col3'), exclude_columns=(), exist_policy='raise', missing_policy='raise', prefix='', suffix='_out', propagate_nulls=True)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [10, 20, 30, 40, 50],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.fit_transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out \u2506 col3_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2506 f64      \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2506 0.2      \u2506 0.2      \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2506 0.4      \u2506 0.4      \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2506 0.6      \u2506 0.6      \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2506 0.8      \u2506 0.8      \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2506 1.0      \u2506 1.0      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.MaxHorizontal","title":"grizz.transformer.MaxHorizontal","text":"<p>               Bases: <code>BaseInNOut1Transformer</code></p> <p>Implement a transformer to get the maximum value horizontally across columns and store the result in a column.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns the maximum value horizontally. The columns should be compatible. If <code>None</code>, it processes all the columns.</p> required <code>out_col</code> <code>str</code> <p>The output column.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import MaxHorizontal\n&gt;&gt;&gt; transformer = MaxHorizontal(columns=[\"col1\", \"col2\", \"col3\"], out_col=\"col\")\n&gt;&gt;&gt; transformer\nMaxHorizontalTransformer(columns=('col1', 'col2', 'col3'), out_col='col', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [9, 5, 4, 9, 6],\n...         \"col2\": [8, 0, 1, 8, 9],\n...         \"col3\": [0, 4, 8, 7, 0],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 9    \u2506 8    \u2506 0    \u2506 a    \u2502\n\u2502 5    \u2506 0    \u2506 4    \u2506 b    \u2502\n\u2502 4    \u2506 1    \u2506 8    \u2506 c    \u2502\n\u2502 9    \u2506 8    \u2506 7    \u2506 d    \u2502\n\u2502 6    \u2506 9    \u2506 0    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 --- \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 9    \u2506 8    \u2506 0    \u2506 a    \u2506 9   \u2502\n\u2502 5    \u2506 0    \u2506 4    \u2506 b    \u2506 5   \u2502\n\u2502 4    \u2506 1    \u2506 8    \u2506 c    \u2506 8   \u2502\n\u2502 9    \u2506 8    \u2506 7    \u2506 d    \u2506 9   \u2502\n\u2502 6    \u2506 9    \u2506 0    \u2506 e    \u2506 9   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.MaxHorizontalTransformer","title":"grizz.transformer.MaxHorizontalTransformer","text":"<p>               Bases: <code>BaseInNOut1Transformer</code></p> <p>Implement a transformer to get the maximum value horizontally across columns and store the result in a column.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns the maximum value horizontally. The columns should be compatible. If <code>None</code>, it processes all the columns.</p> required <code>out_col</code> <code>str</code> <p>The output column.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import MaxHorizontal\n&gt;&gt;&gt; transformer = MaxHorizontal(columns=[\"col1\", \"col2\", \"col3\"], out_col=\"col\")\n&gt;&gt;&gt; transformer\nMaxHorizontalTransformer(columns=('col1', 'col2', 'col3'), out_col='col', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [9, 5, 4, 9, 6],\n...         \"col2\": [8, 0, 1, 8, 9],\n...         \"col3\": [0, 4, 8, 7, 0],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 9    \u2506 8    \u2506 0    \u2506 a    \u2502\n\u2502 5    \u2506 0    \u2506 4    \u2506 b    \u2502\n\u2502 4    \u2506 1    \u2506 8    \u2506 c    \u2502\n\u2502 9    \u2506 8    \u2506 7    \u2506 d    \u2502\n\u2502 6    \u2506 9    \u2506 0    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 --- \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 9    \u2506 8    \u2506 0    \u2506 a    \u2506 9   \u2502\n\u2502 5    \u2506 0    \u2506 4    \u2506 b    \u2506 5   \u2502\n\u2502 4    \u2506 1    \u2506 8    \u2506 c    \u2506 8   \u2502\n\u2502 9    \u2506 8    \u2506 7    \u2506 d    \u2506 9   \u2502\n\u2502 6    \u2506 9    \u2506 0    \u2506 e    \u2506 9   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.MeanHorizontal","title":"grizz.transformer.MeanHorizontal","text":"<p>               Bases: <code>BaseInNOut1Transformer</code></p> <p>Implement a transformer to get the mean value horizontally across columns and store the result in a column.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns the mean value horizontally. The columns should be compatible. If <code>None</code>, it processes all the columns.</p> required <code>out_col</code> <code>str</code> <p>The output column.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>polars.mean_horizontal</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import MeanHorizontal\n&gt;&gt;&gt; transformer = MeanHorizontal(columns=[\"col1\", \"col2\", \"col3\"], out_col=\"col\")\n&gt;&gt;&gt; transformer\nMeanHorizontalTransformer(columns=('col1', 'col2', 'col3'), out_col='col', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [11, 12, 13, 14, 15],\n...         \"col2\": [21, 22, 23, 24, 25],\n...         \"col3\": [31, 32, 33, 34, 35],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11   \u2506 21   \u2506 31   \u2506 a    \u2502\n\u2502 12   \u2506 22   \u2506 32   \u2506 b    \u2502\n\u2502 13   \u2506 23   \u2506 33   \u2506 c    \u2502\n\u2502 14   \u2506 24   \u2506 34   \u2506 d    \u2502\n\u2502 15   \u2506 25   \u2506 35   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11   \u2506 21   \u2506 31   \u2506 a    \u2506 21.0 \u2502\n\u2502 12   \u2506 22   \u2506 32   \u2506 b    \u2506 22.0 \u2502\n\u2502 13   \u2506 23   \u2506 33   \u2506 c    \u2506 23.0 \u2502\n\u2502 14   \u2506 24   \u2506 34   \u2506 d    \u2506 24.0 \u2502\n\u2502 15   \u2506 25   \u2506 35   \u2506 e    \u2506 25.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.MeanHorizontalTransformer","title":"grizz.transformer.MeanHorizontalTransformer","text":"<p>               Bases: <code>BaseInNOut1Transformer</code></p> <p>Implement a transformer to get the mean value horizontally across columns and store the result in a column.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns the mean value horizontally. The columns should be compatible. If <code>None</code>, it processes all the columns.</p> required <code>out_col</code> <code>str</code> <p>The output column.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>polars.mean_horizontal</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import MeanHorizontal\n&gt;&gt;&gt; transformer = MeanHorizontal(columns=[\"col1\", \"col2\", \"col3\"], out_col=\"col\")\n&gt;&gt;&gt; transformer\nMeanHorizontalTransformer(columns=('col1', 'col2', 'col3'), out_col='col', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [11, 12, 13, 14, 15],\n...         \"col2\": [21, 22, 23, 24, 25],\n...         \"col3\": [31, 32, 33, 34, 35],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11   \u2506 21   \u2506 31   \u2506 a    \u2502\n\u2502 12   \u2506 22   \u2506 32   \u2506 b    \u2502\n\u2502 13   \u2506 23   \u2506 33   \u2506 c    \u2502\n\u2502 14   \u2506 24   \u2506 34   \u2506 d    \u2502\n\u2502 15   \u2506 25   \u2506 35   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11   \u2506 21   \u2506 31   \u2506 a    \u2506 21.0 \u2502\n\u2502 12   \u2506 22   \u2506 32   \u2506 b    \u2506 22.0 \u2502\n\u2502 13   \u2506 23   \u2506 33   \u2506 c    \u2506 23.0 \u2502\n\u2502 14   \u2506 24   \u2506 34   \u2506 d    \u2506 24.0 \u2502\n\u2502 15   \u2506 25   \u2506 35   \u2506 e    \u2506 25.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.MinHorizontal","title":"grizz.transformer.MinHorizontal","text":"<p>               Bases: <code>BaseInNOut1Transformer</code></p> <p>Implement a transformer to get the minimum value horizontally across columns and store the result in a column.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns the minimum value horizontally. The columns should be compatible. If <code>None</code>, it processes all the columns.</p> required <code>out_col</code> <code>str</code> <p>The output column.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import MinHorizontal\n&gt;&gt;&gt; transformer = MinHorizontal(columns=[\"col1\", \"col2\", \"col3\"], out_col=\"col\")\n&gt;&gt;&gt; transformer\nMinHorizontalTransformer(columns=('col1', 'col2', 'col3'), out_col='col', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [9, 5, 4, 9, 6],\n...         \"col2\": [8, 0, 1, 8, 9],\n...         \"col3\": [0, 4, 8, 7, 0],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 9    \u2506 8    \u2506 0    \u2506 a    \u2502\n\u2502 5    \u2506 0    \u2506 4    \u2506 b    \u2502\n\u2502 4    \u2506 1    \u2506 8    \u2506 c    \u2502\n\u2502 9    \u2506 8    \u2506 7    \u2506 d    \u2502\n\u2502 6    \u2506 9    \u2506 0    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 --- \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 9    \u2506 8    \u2506 0    \u2506 a    \u2506 0   \u2502\n\u2502 5    \u2506 0    \u2506 4    \u2506 b    \u2506 0   \u2502\n\u2502 4    \u2506 1    \u2506 8    \u2506 c    \u2506 1   \u2502\n\u2502 9    \u2506 8    \u2506 7    \u2506 d    \u2506 7   \u2502\n\u2502 6    \u2506 9    \u2506 0    \u2506 e    \u2506 0   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.MinHorizontalTransformer","title":"grizz.transformer.MinHorizontalTransformer","text":"<p>               Bases: <code>BaseInNOut1Transformer</code></p> <p>Implement a transformer to get the minimum value horizontally across columns and store the result in a column.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns the minimum value horizontally. The columns should be compatible. If <code>None</code>, it processes all the columns.</p> required <code>out_col</code> <code>str</code> <p>The output column.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import MinHorizontal\n&gt;&gt;&gt; transformer = MinHorizontal(columns=[\"col1\", \"col2\", \"col3\"], out_col=\"col\")\n&gt;&gt;&gt; transformer\nMinHorizontalTransformer(columns=('col1', 'col2', 'col3'), out_col='col', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [9, 5, 4, 9, 6],\n...         \"col2\": [8, 0, 1, 8, 9],\n...         \"col3\": [0, 4, 8, 7, 0],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 9    \u2506 8    \u2506 0    \u2506 a    \u2502\n\u2502 5    \u2506 0    \u2506 4    \u2506 b    \u2502\n\u2502 4    \u2506 1    \u2506 8    \u2506 c    \u2502\n\u2502 9    \u2506 8    \u2506 7    \u2506 d    \u2502\n\u2502 6    \u2506 9    \u2506 0    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 --- \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 9    \u2506 8    \u2506 0    \u2506 a    \u2506 0   \u2502\n\u2502 5    \u2506 0    \u2506 4    \u2506 b    \u2506 0   \u2502\n\u2502 4    \u2506 1    \u2506 8    \u2506 c    \u2506 1   \u2502\n\u2502 9    \u2506 8    \u2506 7    \u2506 d    \u2506 7   \u2502\n\u2502 6    \u2506 9    \u2506 0    \u2506 e    \u2506 0   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.MinMaxScaler","title":"grizz.transformer.MinMaxScaler","text":"<p>               Bases: <code>BaseInNOutNTransformer</code></p> <p>Implement a transformer to scale each column to a given range.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to scale. <code>None</code> means all the columns.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the copied columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the copied columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>propagate_nulls</code> <code>bool</code> <p>If set to <code>True</code>, the <code>None</code> values are propagated after the transformation. If <code>False</code>, the <code>None</code> values are replaced by NaNs.</p> <code>True</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>sklearn.preprocessing.MinMaxScaler</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import MinMaxScaler\n&gt;&gt;&gt; transformer = MinMaxScaler(columns=[\"col1\", \"col3\"], prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nMinMaxScalerTransformer(columns=('col1', 'col3'), exclude_columns=(), exist_policy='raise', missing_policy='raise', prefix='', suffix='_out', propagate_nulls=True)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [0, 1, 2, 3, 4, 5],\n...         \"col2\": [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [0, 10, 20, 30, 40, 50],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (6, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0    \u2506 0    \u2506 0    \u2506 a    \u2502\n\u2502 1    \u2506 1    \u2506 10   \u2506 b    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 c    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 d    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 e    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 f    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n&gt;&gt;&gt; out = transformer.fit_transform(frame)\n&gt;&gt;&gt; out\nshape: (6, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out \u2506 col3_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2506 f64      \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0    \u2506 0    \u2506 0    \u2506 a    \u2506 0.0      \u2506 0.0      \u2502\n\u2502 1    \u2506 1    \u2506 10   \u2506 b    \u2506 0.2      \u2506 0.2      \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 c    \u2506 0.4      \u2506 0.4      \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 d    \u2506 0.6      \u2506 0.6      \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 e    \u2506 0.8      \u2506 0.8      \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 f    \u2506 1.0      \u2506 1.0      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.MinMaxScalerTransformer","title":"grizz.transformer.MinMaxScalerTransformer","text":"<p>               Bases: <code>BaseInNOutNTransformer</code></p> <p>Implement a transformer to scale each column to a given range.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to scale. <code>None</code> means all the columns.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the copied columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the copied columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>propagate_nulls</code> <code>bool</code> <p>If set to <code>True</code>, the <code>None</code> values are propagated after the transformation. If <code>False</code>, the <code>None</code> values are replaced by NaNs.</p> <code>True</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>sklearn.preprocessing.MinMaxScaler</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import MinMaxScaler\n&gt;&gt;&gt; transformer = MinMaxScaler(columns=[\"col1\", \"col3\"], prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nMinMaxScalerTransformer(columns=('col1', 'col3'), exclude_columns=(), exist_policy='raise', missing_policy='raise', prefix='', suffix='_out', propagate_nulls=True)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [0, 1, 2, 3, 4, 5],\n...         \"col2\": [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [0, 10, 20, 30, 40, 50],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (6, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0    \u2506 0    \u2506 0    \u2506 a    \u2502\n\u2502 1    \u2506 1    \u2506 10   \u2506 b    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 c    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 d    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 e    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 f    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n&gt;&gt;&gt; out = transformer.fit_transform(frame)\n&gt;&gt;&gt; out\nshape: (6, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out \u2506 col3_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2506 f64      \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0    \u2506 0    \u2506 0    \u2506 a    \u2506 0.0      \u2506 0.0      \u2502\n\u2502 1    \u2506 1    \u2506 10   \u2506 b    \u2506 0.2      \u2506 0.2      \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 c    \u2506 0.4      \u2506 0.4      \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 d    \u2506 0.6      \u2506 0.6      \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 e    \u2506 0.8      \u2506 0.8      \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 f    \u2506 1.0      \u2506 1.0      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.Normalizer","title":"grizz.transformer.Normalizer","text":"<p>               Bases: <code>BaseInNOutNTransformer</code></p> <p>Implement a transformer to normalize data points individually to unit norm.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to scale. <code>None</code> means all the columns.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the copied columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the copied columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>sklearn.preprocessing.Normalizer</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Normalizer\n&gt;&gt;&gt; transformer = Normalizer(columns=[\"col1\", \"col3\"], prefix=\"\", suffix=\"_norm\")\n&gt;&gt;&gt; transformer\nNormalizerTransformer(columns=('col1', 'col3'), exclude_columns=(), exist_policy='raise', missing_policy='raise', prefix='', suffix='_norm')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [0, 1, 2, 3, 4, 5],\n...         \"col2\": [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [5, 4, 3, 2, 1, 0],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (6, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0    \u2506 0    \u2506 5    \u2506 a    \u2502\n\u2502 1    \u2506 1    \u2506 4    \u2506 b    \u2502\n\u2502 2    \u2506 2    \u2506 3    \u2506 c    \u2502\n\u2502 3    \u2506 3    \u2506 2    \u2506 d    \u2502\n\u2502 4    \u2506 4    \u2506 1    \u2506 e    \u2502\n\u2502 5    \u2506 5    \u2506 0    \u2506 f    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.fit_transform(frame)\n&gt;&gt;&gt; out\nshape: (6, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_norm \u2506 col3_norm \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---       \u2506 ---       \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2506 f64       \u2506 f64       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0    \u2506 0    \u2506 5    \u2506 a    \u2506 0.0       \u2506 1.0       \u2502\n\u2502 1    \u2506 1    \u2506 4    \u2506 b    \u2506 0.242536  \u2506 0.970143  \u2502\n\u2502 2    \u2506 2    \u2506 3    \u2506 c    \u2506 0.5547    \u2506 0.83205   \u2502\n\u2502 3    \u2506 3    \u2506 2    \u2506 d    \u2506 0.83205   \u2506 0.5547    \u2502\n\u2502 4    \u2506 4    \u2506 1    \u2506 e    \u2506 0.970143  \u2506 0.242536  \u2502\n\u2502 5    \u2506 5    \u2506 0    \u2506 f    \u2506 1.0       \u2506 0.0       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.NormalizerTransformer","title":"grizz.transformer.NormalizerTransformer","text":"<p>               Bases: <code>BaseInNOutNTransformer</code></p> <p>Implement a transformer to normalize data points individually to unit norm.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to scale. <code>None</code> means all the columns.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the copied columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the copied columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>sklearn.preprocessing.Normalizer</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Normalizer\n&gt;&gt;&gt; transformer = Normalizer(columns=[\"col1\", \"col3\"], prefix=\"\", suffix=\"_norm\")\n&gt;&gt;&gt; transformer\nNormalizerTransformer(columns=('col1', 'col3'), exclude_columns=(), exist_policy='raise', missing_policy='raise', prefix='', suffix='_norm')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [0, 1, 2, 3, 4, 5],\n...         \"col2\": [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [5, 4, 3, 2, 1, 0],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (6, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0    \u2506 0    \u2506 5    \u2506 a    \u2502\n\u2502 1    \u2506 1    \u2506 4    \u2506 b    \u2502\n\u2502 2    \u2506 2    \u2506 3    \u2506 c    \u2502\n\u2502 3    \u2506 3    \u2506 2    \u2506 d    \u2502\n\u2502 4    \u2506 4    \u2506 1    \u2506 e    \u2502\n\u2502 5    \u2506 5    \u2506 0    \u2506 f    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.fit_transform(frame)\n&gt;&gt;&gt; out\nshape: (6, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_norm \u2506 col3_norm \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---       \u2506 ---       \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2506 f64       \u2506 f64       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0    \u2506 0    \u2506 5    \u2506 a    \u2506 0.0       \u2506 1.0       \u2502\n\u2502 1    \u2506 1    \u2506 4    \u2506 b    \u2506 0.242536  \u2506 0.970143  \u2502\n\u2502 2    \u2506 2    \u2506 3    \u2506 c    \u2506 0.5547    \u2506 0.83205   \u2502\n\u2502 3    \u2506 3    \u2506 2    \u2506 d    \u2506 0.83205   \u2506 0.5547    \u2502\n\u2502 4    \u2506 4    \u2506 1    \u2506 e    \u2506 0.970143  \u2506 0.242536  \u2502\n\u2502 5    \u2506 5    \u2506 0    \u2506 f    \u2506 1.0       \u2506 0.0       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.NotEqual","title":"grizz.transformer.NotEqual","text":"<p>               Bases: <code>BaseComparatorTransformer</code></p> <p>Implements a transformer that computes the not equal operation.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to compare. <code>None</code> means all the columns.</p> required <code>target</code> <code>Any</code> <p>The target value to compare with.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the output columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the output columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import NotEqual\n&gt;&gt;&gt; transformer = NotEqual(columns=[\"col1\", \"col3\"], target=3, prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nNotEqualTransformer(columns=('col1', 'col3'), target=3, prefix='', suffix='_out', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [10, 20, 30, 40, 50],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out \u2506 col3_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2506 bool     \u2506 bool     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2506 true     \u2506 true     \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2506 true     \u2506 true     \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2506 false    \u2506 true     \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2506 true     \u2506 true     \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2506 true     \u2506 true     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.NotEqualMissing","title":"grizz.transformer.NotEqualMissing","text":"<p>               Bases: <code>BaseComparatorTransformer</code></p> <p>Implements a transformer that computes the not equal operation where where null values are not propagated.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to compare. <code>None</code> means all the columns.</p> required <code>target</code> <code>Any</code> <p>The target value to compare with.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the output columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the output columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import NotEqualMissing\n&gt;&gt;&gt; transformer = NotEqualMissing(\n...     columns=[\"col1\", \"col3\"], target=3, prefix=\"\", suffix=\"_out\"\n... )\n&gt;&gt;&gt; transformer\nNotEqualMissingTransformer(columns=('col1', 'col3'), target=3, prefix='', suffix='_out', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [10, 20, 30, 40, 50],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out \u2506 col3_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2506 bool     \u2506 bool     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2506 true     \u2506 true     \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2506 true     \u2506 true     \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2506 false    \u2506 true     \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2506 true     \u2506 true     \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2506 true     \u2506 true     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.NotEqualMissingTransformer","title":"grizz.transformer.NotEqualMissingTransformer","text":"<p>               Bases: <code>BaseComparatorTransformer</code></p> <p>Implements a transformer that computes the not equal operation where where null values are not propagated.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to compare. <code>None</code> means all the columns.</p> required <code>target</code> <code>Any</code> <p>The target value to compare with.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the output columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the output columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import NotEqualMissing\n&gt;&gt;&gt; transformer = NotEqualMissing(\n...     columns=[\"col1\", \"col3\"], target=3, prefix=\"\", suffix=\"_out\"\n... )\n&gt;&gt;&gt; transformer\nNotEqualMissingTransformer(columns=('col1', 'col3'), target=3, prefix='', suffix='_out', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [10, 20, 30, 40, 50],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out \u2506 col3_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2506 bool     \u2506 bool     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2506 true     \u2506 true     \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2506 true     \u2506 true     \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2506 false    \u2506 true     \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2506 true     \u2506 true     \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2506 true     \u2506 true     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.NotEqualTransformer","title":"grizz.transformer.NotEqualTransformer","text":"<p>               Bases: <code>BaseComparatorTransformer</code></p> <p>Implements a transformer that computes the not equal operation.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to compare. <code>None</code> means all the columns.</p> required <code>target</code> <code>Any</code> <p>The target value to compare with.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the output columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the output columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import NotEqual\n&gt;&gt;&gt; transformer = NotEqual(columns=[\"col1\", \"col3\"], target=3, prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nNotEqualTransformer(columns=('col1', 'col3'), target=3, prefix='', suffix='_out', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [10, 20, 30, 40, 50],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out \u2506 col3_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2506 bool     \u2506 bool     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2506 true     \u2506 true     \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2506 true     \u2506 true     \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2506 false    \u2506 true     \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2506 true     \u2506 true     \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2506 true     \u2506 true     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.NumericCast","title":"grizz.transformer.NumericCast","text":"<p>               Bases: <code>CastTransformer</code></p> <p>Implement a transformer to convert columns of numeric type to a new data type.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to convert. <code>None</code> means all the columns.</p> required <code>dtype</code> <code>type[DataType]</code> <p>The target data type.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>cast</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import NumericCast\n&gt;&gt;&gt; transformer = NumericCast(columns=[\"col1\", \"col2\"], dtype=pl.Float32)\n&gt;&gt;&gt; transformer\nNumericCastTransformer(columns=('col1', 'col2'), exclude_columns=(), missing_policy='raise', dtype=Float32)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [1.0, 2.0, 3.0, 4.0, 5.0],\n...         \"col3\": [1.0, 2.0, 3.0, 4.0, 5.0],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     },\n...     schema={\n...         \"col1\": pl.Int64,\n...         \"col2\": pl.Float32,\n...         \"col3\": pl.Float64,\n...         \"col4\": pl.String,\n...     },\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 f32  \u2506 f64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.0  \u2506 1.0  \u2506 a    \u2502\n\u2502 2    \u2506 2.0  \u2506 2.0  \u2506 b    \u2502\n\u2502 3    \u2506 3.0  \u2506 3.0  \u2506 c    \u2502\n\u2502 4    \u2506 4.0  \u2506 4.0  \u2506 d    \u2502\n\u2502 5    \u2506 5.0  \u2506 5.0  \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 f32  \u2506 f32  \u2506 f64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0  \u2506 1.0  \u2506 1.0  \u2506 a    \u2502\n\u2502 2.0  \u2506 2.0  \u2506 2.0  \u2506 b    \u2502\n\u2502 3.0  \u2506 3.0  \u2506 3.0  \u2506 c    \u2502\n\u2502 4.0  \u2506 4.0  \u2506 4.0  \u2506 d    \u2502\n\u2502 5.0  \u2506 5.0  \u2506 5.0  \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.NumericCastTransformer","title":"grizz.transformer.NumericCastTransformer","text":"<p>               Bases: <code>CastTransformer</code></p> <p>Implement a transformer to convert columns of numeric type to a new data type.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to convert. <code>None</code> means all the columns.</p> required <code>dtype</code> <code>type[DataType]</code> <p>The target data type.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>cast</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import NumericCast\n&gt;&gt;&gt; transformer = NumericCast(columns=[\"col1\", \"col2\"], dtype=pl.Float32)\n&gt;&gt;&gt; transformer\nNumericCastTransformer(columns=('col1', 'col2'), exclude_columns=(), missing_policy='raise', dtype=Float32)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [1.0, 2.0, 3.0, 4.0, 5.0],\n...         \"col3\": [1.0, 2.0, 3.0, 4.0, 5.0],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     },\n...     schema={\n...         \"col1\": pl.Int64,\n...         \"col2\": pl.Float32,\n...         \"col3\": pl.Float64,\n...         \"col4\": pl.String,\n...     },\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 f32  \u2506 f64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1.0  \u2506 1.0  \u2506 a    \u2502\n\u2502 2    \u2506 2.0  \u2506 2.0  \u2506 b    \u2502\n\u2502 3    \u2506 3.0  \u2506 3.0  \u2506 c    \u2502\n\u2502 4    \u2506 4.0  \u2506 4.0  \u2506 d    \u2502\n\u2502 5    \u2506 5.0  \u2506 5.0  \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 f32  \u2506 f32  \u2506 f64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0  \u2506 1.0  \u2506 1.0  \u2506 a    \u2502\n\u2502 2.0  \u2506 2.0  \u2506 2.0  \u2506 b    \u2502\n\u2502 3.0  \u2506 3.0  \u2506 3.0  \u2506 c    \u2502\n\u2502 4.0  \u2506 4.0  \u2506 4.0  \u2506 d    \u2502\n\u2502 5.0  \u2506 5.0  \u2506 5.0  \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.OrdinalEncoder","title":"grizz.transformer.OrdinalEncoder","text":"<p>               Bases: <code>BaseInNOutNTransformer</code></p> <p>Implement a transformer to convert each column ordinal integers.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to scale. <code>None</code> means all the columns.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the copied columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the copied columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>propagate_nulls</code> <code>bool</code> <p>If set to <code>True</code>, the <code>None</code> values are propagated after the transformation. If <code>False</code>, the <code>None</code> values are replaced by NaNs.</p> <code>True</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>sklearn.preprocessing.OrdinalEncoder</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import OrdinalEncoder\n&gt;&gt;&gt; transformer = OrdinalEncoder(columns=[\"col1\", \"col2\"], prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nOrdinalEncoderTransformer(columns=('col1', 'col2'), exclude_columns=(), exist_policy='raise', missing_policy='raise', prefix='', suffix='_out', propagate_nulls=True)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [0, 1, 2, 3, 4, 5],\n...         \"col2\": [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"],\n...         \"col3\": [0, 10, 20, 30, 40, 50],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (6, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0    \u2506 a    \u2506 0    \u2502\n\u2502 1    \u2506 b    \u2506 10   \u2502\n\u2502 2    \u2506 c    \u2506 20   \u2502\n\u2502 3    \u2506 d    \u2506 30   \u2502\n\u2502 4    \u2506 e    \u2506 40   \u2502\n\u2502 5    \u2506 f    \u2506 50   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.fit_transform(frame)\n&gt;&gt;&gt; out\nshape: (6, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col1_out \u2506 col2_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 f64      \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0    \u2506 a    \u2506 0    \u2506 0.0      \u2506 0.0      \u2502\n\u2502 1    \u2506 b    \u2506 10   \u2506 1.0      \u2506 1.0      \u2502\n\u2502 2    \u2506 c    \u2506 20   \u2506 2.0      \u2506 2.0      \u2502\n\u2502 3    \u2506 d    \u2506 30   \u2506 3.0      \u2506 3.0      \u2502\n\u2502 4    \u2506 e    \u2506 40   \u2506 4.0      \u2506 4.0      \u2502\n\u2502 5    \u2506 f    \u2506 50   \u2506 5.0      \u2506 5.0      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.OrdinalEncoderTransformer","title":"grizz.transformer.OrdinalEncoderTransformer","text":"<p>               Bases: <code>BaseInNOutNTransformer</code></p> <p>Implement a transformer to convert each column ordinal integers.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to scale. <code>None</code> means all the columns.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the copied columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the copied columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>propagate_nulls</code> <code>bool</code> <p>If set to <code>True</code>, the <code>None</code> values are propagated after the transformation. If <code>False</code>, the <code>None</code> values are replaced by NaNs.</p> <code>True</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>sklearn.preprocessing.OrdinalEncoder</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import OrdinalEncoder\n&gt;&gt;&gt; transformer = OrdinalEncoder(columns=[\"col1\", \"col2\"], prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nOrdinalEncoderTransformer(columns=('col1', 'col2'), exclude_columns=(), exist_policy='raise', missing_policy='raise', prefix='', suffix='_out', propagate_nulls=True)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [0, 1, 2, 3, 4, 5],\n...         \"col2\": [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"],\n...         \"col3\": [0, 10, 20, 30, 40, 50],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (6, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0    \u2506 a    \u2506 0    \u2502\n\u2502 1    \u2506 b    \u2506 10   \u2502\n\u2502 2    \u2506 c    \u2506 20   \u2502\n\u2502 3    \u2506 d    \u2506 30   \u2502\n\u2502 4    \u2506 e    \u2506 40   \u2502\n\u2502 5    \u2506 f    \u2506 50   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.fit_transform(frame)\n&gt;&gt;&gt; out\nshape: (6, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col1_out \u2506 col2_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 f64      \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0    \u2506 a    \u2506 0    \u2506 0.0      \u2506 0.0      \u2502\n\u2502 1    \u2506 b    \u2506 10   \u2506 1.0      \u2506 1.0      \u2502\n\u2502 2    \u2506 c    \u2506 20   \u2506 2.0      \u2506 2.0      \u2502\n\u2502 3    \u2506 d    \u2506 30   \u2506 3.0      \u2506 3.0      \u2502\n\u2502 4    \u2506 e    \u2506 40   \u2506 4.0      \u2506 4.0      \u2502\n\u2502 5    \u2506 f    \u2506 50   \u2506 5.0      \u2506 5.0      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.PowerTransformer","title":"grizz.transformer.PowerTransformer","text":"<p>               Bases: <code>BaseInNOutNTransformer</code></p> <p>Implement a transformer to apply a power transform featurewise to make data more Gaussian-like.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to scale. <code>None</code> means all the columns.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the copied columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the copied columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>propagate_nulls</code> <code>bool</code> <p>If set to <code>True</code>, the <code>None</code> values are propagated after the transformation. If <code>False</code>, the <code>None</code> values are replaced by NaNs.</p> <code>True</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>sklearn.preprocessing.PowerTransformer</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import PowerTransformer\n&gt;&gt;&gt; transformer = PowerTransformer(columns=[\"col1\", \"col3\"], prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nPowerTransformer(columns=('col1', 'col3'), exclude_columns=(), exist_policy='raise', missing_policy='raise', prefix='', suffix='_out', propagate_nulls=True)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [0, 1, 2, 3, 4, 5],\n...         \"col2\": [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [0, 10, 20, 30, 40, 50],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (6, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0    \u2506 0    \u2506 0    \u2506 a    \u2502\n\u2502 1    \u2506 1    \u2506 10   \u2506 b    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 c    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 d    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 e    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 f    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.fit_transform(frame)\n&gt;&gt;&gt; out\nshape: (6, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out  \u2506 col3_out  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---       \u2506 ---       \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2506 f64       \u2506 f64       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0    \u2506 0    \u2506 0    \u2506 a    \u2506 -1.567837 \u2506 -1.695398 \u2502\n\u2502 1    \u2506 1    \u2506 10   \u2506 b    \u2506 -0.836194 \u2506 -0.740367 \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 c    \u2506 -0.210053 \u2506 -0.117399 \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 d    \u2506 0.356111  \u2506 0.402585  \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 e    \u2506 0.881486  \u2506 0.864187  \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 f    \u2506 1.376486  \u2506 1.286392  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.QuantileTransformer","title":"grizz.transformer.QuantileTransformer","text":"<p>               Bases: <code>BaseInNOutNTransformer</code></p> <p>Implement a transformer to apply the quantile transformation.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to scale. <code>None</code> means all the columns.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the copied columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the copied columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>propagate_nulls</code> <code>bool</code> <p>If set to <code>True</code>, the <code>None</code> values are propagated after the transformation. If <code>False</code>, the <code>None</code> values are replaced by NaNs.</p> <code>True</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>sklearn.preprocessing.QuantileTransformer</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import QuantileTransformer\n&gt;&gt;&gt; transformer = QuantileTransformer(columns=[\"col1\", \"col3\"], prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nQuantileTransformer(columns=('col1', 'col3'), exclude_columns=(), exist_policy='raise', missing_policy='raise', prefix='', suffix='_out', propagate_nulls=True)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [0, 1, 2, 3, 4, 5],\n...         \"col2\": [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [0, 10, 20, 30, 40, 50],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (6, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0    \u2506 0    \u2506 0    \u2506 a    \u2502\n\u2502 1    \u2506 1    \u2506 10   \u2506 b    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 c    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 d    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 e    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 f    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.fit_transform(frame)\n&gt;&gt;&gt; out\nshape: (6, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out \u2506 col3_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2506 f64      \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0    \u2506 0    \u2506 0    \u2506 a    \u2506 0.0      \u2506 0.0      \u2502\n\u2502 1    \u2506 1    \u2506 10   \u2506 b    \u2506 0.2      \u2506 0.2      \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 c    \u2506 0.4      \u2506 0.4      \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 d    \u2506 0.6      \u2506 0.6      \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 e    \u2506 0.8      \u2506 0.8      \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 f    \u2506 1.0      \u2506 1.0      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.Replace","title":"grizz.transformer.Replace","text":"<p>               Bases: <code>BaseIn1Out1Transformer</code></p> <p>Replace the values in a column by the values in a mapping.</p> <p>Parameters:</p> Name Type Description Default <code>in_col</code> <code>str</code> <p>The input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments to pass to <code>replace</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Replace\n&gt;&gt;&gt; transformer = Replace(in_col=\"old\", out_col=\"new\", old={\"a\": 1, \"b\": 2, \"c\": 3})\n&gt;&gt;&gt; transformer\nReplaceTransformer(in_col='old', out_col='new', exist_policy='raise', missing_policy='raise', old={'a': 1, 'b': 2, 'c': 3})\n&gt;&gt;&gt; frame = pl.DataFrame({\"old\": [\"a\", \"b\", \"c\", \"d\", \"e\"]})\n&gt;&gt;&gt; frame\nshape: (5, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 old \u2502\n\u2502 --- \u2502\n\u2502 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2502\n\u2502 b   \u2502\n\u2502 c   \u2502\n\u2502 d   \u2502\n\u2502 e   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 old \u2506 new \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 str \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1   \u2502\n\u2502 b   \u2506 2   \u2502\n\u2502 c   \u2506 3   \u2502\n\u2502 d   \u2506 d   \u2502\n\u2502 e   \u2506 e   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; transformer = Replace(\n...     in_col=\"old\",\n...     out_col=\"new\",\n...     old={\"a\": 1, \"b\": 2, \"c\": 3},\n...     default=None,\n... )\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 old \u2506 new  \u2502\n\u2502 --- \u2506 ---  \u2502\n\u2502 str \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1    \u2502\n\u2502 b   \u2506 2    \u2502\n\u2502 c   \u2506 3    \u2502\n\u2502 d   \u2506 null \u2502\n\u2502 e   \u2506 null \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ReplaceStrict","title":"grizz.transformer.ReplaceStrict","text":"<p>               Bases: <code>BaseIn1Out1Transformer</code></p> <p>Replace the values in a column by the values in a mapping.</p> <p>Parameters:</p> Name Type Description Default <code>in_col</code> <code>str</code> <p>The input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments to pass to <code>replace</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ReplaceStrict\n&gt;&gt;&gt; transformer = ReplaceStrict(\n...     in_col=\"old\", out_col=\"new\", old={\"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4, \"e\": 5}\n... )\n&gt;&gt;&gt; transformer\nReplaceStrictTransformer(in_col='old', out_col='new', exist_policy='raise', missing_policy='raise', old={'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5})\n&gt;&gt;&gt; frame = pl.DataFrame({\"old\": [\"a\", \"b\", \"c\", \"d\", \"e\"]})\n&gt;&gt;&gt; frame\nshape: (5, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 old \u2502\n\u2502 --- \u2502\n\u2502 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2502\n\u2502 b   \u2502\n\u2502 c   \u2502\n\u2502 d   \u2502\n\u2502 e   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 old \u2506 new \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 str \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1   \u2502\n\u2502 b   \u2506 2   \u2502\n\u2502 c   \u2506 3   \u2502\n\u2502 d   \u2506 4   \u2502\n\u2502 e   \u2506 5   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; transformer = ReplaceStrict(\n...     in_col=\"old\",\n...     out_col=\"new\",\n...     old={\"a\": 1, \"b\": 2, \"c\": 3},\n...     default=None,\n... )\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 old \u2506 new  \u2502\n\u2502 --- \u2506 ---  \u2502\n\u2502 str \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1    \u2502\n\u2502 b   \u2506 2    \u2502\n\u2502 c   \u2506 3    \u2502\n\u2502 d   \u2506 null \u2502\n\u2502 e   \u2506 null \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ReplaceStrictTransformer","title":"grizz.transformer.ReplaceStrictTransformer","text":"<p>               Bases: <code>BaseIn1Out1Transformer</code></p> <p>Replace the values in a column by the values in a mapping.</p> <p>Parameters:</p> Name Type Description Default <code>in_col</code> <code>str</code> <p>The input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments to pass to <code>replace</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ReplaceStrict\n&gt;&gt;&gt; transformer = ReplaceStrict(\n...     in_col=\"old\", out_col=\"new\", old={\"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4, \"e\": 5}\n... )\n&gt;&gt;&gt; transformer\nReplaceStrictTransformer(in_col='old', out_col='new', exist_policy='raise', missing_policy='raise', old={'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5})\n&gt;&gt;&gt; frame = pl.DataFrame({\"old\": [\"a\", \"b\", \"c\", \"d\", \"e\"]})\n&gt;&gt;&gt; frame\nshape: (5, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 old \u2502\n\u2502 --- \u2502\n\u2502 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2502\n\u2502 b   \u2502\n\u2502 c   \u2502\n\u2502 d   \u2502\n\u2502 e   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 old \u2506 new \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 str \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1   \u2502\n\u2502 b   \u2506 2   \u2502\n\u2502 c   \u2506 3   \u2502\n\u2502 d   \u2506 4   \u2502\n\u2502 e   \u2506 5   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; transformer = ReplaceStrict(\n...     in_col=\"old\",\n...     out_col=\"new\",\n...     old={\"a\": 1, \"b\": 2, \"c\": 3},\n...     default=None,\n... )\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 old \u2506 new  \u2502\n\u2502 --- \u2506 ---  \u2502\n\u2502 str \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1    \u2502\n\u2502 b   \u2506 2    \u2502\n\u2502 c   \u2506 3    \u2502\n\u2502 d   \u2506 null \u2502\n\u2502 e   \u2506 null \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ReplaceTransformer","title":"grizz.transformer.ReplaceTransformer","text":"<p>               Bases: <code>BaseIn1Out1Transformer</code></p> <p>Replace the values in a column by the values in a mapping.</p> <p>Parameters:</p> Name Type Description Default <code>in_col</code> <code>str</code> <p>The input column name.</p> required <code>out_col</code> <code>str</code> <p>The output column name.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments to pass to <code>replace</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Replace\n&gt;&gt;&gt; transformer = Replace(in_col=\"old\", out_col=\"new\", old={\"a\": 1, \"b\": 2, \"c\": 3})\n&gt;&gt;&gt; transformer\nReplaceTransformer(in_col='old', out_col='new', exist_policy='raise', missing_policy='raise', old={'a': 1, 'b': 2, 'c': 3})\n&gt;&gt;&gt; frame = pl.DataFrame({\"old\": [\"a\", \"b\", \"c\", \"d\", \"e\"]})\n&gt;&gt;&gt; frame\nshape: (5, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 old \u2502\n\u2502 --- \u2502\n\u2502 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2502\n\u2502 b   \u2502\n\u2502 c   \u2502\n\u2502 d   \u2502\n\u2502 e   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 old \u2506 new \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 str \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1   \u2502\n\u2502 b   \u2506 2   \u2502\n\u2502 c   \u2506 3   \u2502\n\u2502 d   \u2506 d   \u2502\n\u2502 e   \u2506 e   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; transformer = Replace(\n...     in_col=\"old\",\n...     out_col=\"new\",\n...     old={\"a\": 1, \"b\": 2, \"c\": 3},\n...     default=None,\n... )\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 old \u2506 new  \u2502\n\u2502 --- \u2506 ---  \u2502\n\u2502 str \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1    \u2502\n\u2502 b   \u2506 2    \u2502\n\u2502 c   \u2506 3    \u2502\n\u2502 d   \u2506 null \u2502\n\u2502 e   \u2506 null \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.RobustScaler","title":"grizz.transformer.RobustScaler","text":"<p>               Bases: <code>BaseInNOutNTransformer</code></p> <p>Implement a transformer to scale each column using statistics that are robust to outliers.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to scale. <code>None</code> means all the columns.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the copied columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the copied columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>propagate_nulls</code> <code>bool</code> <p>If set to <code>True</code>, the <code>None</code> values are propagated after the transformation. If <code>False</code>, the <code>None</code> values are replaced by NaNs.</p> <code>True</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>sklearn.preprocessing.RobustScaler</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import RobustScaler\n&gt;&gt;&gt; transformer = RobustScaler(columns=[\"col1\", \"col3\"], prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nRobustScalerTransformer(columns=('col1', 'col3'), exclude_columns=(), exist_policy='raise', missing_policy='raise', prefix='', suffix='_out', propagate_nulls=True)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [0, 1, 2, 3, 4, 5],\n...         \"col2\": [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [0, 10, 20, 30, 40, 50],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (6, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0    \u2506 0    \u2506 0    \u2506 a    \u2502\n\u2502 1    \u2506 1    \u2506 10   \u2506 b    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 c    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 d    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 e    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 f    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.fit_transform(frame)\n&gt;&gt;&gt; out\nshape: (6, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out \u2506 col3_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2506 f64      \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0    \u2506 0    \u2506 0    \u2506 a    \u2506 -1.0     \u2506 -1.0     \u2502\n\u2502 1    \u2506 1    \u2506 10   \u2506 b    \u2506 -0.6     \u2506 -0.6     \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 c    \u2506 -0.2     \u2506 -0.2     \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 d    \u2506 0.2      \u2506 0.2      \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 e    \u2506 0.6      \u2506 0.6      \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 f    \u2506 1.0      \u2506 1.0      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.RobustScalerTransformer","title":"grizz.transformer.RobustScalerTransformer","text":"<p>               Bases: <code>BaseInNOutNTransformer</code></p> <p>Implement a transformer to scale each column using statistics that are robust to outliers.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to scale. <code>None</code> means all the columns.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the copied columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the copied columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>propagate_nulls</code> <code>bool</code> <p>If set to <code>True</code>, the <code>None</code> values are propagated after the transformation. If <code>False</code>, the <code>None</code> values are replaced by NaNs.</p> <code>True</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>sklearn.preprocessing.RobustScaler</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import RobustScaler\n&gt;&gt;&gt; transformer = RobustScaler(columns=[\"col1\", \"col3\"], prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nRobustScalerTransformer(columns=('col1', 'col3'), exclude_columns=(), exist_policy='raise', missing_policy='raise', prefix='', suffix='_out', propagate_nulls=True)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [0, 1, 2, 3, 4, 5],\n...         \"col2\": [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [0, 10, 20, 30, 40, 50],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (6, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0    \u2506 0    \u2506 0    \u2506 a    \u2502\n\u2502 1    \u2506 1    \u2506 10   \u2506 b    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 c    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 d    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 e    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 f    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.fit_transform(frame)\n&gt;&gt;&gt; out\nshape: (6, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out \u2506 col3_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2506 f64      \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0    \u2506 0    \u2506 0    \u2506 a    \u2506 -1.0     \u2506 -1.0     \u2502\n\u2502 1    \u2506 1    \u2506 10   \u2506 b    \u2506 -0.6     \u2506 -0.6     \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 c    \u2506 -0.2     \u2506 -0.2     \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 d    \u2506 0.2      \u2506 0.2      \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 e    \u2506 0.6      \u2506 0.6      \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 f    \u2506 1.0      \u2506 1.0      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.Sequential","title":"grizz.transformer.Sequential","text":"<p>               Bases: <code>BaseTransformer</code></p> <p>Implement a <code>polars.DataFrame</code> transformer to apply sequentially several transformers.</p> <p>Parameters:</p> Name Type Description Default <code>transformers</code> <code>Sequence[BaseTransformer | dict]</code> <p>The transformers or their configurations.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import (\n...     Sequential,\n...     Cast,\n... )\n&gt;&gt;&gt; transformer = Sequential(\n...     [\n...         Cast(columns=[\"col1\"], dtype=pl.Float32),\n...         Cast(columns=[\"col2\"], dtype=pl.Int64),\n...     ]\n... )\n&gt;&gt;&gt; transformer\nSequentialTransformer(\n  (0): CastTransformer(columns=('col1',), exclude_columns=(), missing_policy='raise', dtype=Float32)\n  (1): CastTransformer(columns=('col2',), exclude_columns=(), missing_policy='raise', dtype=Int64)\n)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...         \"col4\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3  \u2506 col4  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---   \u2506 ---   \u2502\n\u2502 i64  \u2506 str  \u2506 str   \u2506 str   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 a     \u2506 a     \u2502\n\u2502 2    \u2506 2    \u2506  b    \u2506  b    \u2502\n\u2502 3    \u2506 3    \u2506   c   \u2506   c   \u2502\n\u2502 4    \u2506 4    \u2506 d     \u2506 d     \u2502\n\u2502 5    \u2506 5    \u2506 e     \u2506 e     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3  \u2506 col4  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---   \u2506 ---   \u2502\n\u2502 f32  \u2506 i64  \u2506 str   \u2506 str   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0  \u2506 1    \u2506 a     \u2506 a     \u2502\n\u2502 2.0  \u2506 2    \u2506  b    \u2506  b    \u2502\n\u2502 3.0  \u2506 3    \u2506   c   \u2506   c   \u2502\n\u2502 4.0  \u2506 4    \u2506 d     \u2506 d     \u2502\n\u2502 5.0  \u2506 5    \u2506 e     \u2506 e     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.SequentialTransformer","title":"grizz.transformer.SequentialTransformer","text":"<p>               Bases: <code>BaseTransformer</code></p> <p>Implement a <code>polars.DataFrame</code> transformer to apply sequentially several transformers.</p> <p>Parameters:</p> Name Type Description Default <code>transformers</code> <code>Sequence[BaseTransformer | dict]</code> <p>The transformers or their configurations.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import (\n...     Sequential,\n...     Cast,\n... )\n&gt;&gt;&gt; transformer = Sequential(\n...     [\n...         Cast(columns=[\"col1\"], dtype=pl.Float32),\n...         Cast(columns=[\"col2\"], dtype=pl.Int64),\n...     ]\n... )\n&gt;&gt;&gt; transformer\nSequentialTransformer(\n  (0): CastTransformer(columns=('col1',), exclude_columns=(), missing_policy='raise', dtype=Float32)\n  (1): CastTransformer(columns=('col2',), exclude_columns=(), missing_policy='raise', dtype=Int64)\n)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...         \"col4\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3  \u2506 col4  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---   \u2506 ---   \u2502\n\u2502 i64  \u2506 str  \u2506 str   \u2506 str   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 a     \u2506 a     \u2502\n\u2502 2    \u2506 2    \u2506  b    \u2506  b    \u2502\n\u2502 3    \u2506 3    \u2506   c   \u2506   c   \u2502\n\u2502 4    \u2506 4    \u2506 d     \u2506 d     \u2502\n\u2502 5    \u2506 5    \u2506 e     \u2506 e     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3  \u2506 col4  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---   \u2506 ---   \u2502\n\u2502 f32  \u2506 i64  \u2506 str   \u2506 str   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0  \u2506 1    \u2506 a     \u2506 a     \u2502\n\u2502 2.0  \u2506 2    \u2506  b    \u2506  b    \u2502\n\u2502 3.0  \u2506 3    \u2506   c   \u2506   c   \u2502\n\u2502 4.0  \u2506 4    \u2506 d     \u2506 d     \u2502\n\u2502 5.0  \u2506 5    \u2506 e     \u2506 e     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ShrinkMemory","title":"grizz.transformer.ShrinkMemory","text":"<p>               Bases: <code>BaseArgTransformer</code></p> <p>Implement a transformer that shrinks DataFrame memory usage.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ShrinkMemory\n&gt;&gt;&gt; transformer = ShrinkMemory()\n&gt;&gt;&gt; transformer\nShrinkMemoryTransformer()\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ShrinkMemoryTransformer","title":"grizz.transformer.ShrinkMemoryTransformer","text":"<p>               Bases: <code>BaseArgTransformer</code></p> <p>Implement a transformer that shrinks DataFrame memory usage.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ShrinkMemory\n&gt;&gt;&gt; transformer = ShrinkMemory()\n&gt;&gt;&gt; transformer\nShrinkMemoryTransformer()\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 1    \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 2    \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 3    \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 4    \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.SimpleImputer","title":"grizz.transformer.SimpleImputer","text":"<p>               Bases: <code>BaseInNOutNTransformer</code></p> <p>Implement a transformer to impute missing values with simple strategies.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to scale. <code>None</code> means all the columns.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the copied columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the copied columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>propagate_nulls</code> <code>bool</code> <p>If set to <code>True</code>, the <code>None</code> values are propagated after the transformation. If <code>False</code>, the <code>None</code> values are replaced by NaNs.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>sklearn.impute.SimpleImputer</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import SimpleImputer\n&gt;&gt;&gt; transformer = SimpleImputer(columns=[\"col1\", \"col3\"], prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nSimpleImputerTransformer(columns=('col1', 'col3'), exclude_columns=(), exist_policy='raise', missing_policy='raise', prefix='', suffix='_out', propagate_nulls=True)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [0, 1, None, 3, 4, 5],\n...         \"col2\": [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [float(\"nan\"), 10, 20, 30, 40, None],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (6, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 f64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0    \u2506 0    \u2506 NaN  \u2506 a    \u2502\n\u2502 1    \u2506 1    \u2506 10.0 \u2506 b    \u2502\n\u2502 null \u2506 2    \u2506 20.0 \u2506 c    \u2502\n\u2502 3    \u2506 3    \u2506 30.0 \u2506 d    \u2502\n\u2502 4    \u2506 4    \u2506 40.0 \u2506 e    \u2502\n\u2502 5    \u2506 5    \u2506 null \u2506 f    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.fit_transform(frame)\n&gt;&gt;&gt; out\nshape: (6, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out \u2506 col3_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 f64  \u2506 str  \u2506 f64      \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0    \u2506 0    \u2506 NaN  \u2506 a    \u2506 0.0      \u2506 25.0     \u2502\n\u2502 1    \u2506 1    \u2506 10.0 \u2506 b    \u2506 1.0      \u2506 10.0     \u2502\n\u2502 null \u2506 2    \u2506 20.0 \u2506 c    \u2506 null     \u2506 20.0     \u2502\n\u2502 3    \u2506 3    \u2506 30.0 \u2506 d    \u2506 3.0      \u2506 30.0     \u2502\n\u2502 4    \u2506 4    \u2506 40.0 \u2506 e    \u2506 4.0      \u2506 40.0     \u2502\n\u2502 5    \u2506 5    \u2506 null \u2506 f    \u2506 5.0      \u2506 null     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.SimpleImputerTransformer","title":"grizz.transformer.SimpleImputerTransformer","text":"<p>               Bases: <code>BaseInNOutNTransformer</code></p> <p>Implement a transformer to impute missing values with simple strategies.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to scale. <code>None</code> means all the columns.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the copied columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the copied columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>propagate_nulls</code> <code>bool</code> <p>If set to <code>True</code>, the <code>None</code> values are propagated after the transformation. If <code>False</code>, the <code>None</code> values are replaced by NaNs.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>sklearn.impute.SimpleImputer</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import SimpleImputer\n&gt;&gt;&gt; transformer = SimpleImputer(columns=[\"col1\", \"col3\"], prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nSimpleImputerTransformer(columns=('col1', 'col3'), exclude_columns=(), exist_policy='raise', missing_policy='raise', prefix='', suffix='_out', propagate_nulls=True)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [0, 1, None, 3, 4, 5],\n...         \"col2\": [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [float(\"nan\"), 10, 20, 30, 40, None],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (6, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 f64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0    \u2506 0    \u2506 NaN  \u2506 a    \u2502\n\u2502 1    \u2506 1    \u2506 10.0 \u2506 b    \u2502\n\u2502 null \u2506 2    \u2506 20.0 \u2506 c    \u2502\n\u2502 3    \u2506 3    \u2506 30.0 \u2506 d    \u2502\n\u2502 4    \u2506 4    \u2506 40.0 \u2506 e    \u2502\n\u2502 5    \u2506 5    \u2506 null \u2506 f    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.fit_transform(frame)\n&gt;&gt;&gt; out\nshape: (6, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out \u2506 col3_out \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 i64  \u2506 str  \u2506 f64  \u2506 str  \u2506 f64      \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0    \u2506 0    \u2506 NaN  \u2506 a    \u2506 0.0      \u2506 25.0     \u2502\n\u2502 1    \u2506 1    \u2506 10.0 \u2506 b    \u2506 1.0      \u2506 10.0     \u2502\n\u2502 null \u2506 2    \u2506 20.0 \u2506 c    \u2506 null     \u2506 20.0     \u2502\n\u2502 3    \u2506 3    \u2506 30.0 \u2506 d    \u2506 3.0      \u2506 30.0     \u2502\n\u2502 4    \u2506 4    \u2506 40.0 \u2506 e    \u2506 4.0      \u2506 40.0     \u2502\n\u2502 5    \u2506 5    \u2506 null \u2506 f    \u2506 5.0      \u2506 null     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.Sort","title":"grizz.transformer.Sort","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to sort the DataFrame by the given columns.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to use to sort the rows.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments to pass to <code>sort</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Sort\n&gt;&gt;&gt; transformer = Sort(columns=[\"col3\", \"col1\"])\n&gt;&gt;&gt; transformer\nSortTransformer(columns=('col3', 'col1'), exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\"col1\": [1, 2, None], \"col2\": [6.0, 5.0, 4.0], \"col3\": [\"a\", \"c\", \"b\"]}\n... )\n&gt;&gt;&gt; frame\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 f64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 6.0  \u2506 a    \u2502\n\u2502 2    \u2506 5.0  \u2506 c    \u2502\n\u2502 null \u2506 4.0  \u2506 b    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 f64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 6.0  \u2506 a    \u2502\n\u2502 null \u2506 4.0  \u2506 b    \u2502\n\u2502 2    \u2506 5.0  \u2506 c    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.SortColumns","title":"grizz.transformer.SortColumns","text":"<p>               Bases: <code>BaseArgTransformer</code></p> <p>Implement a transformer to sort the DataFrame columns by name.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>If set to <code>False</code>, then the columns are sorted by alphabetical order.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import SortColumns\n&gt;&gt;&gt; transformer = SortColumns()\n&gt;&gt;&gt; transformer\nSortColumnsTransformer(reverse=False)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\"col2\": [1, 2, None], \"col3\": [6.0, 5.0, 4.0], \"col1\": [\"a\", \"c\", \"b\"]}\n... )\n&gt;&gt;&gt; frame\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col2 \u2506 col3 \u2506 col1 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 f64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 6.0  \u2506 a    \u2502\n\u2502 2    \u2506 5.0  \u2506 c    \u2502\n\u2502 null \u2506 4.0  \u2506 b    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 str  \u2506 i64  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a    \u2506 1    \u2506 6.0  \u2502\n\u2502 c    \u2506 2    \u2506 5.0  \u2502\n\u2502 b    \u2506 null \u2506 4.0  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.SortColumnsTransformer","title":"grizz.transformer.SortColumnsTransformer","text":"<p>               Bases: <code>BaseArgTransformer</code></p> <p>Implement a transformer to sort the DataFrame columns by name.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>If set to <code>False</code>, then the columns are sorted by alphabetical order.</p> <code>False</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import SortColumns\n&gt;&gt;&gt; transformer = SortColumns()\n&gt;&gt;&gt; transformer\nSortColumnsTransformer(reverse=False)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\"col2\": [1, 2, None], \"col3\": [6.0, 5.0, 4.0], \"col1\": [\"a\", \"c\", \"b\"]}\n... )\n&gt;&gt;&gt; frame\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col2 \u2506 col3 \u2506 col1 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 f64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 6.0  \u2506 a    \u2502\n\u2502 2    \u2506 5.0  \u2506 c    \u2502\n\u2502 null \u2506 4.0  \u2506 b    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 str  \u2506 i64  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a    \u2506 1    \u2506 6.0  \u2502\n\u2502 c    \u2506 2    \u2506 5.0  \u2502\n\u2502 b    \u2506 null \u2506 4.0  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.SortTransformer","title":"grizz.transformer.SortTransformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to sort the DataFrame by the given columns.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to use to sort the rows.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments to pass to <code>sort</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import Sort\n&gt;&gt;&gt; transformer = Sort(columns=[\"col3\", \"col1\"])\n&gt;&gt;&gt; transformer\nSortTransformer(columns=('col3', 'col1'), exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\"col1\": [1, 2, None], \"col2\": [6.0, 5.0, 4.0], \"col3\": [\"a\", \"c\", \"b\"]}\n... )\n&gt;&gt;&gt; frame\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 f64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 6.0  \u2506 a    \u2502\n\u2502 2    \u2506 5.0  \u2506 c    \u2502\n\u2502 null \u2506 4.0  \u2506 b    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 f64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 6.0  \u2506 a    \u2502\n\u2502 null \u2506 4.0  \u2506 b    \u2502\n\u2502 2    \u2506 5.0  \u2506 c    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.SqlTransformer","title":"grizz.transformer.SqlTransformer","text":"<p>               Bases: <code>BaseArgTransformer</code></p> <p>Implement a transformer that executes a SQL query against the DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The SQL query to execute.</p> required <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import SqlTransformer\n&gt;&gt;&gt; transformer = SqlTransformer(query=\"SELECT col1, col4 FROM self WHERE col1 &gt; 2\")\n&gt;&gt;&gt; transformer\nSqlTransformer(\n  (query): SELECT col1, col4 FROM self WHERE col1 &gt; 2\n)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 3    \u2506 c    \u2502\n\u2502 4    \u2506 d    \u2502\n\u2502 5    \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.StandardScaler","title":"grizz.transformer.StandardScaler","text":"<p>               Bases: <code>BaseInNOutNTransformer</code></p> <p>Implement a transformer to standardize each column by removing the mean and scaling to unit variance.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to scale. <code>None</code> means all the columns.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the output columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the output columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>propagate_nulls</code> <code>bool</code> <p>If set to <code>True</code>, the <code>None</code> values are propagated after the transformation. If <code>False</code>, the <code>None</code> values are replaced by NaNs.</p> <code>True</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>sklearn.preprocessing.StandardScaler</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import StandardScaler\n&gt;&gt;&gt; transformer = StandardScaler(columns=[\"col1\", \"col3\"], prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nStandardScalerTransformer(columns=('col1', 'col3'), exclude_columns=(), exist_policy='raise', missing_policy='raise', prefix='', suffix='_out', propagate_nulls=True)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [10, 20, 30, 40, 50],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.fit_transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out  \u2506 col3_out  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---       \u2506 ---       \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2506 f64       \u2506 f64       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2506 -1.414214 \u2506 -1.414214 \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2506 -0.707107 \u2506 -0.707107 \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2506 0.0       \u2506 0.0       \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2506 0.707107  \u2506 0.707107  \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2506 1.414214  \u2506 1.414214  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.StandardScalerTransformer","title":"grizz.transformer.StandardScalerTransformer","text":"<p>               Bases: <code>BaseInNOutNTransformer</code></p> <p>Implement a transformer to standardize each column by removing the mean and scaling to unit variance.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to scale. <code>None</code> means all the columns.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the output columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the output columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>propagate_nulls</code> <code>bool</code> <p>If set to <code>True</code>, the <code>None</code> values are propagated after the transformation. If <code>False</code>, the <code>None</code> values are replaced by NaNs.</p> <code>True</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>sklearn.preprocessing.StandardScaler</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import StandardScaler\n&gt;&gt;&gt; transformer = StandardScaler(columns=[\"col1\", \"col3\"], prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nStandardScalerTransformer(columns=('col1', 'col3'), exclude_columns=(), exist_policy='raise', missing_policy='raise', prefix='', suffix='_out', propagate_nulls=True)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [10, 20, 30, 40, 50],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.fit_transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col1_out  \u2506 col3_out  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---       \u2506 ---       \u2502\n\u2502 i64  \u2506 str  \u2506 i64  \u2506 str  \u2506 f64       \u2506 f64       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 10   \u2506 a    \u2506 -1.414214 \u2506 -1.414214 \u2502\n\u2502 2    \u2506 2    \u2506 20   \u2506 b    \u2506 -0.707107 \u2506 -0.707107 \u2502\n\u2502 3    \u2506 3    \u2506 30   \u2506 c    \u2506 0.0       \u2506 0.0       \u2502\n\u2502 4    \u2506 4    \u2506 40   \u2506 d    \u2506 0.707107  \u2506 0.707107  \u2502\n\u2502 5    \u2506 5    \u2506 50   \u2506 e    \u2506 1.414214  \u2506 1.414214  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.StripChars","title":"grizz.transformer.StripChars","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to remove leading and trailing characters.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to prepare. If <code>None</code>, it processes all the columns of type string.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>strip_chars</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import StripChars\n&gt;&gt;&gt; transformer = StripChars(columns=[\"col2\", \"col3\"])\n&gt;&gt;&gt; transformer\nStripCharsTransformer(columns=('col2', 'col3'), exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...         \"col4\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3  \u2506 col4  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---   \u2506 ---   \u2502\n\u2502 i64  \u2506 str  \u2506 str   \u2506 str   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 a     \u2506 a     \u2502\n\u2502 2    \u2506 2    \u2506  b    \u2506  b    \u2502\n\u2502 3    \u2506 3    \u2506   c   \u2506   c   \u2502\n\u2502 4    \u2506 4    \u2506 d     \u2506 d     \u2502\n\u2502 5    \u2506 5    \u2506 e     \u2506 e     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 a    \u2506 a     \u2502\n\u2502 2    \u2506 2    \u2506 b    \u2506  b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506   c   \u2502\n\u2502 4    \u2506 4    \u2506 d    \u2506 d     \u2502\n\u2502 5    \u2506 5    \u2506 e    \u2506 e     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.StripCharsTransformer","title":"grizz.transformer.StripCharsTransformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to remove leading and trailing characters.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to prepare. If <code>None</code>, it processes all the columns of type string.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>strip_chars</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import StripChars\n&gt;&gt;&gt; transformer = StripChars(columns=[\"col2\", \"col3\"])\n&gt;&gt;&gt; transformer\nStripCharsTransformer(columns=('col2', 'col3'), exclude_columns=(), missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...         \"col4\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3  \u2506 col4  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---   \u2506 ---   \u2502\n\u2502 i64  \u2506 str  \u2506 str   \u2506 str   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 a     \u2506 a     \u2502\n\u2502 2    \u2506 2    \u2506  b    \u2506  b    \u2502\n\u2502 3    \u2506 3    \u2506   c   \u2506   c   \u2502\n\u2502 4    \u2506 4    \u2506 d     \u2506 d     \u2502\n\u2502 5    \u2506 5    \u2506 e     \u2506 e     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4  \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---   \u2502\n\u2502 i64  \u2506 str  \u2506 str  \u2506 str   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 1    \u2506 a    \u2506 a     \u2502\n\u2502 2    \u2506 2    \u2506 b    \u2506  b    \u2502\n\u2502 3    \u2506 3    \u2506 c    \u2506   c   \u2502\n\u2502 4    \u2506 4    \u2506 d    \u2506 d     \u2502\n\u2502 5    \u2506 5    \u2506 e    \u2506 e     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.SumHorizontal","title":"grizz.transformer.SumHorizontal","text":"<p>               Bases: <code>BaseInNOut1Transformer</code></p> <p>Implement a transformer to sum all values horizontally across columns and store the result in a column.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to sum. The columns should be compatible. If <code>None</code>, it processes all the columns.</p> required <code>out_col</code> <code>str</code> <p>The output column.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>polars.sum_horizontal</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import SumHorizontal\n&gt;&gt;&gt; transformer = SumHorizontal(columns=[\"col1\", \"col2\", \"col3\"], out_col=\"col\")\n&gt;&gt;&gt; transformer\nSumHorizontalTransformer(columns=('col1', 'col2', 'col3'), out_col='col', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [11, 12, 13, 14, 15],\n...         \"col2\": [21, 22, 23, 24, 25],\n...         \"col3\": [31, 32, 33, 34, 35],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11   \u2506 21   \u2506 31   \u2506 a    \u2502\n\u2502 12   \u2506 22   \u2506 32   \u2506 b    \u2502\n\u2502 13   \u2506 23   \u2506 33   \u2506 c    \u2502\n\u2502 14   \u2506 24   \u2506 34   \u2506 d    \u2502\n\u2502 15   \u2506 25   \u2506 35   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 --- \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11   \u2506 21   \u2506 31   \u2506 a    \u2506 63  \u2502\n\u2502 12   \u2506 22   \u2506 32   \u2506 b    \u2506 66  \u2502\n\u2502 13   \u2506 23   \u2506 33   \u2506 c    \u2506 69  \u2502\n\u2502 14   \u2506 24   \u2506 34   \u2506 d    \u2506 72  \u2502\n\u2502 15   \u2506 25   \u2506 35   \u2506 e    \u2506 75  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.SumHorizontalTransformer","title":"grizz.transformer.SumHorizontalTransformer","text":"<p>               Bases: <code>BaseInNOut1Transformer</code></p> <p>Implement a transformer to sum all values horizontally across columns and store the result in a column.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to sum. The columns should be compatible. If <code>None</code>, it processes all the columns.</p> required <code>out_col</code> <code>str</code> <p>The output column.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to <code>polars.sum_horizontal</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import SumHorizontal\n&gt;&gt;&gt; transformer = SumHorizontal(columns=[\"col1\", \"col2\", \"col3\"], out_col=\"col\")\n&gt;&gt;&gt; transformer\nSumHorizontalTransformer(columns=('col1', 'col2', 'col3'), out_col='col', exclude_columns=(), exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [11, 12, 13, 14, 15],\n...         \"col2\": [21, 22, 23, 24, 25],\n...         \"col3\": [31, 32, 33, 34, 35],\n...         \"col4\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11   \u2506 21   \u2506 31   \u2506 a    \u2502\n\u2502 12   \u2506 22   \u2506 32   \u2506 b    \u2502\n\u2502 13   \u2506 23   \u2506 33   \u2506 c    \u2502\n\u2502 14   \u2506 24   \u2506 34   \u2506 d    \u2502\n\u2502 15   \u2506 25   \u2506 35   \u2506 e    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2506 col4 \u2506 col \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2506 --- \u2502\n\u2502 i64  \u2506 i64  \u2506 i64  \u2506 str  \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 11   \u2506 21   \u2506 31   \u2506 a    \u2506 63  \u2502\n\u2502 12   \u2506 22   \u2506 32   \u2506 b    \u2506 66  \u2502\n\u2502 13   \u2506 23   \u2506 33   \u2506 c    \u2506 69  \u2502\n\u2502 14   \u2506 24   \u2506 34   \u2506 d    \u2506 72  \u2502\n\u2502 15   \u2506 25   \u2506 35   \u2506 e    \u2506 75  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.TimeDiff","title":"grizz.transformer.TimeDiff","text":"<p>               Bases: <code>BaseTransformer</code></p> <p>Implement a transformer to compute the time difference between consecutive time steps.</p> <p>Parameters:</p> Name Type Description Default <code>group_cols</code> <code>Sequence[str]</code> <p>The columns used to generate the group for each sequence.</p> required <code>time_col</code> <code>str</code> <p>The input time column name.</p> required <code>time_diff_col</code> <code>str</code> <p>The output time difference column name.</p> required <code>shift</code> <code>int</code> <p>The number of slots to shift.</p> <code>1</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import TimeDiff\n&gt;&gt;&gt; transformer = TimeDiff(group_cols=[\"col\"], time_col=\"time\", time_diff_col=\"diff\")\n&gt;&gt;&gt; transformer\nTimeDiffTransformer(group_cols=['col'], time_col='time', time_diff_col='diff', shift=1)\n&gt;&gt;&gt; frame = pl.DataFrame({\"col\": [\"a\", \"b\", \"a\", \"a\", \"b\"], \"time\": [1, 2, 3, 4, 5]})\n&gt;&gt;&gt; frame\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col \u2506 time \u2502\n\u2502 --- \u2506 ---  \u2502\n\u2502 str \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1    \u2502\n\u2502 b   \u2506 2    \u2502\n\u2502 a   \u2506 3    \u2502\n\u2502 a   \u2506 4    \u2502\n\u2502 b   \u2506 5    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col \u2506 time \u2506 diff \u2502\n\u2502 --- \u2506 ---  \u2506 ---  \u2502\n\u2502 str \u2506 i64  \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1    \u2506 0    \u2502\n\u2502 a   \u2506 3    \u2506 2    \u2502\n\u2502 a   \u2506 4    \u2506 1    \u2502\n\u2502 b   \u2506 2    \u2506 0    \u2502\n\u2502 b   \u2506 5    \u2506 3    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.TimeDiffTransformer","title":"grizz.transformer.TimeDiffTransformer","text":"<p>               Bases: <code>BaseTransformer</code></p> <p>Implement a transformer to compute the time difference between consecutive time steps.</p> <p>Parameters:</p> Name Type Description Default <code>group_cols</code> <code>Sequence[str]</code> <p>The columns used to generate the group for each sequence.</p> required <code>time_col</code> <code>str</code> <p>The input time column name.</p> required <code>time_diff_col</code> <code>str</code> <p>The output time difference column name.</p> required <code>shift</code> <code>int</code> <p>The number of slots to shift.</p> <code>1</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import TimeDiff\n&gt;&gt;&gt; transformer = TimeDiff(group_cols=[\"col\"], time_col=\"time\", time_diff_col=\"diff\")\n&gt;&gt;&gt; transformer\nTimeDiffTransformer(group_cols=['col'], time_col='time', time_diff_col='diff', shift=1)\n&gt;&gt;&gt; frame = pl.DataFrame({\"col\": [\"a\", \"b\", \"a\", \"a\", \"b\"], \"time\": [1, 2, 3, 4, 5]})\n&gt;&gt;&gt; frame\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col \u2506 time \u2502\n\u2502 --- \u2506 ---  \u2502\n\u2502 str \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1    \u2502\n\u2502 b   \u2506 2    \u2502\n\u2502 a   \u2506 3    \u2502\n\u2502 a   \u2506 4    \u2502\n\u2502 b   \u2506 5    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col \u2506 time \u2506 diff \u2502\n\u2502 --- \u2506 ---  \u2506 ---  \u2502\n\u2502 str \u2506 i64  \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1    \u2506 0    \u2502\n\u2502 a   \u2506 3    \u2506 2    \u2502\n\u2502 a   \u2506 4    \u2506 1    \u2502\n\u2502 b   \u2506 2    \u2506 0    \u2502\n\u2502 b   \u2506 5    \u2506 3    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.TimeToSecond","title":"grizz.transformer.TimeToSecond","text":"<p>               Bases: <code>BaseIn1Out1Transformer</code></p> <p>Implement a transformer to convert a column with time values to seconds.</p> <p>Parameters:</p> Name Type Description Default <code>in_col</code> <code>str</code> <p>The input column with the time value to convert.</p> required <code>out_col</code> <code>str</code> <p>The output column with the time in seconds.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import datetime\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import TimeToSecond\n&gt;&gt;&gt; transformer = TimeToSecond(in_col=\"time\", out_col=\"second\")\n&gt;&gt;&gt; transformer\nTimeToSecondTransformer(in_col='time', out_col='second', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"time\": [\n...             datetime.time(0, 0, 1, 890000),\n...             datetime.time(0, 1, 1, 890000),\n...             datetime.time(1, 1, 1, 890000),\n...             datetime.time(0, 19, 19, 890000),\n...             datetime.time(19, 19, 19, 890000),\n...         ],\n...         \"col\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     },\n...     schema={\"time\": pl.Time, \"col\": pl.String},\n... )\n&gt;&gt;&gt; frame\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 time         \u2506 col \u2502\n\u2502 ---          \u2506 --- \u2502\n\u2502 time         \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 00:00:01.890 \u2506 a   \u2502\n\u2502 00:01:01.890 \u2506 b   \u2502\n\u2502 01:01:01.890 \u2506 c   \u2502\n\u2502 00:19:19.890 \u2506 d   \u2502\n\u2502 19:19:19.890 \u2506 e   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 time         \u2506 col \u2506 second   \u2502\n\u2502 ---          \u2506 --- \u2506 ---      \u2502\n\u2502 time         \u2506 str \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 00:00:01.890 \u2506 a   \u2506 1.89     \u2502\n\u2502 00:01:01.890 \u2506 b   \u2506 61.89    \u2502\n\u2502 01:01:01.890 \u2506 c   \u2506 3661.89  \u2502\n\u2502 00:19:19.890 \u2506 d   \u2506 1159.89  \u2502\n\u2502 19:19:19.890 \u2506 e   \u2506 69559.89 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.TimeToSecondTransformer","title":"grizz.transformer.TimeToSecondTransformer","text":"<p>               Bases: <code>BaseIn1Out1Transformer</code></p> <p>Implement a transformer to convert a column with time values to seconds.</p> <p>Parameters:</p> Name Type Description Default <code>in_col</code> <code>str</code> <p>The input column with the time value to convert.</p> required <code>out_col</code> <code>str</code> <p>The output column with the time in seconds.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import datetime\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import TimeToSecond\n&gt;&gt;&gt; transformer = TimeToSecond(in_col=\"time\", out_col=\"second\")\n&gt;&gt;&gt; transformer\nTimeToSecondTransformer(in_col='time', out_col='second', exist_policy='raise', missing_policy='raise')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"time\": [\n...             datetime.time(0, 0, 1, 890000),\n...             datetime.time(0, 1, 1, 890000),\n...             datetime.time(1, 1, 1, 890000),\n...             datetime.time(0, 19, 19, 890000),\n...             datetime.time(19, 19, 19, 890000),\n...         ],\n...         \"col\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n...     },\n...     schema={\"time\": pl.Time, \"col\": pl.String},\n... )\n&gt;&gt;&gt; frame\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 time         \u2506 col \u2502\n\u2502 ---          \u2506 --- \u2502\n\u2502 time         \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 00:00:01.890 \u2506 a   \u2502\n\u2502 00:01:01.890 \u2506 b   \u2502\n\u2502 01:01:01.890 \u2506 c   \u2502\n\u2502 00:19:19.890 \u2506 d   \u2502\n\u2502 19:19:19.890 \u2506 e   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 time         \u2506 col \u2506 second   \u2502\n\u2502 ---          \u2506 --- \u2506 ---      \u2502\n\u2502 time         \u2506 str \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 00:00:01.890 \u2506 a   \u2506 1.89     \u2502\n\u2502 00:01:01.890 \u2506 b   \u2506 61.89    \u2502\n\u2502 01:01:01.890 \u2506 c   \u2506 3661.89  \u2502\n\u2502 00:19:19.890 \u2506 d   \u2506 1159.89  \u2502\n\u2502 19:19:19.890 \u2506 e   \u2506 69559.89 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ToDatetime","title":"grizz.transformer.ToDatetime","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to convert some columns to a <code>polars.Datetime</code> type.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to convert. <code>None</code> means all the columns.</p> <code>None</code> <code>format</code> <code>str | None</code> <p>Format to use for conversion. Refer to the chrono crate documentation for the full specification. Example: <code>\"%Y-%m-%d %H:%M:%S\"</code>. If set to <code>None</code> (default), the format is inferred from the data.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>to_datetime</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ToDatetime\n&gt;&gt;&gt; transformer = ToDatetime(columns=[\"col1\"])\n&gt;&gt;&gt; transformer\nToDatetimeTransformer(columns=('col1',), exclude_columns=(), missing_policy='raise', format=None)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [\n...             \"2020-01-01 01:01:01\",\n...             \"2020-01-01 02:02:02\",\n...             \"2020-01-01 12:00:01\",\n...             \"2020-01-01 18:18:18\",\n...             \"2020-01-01 23:59:59\",\n...         ],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\n...             \"2020-01-01 11:11:11\",\n...             \"2020-02-01 12:12:12\",\n...             \"2020-03-01 13:13:13\",\n...             \"2020-04-01 08:08:08\",\n...             \"2020-05-01 23:59:59\",\n...         ],\n...     },\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1                \u2506 col2 \u2506 col3                \u2502\n\u2502 ---                 \u2506 ---  \u2506 ---                 \u2502\n\u2502 str                 \u2506 str  \u2506 str                 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-01-01 01:01:01 \u2506 1    \u2506 2020-01-01 11:11:11 \u2502\n\u2502 2020-01-01 02:02:02 \u2506 2    \u2506 2020-02-01 12:12:12 \u2502\n\u2502 2020-01-01 12:00:01 \u2506 3    \u2506 2020-03-01 13:13:13 \u2502\n\u2502 2020-01-01 18:18:18 \u2506 4    \u2506 2020-04-01 08:08:08 \u2502\n\u2502 2020-01-01 23:59:59 \u2506 5    \u2506 2020-05-01 23:59:59 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1                \u2506 col2 \u2506 col3                \u2502\n\u2502 ---                 \u2506 ---  \u2506 ---                 \u2502\n\u2502 datetime[\u03bcs]        \u2506 str  \u2506 str                 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-01-01 01:01:01 \u2506 1    \u2506 2020-01-01 11:11:11 \u2502\n\u2502 2020-01-01 02:02:02 \u2506 2    \u2506 2020-02-01 12:12:12 \u2502\n\u2502 2020-01-01 12:00:01 \u2506 3    \u2506 2020-03-01 13:13:13 \u2502\n\u2502 2020-01-01 18:18:18 \u2506 4    \u2506 2020-04-01 08:08:08 \u2502\n\u2502 2020-01-01 23:59:59 \u2506 5    \u2506 2020-05-01 23:59:59 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ToDatetimeTransformer","title":"grizz.transformer.ToDatetimeTransformer","text":"<p>               Bases: <code>BaseInNTransformer</code></p> <p>Implement a transformer to convert some columns to a <code>polars.Datetime</code> type.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns to convert. <code>None</code> means all the columns.</p> <code>None</code> <code>format</code> <code>str | None</code> <p>Format to use for conversion. Refer to the chrono crate documentation for the full specification. Example: <code>\"%Y-%m-%d %H:%M:%S\"</code>. If set to <code>None</code> (default), the format is inferred from the data.</p> <code>None</code> <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>to_datetime</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ToDatetime\n&gt;&gt;&gt; transformer = ToDatetime(columns=[\"col1\"])\n&gt;&gt;&gt; transformer\nToDatetimeTransformer(columns=('col1',), exclude_columns=(), missing_policy='raise', format=None)\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [\n...             \"2020-01-01 01:01:01\",\n...             \"2020-01-01 02:02:02\",\n...             \"2020-01-01 12:00:01\",\n...             \"2020-01-01 18:18:18\",\n...             \"2020-01-01 23:59:59\",\n...         ],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\n...             \"2020-01-01 11:11:11\",\n...             \"2020-02-01 12:12:12\",\n...             \"2020-03-01 13:13:13\",\n...             \"2020-04-01 08:08:08\",\n...             \"2020-05-01 23:59:59\",\n...         ],\n...     },\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1                \u2506 col2 \u2506 col3                \u2502\n\u2502 ---                 \u2506 ---  \u2506 ---                 \u2502\n\u2502 str                 \u2506 str  \u2506 str                 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-01-01 01:01:01 \u2506 1    \u2506 2020-01-01 11:11:11 \u2502\n\u2502 2020-01-01 02:02:02 \u2506 2    \u2506 2020-02-01 12:12:12 \u2502\n\u2502 2020-01-01 12:00:01 \u2506 3    \u2506 2020-03-01 13:13:13 \u2502\n\u2502 2020-01-01 18:18:18 \u2506 4    \u2506 2020-04-01 08:08:08 \u2502\n\u2502 2020-01-01 23:59:59 \u2506 5    \u2506 2020-05-01 23:59:59 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1                \u2506 col2 \u2506 col3                \u2502\n\u2502 ---                 \u2506 ---  \u2506 ---                 \u2502\n\u2502 datetime[\u03bcs]        \u2506 str  \u2506 str                 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-01-01 01:01:01 \u2506 1    \u2506 2020-01-01 11:11:11 \u2502\n\u2502 2020-01-01 02:02:02 \u2506 2    \u2506 2020-02-01 12:12:12 \u2502\n\u2502 2020-01-01 12:00:01 \u2506 3    \u2506 2020-03-01 13:13:13 \u2502\n\u2502 2020-01-01 18:18:18 \u2506 4    \u2506 2020-04-01 08:08:08 \u2502\n\u2502 2020-01-01 23:59:59 \u2506 5    \u2506 2020-05-01 23:59:59 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ToTime","title":"grizz.transformer.ToTime","text":"<p>               Bases: <code>BaseInNOutNTransformer</code></p> <p>Implement a transformer to convert some columns to a <code>polars.Time</code> type.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns of type string to convert. <code>None</code> means all the columns.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the output columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the output columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>to_time</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ToTime\n&gt;&gt;&gt; transformer = ToTime(columns=[\"col1\"], format=\"%H:%M:%S\", prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nToTimeTransformer(columns=('col1',), exclude_columns=(), exist_policy='raise', missing_policy='raise', prefix='', suffix='_out', format='%H:%M:%S')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [\"01:01:01\", \"02:02:02\", \"12:00:01\", \"18:18:18\", \"23:59:59\"],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"01:01:01\", \"02:02:02\", \"12:00:01\", \"18:18:18\", \"23:59:59\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1     \u2506 col2 \u2506 col3     \u2502\n\u2502 ---      \u2506 ---  \u2506 ---      \u2502\n\u2502 str      \u2506 str  \u2506 str      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 01:01:01 \u2506 1    \u2506 01:01:01 \u2502\n\u2502 02:02:02 \u2506 2    \u2506 02:02:02 \u2502\n\u2502 12:00:01 \u2506 3    \u2506 12:00:01 \u2502\n\u2502 18:18:18 \u2506 4    \u2506 18:18:18 \u2502\n\u2502 23:59:59 \u2506 5    \u2506 23:59:59 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1     \u2506 col2 \u2506 col3     \u2506 col1_out \u2502\n\u2502 ---      \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 str      \u2506 str  \u2506 str      \u2506 time     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 01:01:01 \u2506 1    \u2506 01:01:01 \u2506 01:01:01 \u2502\n\u2502 02:02:02 \u2506 2    \u2506 02:02:02 \u2506 02:02:02 \u2502\n\u2502 12:00:01 \u2506 3    \u2506 12:00:01 \u2506 12:00:01 \u2502\n\u2502 18:18:18 \u2506 4    \u2506 18:18:18 \u2506 18:18:18 \u2502\n\u2502 23:59:59 \u2506 5    \u2506 23:59:59 \u2506 23:59:59 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.ToTimeTransformer","title":"grizz.transformer.ToTimeTransformer","text":"<p>               Bases: <code>BaseInNOutNTransformer</code></p> <p>Implement a transformer to convert some columns to a <code>polars.Time</code> type.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Sequence[str] | None</code> <p>The columns of type string to convert. <code>None</code> means all the columns.</p> required <code>prefix</code> <code>str</code> <p>The column name prefix for the output columns.</p> required <code>suffix</code> <code>str</code> <p>The column name suffix for the output columns.</p> required <code>exclude_columns</code> <code>Sequence[str]</code> <p>The columns to exclude from the input <code>columns</code>. If any column is not found, it will be ignored during the filtering process.</p> <code>()</code> <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <code>**kwargs</code> <code>Any</code> <p>The keyword arguments for <code>to_time</code>.</p> <code>{}</code> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import ToTime\n&gt;&gt;&gt; transformer = ToTime(columns=[\"col1\"], format=\"%H:%M:%S\", prefix=\"\", suffix=\"_out\")\n&gt;&gt;&gt; transformer\nToTimeTransformer(columns=('col1',), exclude_columns=(), exist_policy='raise', missing_policy='raise', prefix='', suffix='_out', format='%H:%M:%S')\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [\"01:01:01\", \"02:02:02\", \"12:00:01\", \"18:18:18\", \"23:59:59\"],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"01:01:01\", \"02:02:02\", \"12:00:01\", \"18:18:18\", \"23:59:59\"],\n...     }\n... )\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1     \u2506 col2 \u2506 col3     \u2502\n\u2502 ---      \u2506 ---  \u2506 ---      \u2502\n\u2502 str      \u2506 str  \u2506 str      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 01:01:01 \u2506 1    \u2506 01:01:01 \u2502\n\u2502 02:02:02 \u2506 2    \u2506 02:02:02 \u2502\n\u2502 12:00:01 \u2506 3    \u2506 12:00:01 \u2502\n\u2502 18:18:18 \u2506 4    \u2506 18:18:18 \u2502\n\u2502 23:59:59 \u2506 5    \u2506 23:59:59 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = transformer.transform(frame)\n&gt;&gt;&gt; out\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1     \u2506 col2 \u2506 col3     \u2506 col1_out \u2502\n\u2502 ---      \u2506 ---  \u2506 ---      \u2506 ---      \u2502\n\u2502 str      \u2506 str  \u2506 str      \u2506 time     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 01:01:01 \u2506 1    \u2506 01:01:01 \u2506 01:01:01 \u2502\n\u2502 02:02:02 \u2506 2    \u2506 02:02:02 \u2506 02:02:02 \u2502\n\u2502 12:00:01 \u2506 3    \u2506 12:00:01 \u2506 12:00:01 \u2502\n\u2502 18:18:18 \u2506 4    \u2506 18:18:18 \u2506 18:18:18 \u2502\n\u2502 23:59:59 \u2506 5    \u2506 23:59:59 \u2506 23:59:59 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.is_transformer_config","title":"grizz.transformer.is_transformer_config","text":"<pre><code>is_transformer_config(config: dict) -&gt; bool\n</code></pre> <p>Indicate if the input configuration is a configuration for a <code>BaseTransformer</code>.</p> <p>This function only checks if the value of the key  <code>_target_</code> is valid. It does not check the other values. If <code>_target_</code> indicates a function, the returned type hint is used to check the class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the input configuration is a configuration for a <code>BaseTransformer</code> object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import is_transformer_config\n&gt;&gt;&gt; is_transformer_config(\n...     {\n...         \"_target_\": \"grizz.transformer.Cast\",\n...         \"columns\": (\"col1\", \"col3\"),\n...         \"dtype\": pl.Int32,\n...     }\n... )\nTrue\n</code></pre>"},{"location":"refs/transformer/#grizz.transformer.setup_transformer","title":"grizz.transformer.setup_transformer","text":"<pre><code>setup_transformer(\n    transformer: BaseTransformer | dict,\n) -&gt; BaseTransformer\n</code></pre> <p>Set up a <code>polars.DataFrame</code> transformer.</p> <p>The transformer is instantiated from its configuration by using the <code>BaseTransformer</code> factory function.</p> <p>Parameters:</p> Name Type Description Default <code>transformer</code> <code>BaseTransformer | dict</code> <p>Specifies a <code>polars.DataFrame</code> transformer or its configuration.</p> required <p>Returns:</p> Type Description <code>BaseTransformer</code> <p>An instantiated transformer.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.transformer import setup_transformer\n&gt;&gt;&gt; transformer = setup_transformer(\n...     {\n...         \"_target_\": \"grizz.transformer.Cast\",\n...         \"columns\": (\"col1\", \"col3\"),\n...         \"dtype\": pl.Int32,\n...     }\n... )\n&gt;&gt;&gt; transformer\nCastTransformer(columns=('col1', 'col3'), exclude_columns=(), missing_policy='raise', dtype=Int32)\n</code></pre>"},{"location":"refs/utils/","title":"utils","text":""},{"location":"refs/utils/#grizz.utils","title":"grizz.utils","text":"<p>Contain utility functions.</p>"},{"location":"refs/utils/#grizz.utils.column","title":"grizz.utils.column","text":"<p>Contain DataFrame columns utility functions.</p>"},{"location":"refs/utils/#grizz.utils.column.check_column_exist_policy","title":"grizz.utils.column.check_column_exist_policy","text":"<pre><code>check_column_exist_policy(exist_policy: str) -&gt; None\n</code></pre> <p>Check the policy on how to handle existing columns.</p> <p>Parameters:</p> Name Type Description Default <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>exist_policy</code> is not <code>'ignore'</code>, <code>'warn'</code>, or <code>'raise'</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.column import check_column_exist_policy\n&gt;&gt;&gt; check_column_exist_policy(\"ignore\")\n</code></pre>"},{"location":"refs/utils/#grizz.utils.column.check_column_missing_policy","title":"grizz.utils.column.check_column_missing_policy","text":"<pre><code>check_column_missing_policy(missing_policy: str) -&gt; None\n</code></pre> <p>Check the policy on how to handle missing columns.</p> <p>Parameters:</p> Name Type Description Default <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>missing_policy</code> is not <code>'ignore'</code>, <code>'warn'</code>, or <code>'raise'</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.column import check_column_missing_policy\n&gt;&gt;&gt; check_column_missing_policy(\"ignore\")\n</code></pre>"},{"location":"refs/utils/#grizz.utils.column.check_existing_column","title":"grizz.utils.column.check_existing_column","text":"<pre><code>check_existing_column(\n    frame_or_cols: DataFrame | Sequence,\n    column: str,\n    exist_policy: str = \"raise\",\n) -&gt; None\n</code></pre> <p>Check if a column already exists.</p> <p>Parameters:</p> Name Type Description Default <code>frame_or_cols</code> <code>DataFrame | Sequence</code> <p>The DataFrame or its columns.</p> required <code>column</code> <code>str</code> <p>The column to check.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised the column already exists. If <code>'warn'</code>, a warning is raised if the column already exists and the existing column is overwritten. If <code>'ignore'</code>, the existing column is overwritten and no warning message appears.</p> <code>'raise'</code> <p>Raises:</p> Type Description <code>ColumnExistsError</code> <p>if at least one column already exists and <code>exist_policy='raise'</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.utils.column import check_existing_column\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...         \"col4\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; check_existing_column(frame, \"col1\", exist_policy=\"warn\")\n</code></pre>"},{"location":"refs/utils/#grizz.utils.column.check_existing_columns","title":"grizz.utils.column.check_existing_columns","text":"<pre><code>check_existing_columns(\n    frame_or_cols: DataFrame | Sequence,\n    columns: Sequence,\n    exist_policy: str = \"raise\",\n) -&gt; None\n</code></pre> <p>Check if some columns already exist.</p> <p>Parameters:</p> Name Type Description Default <code>frame_or_cols</code> <code>DataFrame | Sequence</code> <p>The DataFrame or its columns.</p> required <code>columns</code> <code>Sequence</code> <p>The columns to check.</p> required <code>exist_policy</code> <code>str</code> <p>The policy on how to handle existing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column already exist. If <code>'warn'</code>, a warning is raised if at least one column already exist and the existing columns are overwritten. If <code>'ignore'</code>, the existing columns are overwritten and no warning message appears.</p> <code>'raise'</code> <p>Raises:</p> Type Description <code>ColumnExistsError</code> <p>if at least one column already exists and <code>exist_policy='raise'</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.utils.column import check_existing_columns\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...         \"col4\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; check_existing_columns(frame, [\"col1\", \"col5\"], exist_policy=\"warn\")\n</code></pre>"},{"location":"refs/utils/#grizz.utils.column.check_missing_column","title":"grizz.utils.column.check_missing_column","text":"<pre><code>check_missing_column(\n    frame_or_cols: DataFrame | Sequence,\n    column: str,\n    missing_policy: str = \"raise\",\n) -&gt; None\n</code></pre> <p>Check if a column is missing.</p> <p>Parameters:</p> Name Type Description Default <code>frame_or_cols</code> <code>DataFrame | Sequence</code> <p>The DataFrame or its columns.</p> required <code>column</code> <code>str</code> <p>The column to check.</p> required <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if the column is missing. If <code>'warn'</code>, a warning is raised if the column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing column is ignored and no warning message appears.</p> <code>'raise'</code> <p>Raises:</p> Type Description <code>ColumnNotFoundError</code> <p>if the column is missing and <code>missing_policy='raise'</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.utils.column import check_missing_column\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...         \"col4\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; check_missing_column(frame, \"col1\", missing_policy=\"warn\")\n</code></pre>"},{"location":"refs/utils/#grizz.utils.column.check_missing_columns","title":"grizz.utils.column.check_missing_columns","text":"<pre><code>check_missing_columns(\n    frame_or_cols: DataFrame | Sequence,\n    columns: Sequence,\n    missing_policy: str = \"raise\",\n) -&gt; None\n</code></pre> <p>Check if some columns are missing.</p> <p>Parameters:</p> Name Type Description Default <code>frame_or_cols</code> <code>DataFrame | Sequence</code> <p>The DataFrame or its columns.</p> required <code>columns</code> <code>Sequence</code> <p>The columns to check.</p> required <code>missing_policy</code> <code>str</code> <p>The policy on how to handle missing columns. The following options are available: <code>'ignore'</code>, <code>'warn'</code>, and <code>'raise'</code>. If <code>'raise'</code>, an exception is raised if at least one column is missing. If <code>'warn'</code>, a warning is raised if at least one column is missing and the missing columns are ignored. If <code>'ignore'</code>, the missing columns are ignored and no warning message appears.</p> <code>'raise'</code> <p>Raises:</p> Type Description <code>ColumnNotFoundError</code> <p>if at least one column is missing and <code>missing_policy='raise'</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.utils.column import check_missing_columns\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...         \"col4\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; check_missing_columns(frame, [\"col1\", \"col5\"], missing_policy=\"warn\")\n</code></pre>"},{"location":"refs/utils/#grizz.utils.column.find_common_columns","title":"grizz.utils.column.find_common_columns","text":"<pre><code>find_common_columns(\n    frame_or_cols: DataFrame | Sequence,\n    columns: Sequence[str],\n) -&gt; tuple[str, ...]\n</code></pre> <p>Find the common columns that are both in the DataFrame and the given columns.</p> <p>Parameters:</p> Name Type Description Default <code>frame_or_cols</code> <code>DataFrame | Sequence</code> <p>The DataFrame or its columns.</p> required <code>columns</code> <code>Sequence[str]</code> <p>The columns to check.</p> required <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>The columns i.e. the columns that are both in <code>columns</code> and <code>frame_or_cols</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.utils.column import find_common_columns\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; cols = find_common_columns(frame, columns=[\"col1\", \"col2\", \"col3\", \"col4\"])\n&gt;&gt;&gt; cols\n('col1', 'col2', 'col3')\n</code></pre>"},{"location":"refs/utils/#grizz.utils.column.find_missing_columns","title":"grizz.utils.column.find_missing_columns","text":"<pre><code>find_missing_columns(\n    frame_or_cols: DataFrame | Sequence,\n    columns: Sequence[str],\n) -&gt; tuple[str, ...]\n</code></pre> <p>Find the columns that are in the given columns but not in the DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>frame_or_cols</code> <code>DataFrame | Sequence</code> <p>The DataFrame or its columns.</p> required <code>columns</code> <code>Sequence[str]</code> <p>The columns to check.</p> required <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>The list of missing columns i.e. the columns that are in <code>columns</code> but not in <code>frame_or_cols</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.utils.column import find_missing_columns\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"col1\": [1, 2, 3, 4, 5],\n...         \"col2\": [\"1\", \"2\", \"3\", \"4\", \"5\"],\n...         \"col3\": [\"a \", \" b\", \"  c  \", \"d\", \"e\"],\n...     }\n... )\n&gt;&gt;&gt; cols = find_missing_columns(frame, columns=[\"col1\", \"col2\", \"col3\", \"col4\"])\n&gt;&gt;&gt; cols\n('col4',)\n</code></pre>"},{"location":"refs/utils/#grizz.utils.count","title":"grizz.utils.count","text":"<p>Contain utility functions for counting.</p>"},{"location":"refs/utils/#grizz.utils.count.compute_nunique","title":"grizz.utils.count.compute_nunique","text":"<pre><code>compute_nunique(frame: DataFrame) -&gt; ndarray\n</code></pre> <p>Return the number of unique values in each column.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>An array with the number of unique values in each column. The shape of the array is the number of columns.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.utils.count import compute_nunique\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"int\": [None, 1, 0, 1],\n...         \"float\": [1.2, 4.2, None, 2.2],\n...         \"str\": [\"A\", \"B\", None, None],\n...     },\n...     schema={\"int\": pl.Int64, \"float\": pl.Float64, \"str\": pl.String},\n... )\n&gt;&gt;&gt; count = compute_nunique(frame)\n&gt;&gt;&gt; count\narray([3, 4, 3])\n</code></pre>"},{"location":"refs/utils/#grizz.utils.count.compute_temporal_count","title":"grizz.utils.count.compute_temporal_count","text":"<pre><code>compute_temporal_count(\n    frame: DataFrame, temporal_column: str, period: str\n) -&gt; tuple[ndarray, list[str]]\n</code></pre> <p>Prepare the data to create the figure and table.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>temporal_column</code> <code>str</code> <p>The temporal column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <p>Returns:</p> Type Description <code>tuple[ndarray, list[str]]</code> <p>A tuple with the counts and the temporal steps.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.utils.count import compute_temporal_count\n&gt;&gt;&gt; counts, steps = compute_temporal_count(\n...     frame=pl.DataFrame(\n...         {\n...             \"col1\": [None, float(\"nan\"), 0.0, 1.0, 4.2, 42.0],\n...             \"col2\": [None, 1, 0, None, 2, 3],\n...             \"datetime\": [\n...                 datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=1, day=4, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=1, day=5, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...             ],\n...         },\n...         schema={\n...             \"col1\": pl.Float64,\n...             \"col2\": pl.Int64,\n...             \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...         },\n...     ),\n...     temporal_column=\"datetime\",\n...     period=\"1mo\",\n... )\n&gt;&gt;&gt; counts\narray([3, 1, 1, 1])\n&gt;&gt;&gt; steps\n['2020-01', '2020-02', '2020-03', '2020-04']\n</code></pre>"},{"location":"refs/utils/#grizz.utils.count.compute_temporal_value_counts","title":"grizz.utils.count.compute_temporal_value_counts","text":"<pre><code>compute_temporal_value_counts(\n    frame: DataFrame,\n    column: str,\n    temporal_column: str,\n    period: str,\n    drop_nulls: bool = False,\n) -&gt; tuple[ndarray, list[str], list[str]]\n</code></pre> <p>Compute the value counts for temporal windows of a given column.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>column</code> <code>str</code> <p>The column to analyze the temporal value counts.</p> required <code>temporal_column</code> <code>str</code> <p>The temporal column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <code>drop_nulls</code> <code>bool</code> <p>If <code>True</code>, the null values are ignored.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[ndarray, list[str], list[str]]</code> <p>A tuple with 3 items. The first item is a 2-d array that indicates the number of occurrences for each value and time step. The first dimension represents the value and the second dimension represents the steps. The second item is the list of time steps. The third item is the list of string representation of the values.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.utils.count import compute_temporal_value_counts\n&gt;&gt;&gt; counts, steps, values = compute_temporal_value_counts(\n...     frame=pl.DataFrame(\n...         {\n...             \"col1\": [None, 1.0, 0.0, 1.0, 4.2, 42.0],\n...             \"col2\": [None, 1, 0, None, 2, 3],\n...             \"datetime\": [\n...                 datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=1, day=4, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=1, day=5, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...             ],\n...         },\n...         schema={\n...             \"col1\": pl.Float64,\n...             \"col2\": pl.Int64,\n...             \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...         },\n...     ),\n...     column=\"col1\",\n...     temporal_column=\"datetime\",\n...     period=\"1mo\",\n... )\n&gt;&gt;&gt; counts\narray([[1, 0, 0, 0],\n       [1, 1, 0, 0],\n       [0, 0, 1, 0],\n       [0, 0, 0, 1],\n       [1, 0, 0, 0]])\n&gt;&gt;&gt; steps\n['2020-01', '2020-02', '2020-03', '2020-04']\n&gt;&gt;&gt; values\n['0.0', '1.0', '4.2', '42.0', 'null']\n</code></pre>"},{"location":"refs/utils/#grizz.utils.datetime","title":"grizz.utils.datetime","text":"<p>Contain utility functions for datetime and date objects.</p>"},{"location":"refs/utils/#grizz.utils.datetime.find_end_datetime","title":"grizz.utils.datetime.find_end_datetime","text":"<pre><code>find_end_datetime(\n    start: datetime | date,\n    interval: str | timedelta,\n    periods: int,\n) -&gt; datetime\n</code></pre> <p>Find the upper bound of the datetime range from the lower bound of the datetime range, the interval, and the number of periods.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>datetime | date</code> <p>The lower bound of the datetime range.</p> required <code>interval</code> <code>str | timedelta</code> <p>The interval of the range periods, specified as a Python timedelta object or using the Polars duration string language.</p> required <code>periods</code> <code>int</code> <p>The number of periods after the start.</p> required <p>Returns:</p> Type Description <code>datetime</code> <p>The upper bound of the datetime range.</p> Notes <p><code>interval</code> is created according to the following string     language:</p> <pre><code>- 1ns (1 nanosecond)\n- 1us (1 microsecond)\n- 1ms (1 millisecond)\n- 1s (1 second)\n- 1m (1 minute)\n- 1h (1 hour)\n- 1d (1 calendar day)\n- 1w (1 calendar week)\n</code></pre> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta, datetime, timezone\n&gt;&gt;&gt; from grizz.utils.datetime import find_end_datetime\n&gt;&gt;&gt; find_end_datetime(\n...     start=datetime(year=2020, month=5, day=12, hour=4, tzinfo=timezone.utc),\n...     interval=timedelta(hours=1),\n...     periods=42,\n... )\ndatetime.datetime(2020, 5, 13, 22, 0, tzinfo=datetime.timezone.utc)\n</code></pre>"},{"location":"refs/utils/#grizz.utils.datetime.to_datetime","title":"grizz.utils.datetime.to_datetime","text":"<pre><code>to_datetime(dt: datetime | date) -&gt; datetime\n</code></pre> <p>Convert a <code>date</code> object to a <code>datetime</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>datetime | date</code> <p>The <code>date</code> object to convert.</p> required <p>Returns:</p> Type Description <code>datetime</code> <p>The <code>datetime</code> object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, date, timezone\n&gt;&gt;&gt; from grizz.utils.datetime import to_datetime\n&gt;&gt;&gt; to_datetime(datetime(year=2020, month=5, day=12, hour=4, tzinfo=timezone.utc))\ndatetime.datetime(2020, 5, 12, 4, 0, tzinfo=datetime.timezone.utc)\n&gt;&gt;&gt; to_datetime(date(year=2020, month=5, day=12))\ndatetime.datetime(2020, 5, 12, 0, 0, tzinfo=datetime.timezone.utc)\n</code></pre>"},{"location":"refs/utils/#grizz.utils.factory","title":"grizz.utils.factory","text":"<p>Contain a function to instantiate an object from its configuration.</p>"},{"location":"refs/utils/#grizz.utils.factory.setup_object","title":"grizz.utils.factory.setup_object","text":"<pre><code>setup_object(obj_or_config: T | dict) -&gt; T\n</code></pre> <p>Set up an object from its configuration.</p> <p>Parameters:</p> Name Type Description Default <code>obj_or_config</code> <code>T | dict</code> <p>The object or its configuration.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The instantiated object.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.factory import setup_object\n&gt;&gt;&gt; obj = setup_object({\"_target_\": \"collections.deque\", \"iterable\": [1, 2, 1, 3]})\n&gt;&gt;&gt; obj\ndeque([1, 2, 1, 3])\n&gt;&gt;&gt; setup_object(obj)  # Do nothing because the object is already instantiated\ndeque([1, 2, 1, 3])\n</code></pre>"},{"location":"refs/utils/#grizz.utils.format","title":"grizz.utils.format","text":"<p>Contain utility functions to format strings.</p>"},{"location":"refs/utils/#grizz.utils.format.human_byte","title":"grizz.utils.format.human_byte","text":"<pre><code>human_byte(size: float, decimal: int = 2) -&gt; str\n</code></pre> <p>Return a human-readable string representation of byte sizes.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>float</code> <p>The number of bytes.</p> required <code>decimal</code> <code>int</code> <p>The number of decimal digits.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>The human-readable string representation of byte sizes.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.format import human_byte\n&gt;&gt;&gt; human_byte(2)\n'2.00 B'\n&gt;&gt;&gt; human_byte(2048)\n'2.00 KB'\n&gt;&gt;&gt; human_byte(2097152)\n'2.00 MB'\n</code></pre>"},{"location":"refs/utils/#grizz.utils.format.str_boolean_series_stats","title":"grizz.utils.format.str_boolean_series_stats","text":"<pre><code>str_boolean_series_stats(series: Series) -&gt; str\n</code></pre> <p>Return a string about the content of a Boolean series.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>The input series.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The generated string about the input series.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>series</code> is not a Boolean series.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.utils.format import str_boolean_series_stats\n&gt;&gt;&gt; series = pl.Series([True, False, None, None, False, None])\n&gt;&gt;&gt; str_boolean_series_stats(series)\ntrue: 1/3 (33.3333 %) | null: 3/6 (50.0000 %)\n</code></pre>"},{"location":"refs/utils/#grizz.utils.format.str_col_diff","title":"grizz.utils.format.str_col_diff","text":"<pre><code>str_col_diff(orig: int, final: int) -&gt; str\n</code></pre> <p>Return a string that indicates the difference of columns.</p> <p>Parameters:</p> Name Type Description Default <code>orig</code> <code>int</code> <p>The original number of columns.</p> required <code>final</code> <code>int</code> <p>The final number of columns.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The generated string with the difference of columns.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.format import str_col_diff\n&gt;&gt;&gt; str_col_diff(100, 10)\n90/100 (90.0000 %) columns have been removed\n&gt;&gt;&gt; str_col_diff(100, 99)\n1/100 (1.0000 %) column has been removed\n</code></pre>"},{"location":"refs/utils/#grizz.utils.format.str_kwargs","title":"grizz.utils.format.str_kwargs","text":"<pre><code>str_kwargs(mapping: Mapping) -&gt; str\n</code></pre> <p>Return a string of the input mapping.</p> <p>This function is designed to be used in <code>__repr__</code> and <code>__str__</code> methods.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>Mapping</code> <p>The mapping.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The generated string.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.format import str_kwargs\n&gt;&gt;&gt; str_kwargs({\"key1\": 1})\n', key1=1'\n&gt;&gt;&gt; str_kwargs({\"key1\": 1, \"key2\": 2})\n', key1=1, key2=2'\n</code></pre>"},{"location":"refs/utils/#grizz.utils.format.str_row_diff","title":"grizz.utils.format.str_row_diff","text":"<pre><code>str_row_diff(orig: int, final: int) -&gt; str\n</code></pre> <p>Return a string that indicates the difference of rows.</p> <p>Parameters:</p> Name Type Description Default <code>orig</code> <code>int</code> <p>The original number of rows.</p> required <code>final</code> <code>int</code> <p>The final number of rows.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The generated string with the difference of rows.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.format import str_row_diff\n&gt;&gt;&gt; str_row_diff(100, 10)\n90/100 (90.0000 %) rows have been removed\n&gt;&gt;&gt; str_row_diff(100, 99)\n1/100 (1.0000 %) row has been removed\n</code></pre>"},{"location":"refs/utils/#grizz.utils.format.str_shape_diff","title":"grizz.utils.format.str_shape_diff","text":"<pre><code>str_shape_diff(\n    orig: tuple[int, int], final: tuple[int, int]\n) -&gt; str\n</code></pre> <p>Return a string that indicates the difference of DataFrame shapes.</p> <p>Parameters:</p> Name Type Description Default <code>orig</code> <code>tuple[int, int]</code> <p>The original shape.</p> required <code>final</code> <code>tuple[int, int]</code> <p>The final shape.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The generated string with the difference of DataFrame shapes.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.format import str_shape_diff\n&gt;&gt;&gt; str_shape_diff(orig=(100, 10), final=(80, 8))\nDataFrame shape: (100, 10) -&gt; (80, 8) | 20/100 (20.0000 %) rows have been removed |\n2/10 (20.0000 %) columns have been removed\n</code></pre>"},{"location":"refs/utils/#grizz.utils.format.str_size_diff","title":"grizz.utils.format.str_size_diff","text":"<pre><code>str_size_diff(orig: float, final: float) -&gt; str\n</code></pre> <p>Return a string that indicates the difference of DataFrame sizes.</p> <p>Parameters:</p> Name Type Description Default <code>orig</code> <code>float</code> <p>The original size.</p> required <code>final</code> <code>float</code> <p>The final size.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The generated string with the difference of DataFrame sizes.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.format import str_size_diff\n&gt;&gt;&gt; str_size_diff(orig=100, final=120)\nDataFrame estimated size: 100.00 B -&gt; 120.00 B | difference: 20.00 B (20.0000 %)\n</code></pre>"},{"location":"refs/utils/#grizz.utils.hashing","title":"grizz.utils.hashing","text":"<p>Contain utility functions to compute hash of objects.</p>"},{"location":"refs/utils/#grizz.utils.hashing.str_to_sha256","title":"grizz.utils.hashing.str_to_sha256","text":"<pre><code>str_to_sha256(string: str) -&gt; str\n</code></pre> <p>Generate the SHA-256 hash of a string.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The string to hash.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The SHA-256 hash.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.hashing import str_to_sha256\n&gt;&gt;&gt; str_to_sha256(\"bears are funny\")\nc97afc5c7f1b598c9f68dc2d6e323b2dd2eaaa31d3a07c98059de6079cbd30e0\n</code></pre>"},{"location":"refs/utils/#grizz.utils.imports","title":"grizz.utils.imports","text":"<p>Implement some utility functions to manage optional dependencies.</p>"},{"location":"refs/utils/#grizz.utils.imports.check_clickhouse_connect","title":"grizz.utils.imports.check_clickhouse_connect","text":"<pre><code>check_clickhouse_connect() -&gt; None\n</code></pre> <p>Check if the <code>clickhouse_connect</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>clickhouse_connect</code> package is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.imports import check_clickhouse_connect\n&gt;&gt;&gt; check_clickhouse_connect()\n</code></pre>"},{"location":"refs/utils/#grizz.utils.imports.check_colorlog","title":"grizz.utils.imports.check_colorlog","text":"<pre><code>check_colorlog() -&gt; None\n</code></pre> <p>Check if the <code>colorlog</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>colorlog</code> package is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.imports import check_colorlog\n&gt;&gt;&gt; check_colorlog()\n</code></pre>"},{"location":"refs/utils/#grizz.utils.imports.check_pyarrow","title":"grizz.utils.imports.check_pyarrow","text":"<pre><code>check_pyarrow() -&gt; None\n</code></pre> <p>Check if the <code>pyarrow</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>pyarrow</code> package is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.imports import check_pyarrow\n&gt;&gt;&gt; check_pyarrow()\n</code></pre>"},{"location":"refs/utils/#grizz.utils.imports.check_sklearn","title":"grizz.utils.imports.check_sklearn","text":"<pre><code>check_sklearn() -&gt; None\n</code></pre> <p>Check if the <code>sklearn</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>sklearn</code> package is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.imports import check_sklearn\n&gt;&gt;&gt; check_sklearn()\n</code></pre>"},{"location":"refs/utils/#grizz.utils.imports.check_tqdm","title":"grizz.utils.imports.check_tqdm","text":"<pre><code>check_tqdm() -&gt; None\n</code></pre> <p>Check if the <code>tqdm</code> package is installed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the <code>tqdm</code> package is not installed.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.imports import check_tqdm\n&gt;&gt;&gt; check_tqdm()\n</code></pre>"},{"location":"refs/utils/#grizz.utils.imports.clickhouse_connect_available","title":"grizz.utils.imports.clickhouse_connect_available","text":"<pre><code>clickhouse_connect_available(\n    fn: Callable[..., Any]\n) -&gt; Callable[..., Any]\n</code></pre> <p>Implement a decorator to execute a function only if <code>clickhouse_connect</code> package is installed.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[..., Any]</code> <p>The function to execute.</p> required <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>A wrapper around <code>fn</code> if <code>clickhouse_connect</code> package is installed, otherwise <code>None</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.imports import clickhouse_connect_available\n&gt;&gt;&gt; @clickhouse_connect_available\n... def my_function(n: int = 0) -&gt; int:\n...     return 42 + n\n...\n&gt;&gt;&gt; my_function()\n</code></pre>"},{"location":"refs/utils/#grizz.utils.imports.colorlog_available","title":"grizz.utils.imports.colorlog_available","text":"<pre><code>colorlog_available(\n    fn: Callable[..., Any]\n) -&gt; Callable[..., Any]\n</code></pre> <p>Implement a decorator to execute a function only if <code>colorlog</code> package is installed.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[..., Any]</code> <p>The function to execute.</p> required <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>A wrapper around <code>fn</code> if <code>colorlog</code> package is installed, otherwise <code>None</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.imports import colorlog_available\n&gt;&gt;&gt; @colorlog_available\n... def my_function(n: int = 0) -&gt; int:\n...     return 42 + n\n...\n&gt;&gt;&gt; my_function()\n</code></pre>"},{"location":"refs/utils/#grizz.utils.imports.is_clickhouse_connect_available","title":"grizz.utils.imports.is_clickhouse_connect_available  <code>cached</code>","text":"<pre><code>is_clickhouse_connect_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>clickhouse_connect</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>clickhouse_connect</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.imports import is_clickhouse_connect_available\n&gt;&gt;&gt; is_clickhouse_connect_available()\n</code></pre>"},{"location":"refs/utils/#grizz.utils.imports.is_colorlog_available","title":"grizz.utils.imports.is_colorlog_available","text":"<pre><code>is_colorlog_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>colorlog</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>colorlog</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.imports import is_colorlog_available\n&gt;&gt;&gt; is_colorlog_available()\n</code></pre>"},{"location":"refs/utils/#grizz.utils.imports.is_pyarrow_available","title":"grizz.utils.imports.is_pyarrow_available  <code>cached</code>","text":"<pre><code>is_pyarrow_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>pyarrow</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>pyarrow</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.imports import is_pyarrow_available\n&gt;&gt;&gt; is_pyarrow_available()\n</code></pre>"},{"location":"refs/utils/#grizz.utils.imports.is_sklearn_available","title":"grizz.utils.imports.is_sklearn_available  <code>cached</code>","text":"<pre><code>is_sklearn_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>sklearn</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>sklearn</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.imports import is_sklearn_available\n&gt;&gt;&gt; is_sklearn_available()\n</code></pre>"},{"location":"refs/utils/#grizz.utils.imports.is_tqdm_available","title":"grizz.utils.imports.is_tqdm_available  <code>cached</code>","text":"<pre><code>is_tqdm_available() -&gt; bool\n</code></pre> <p>Indicate if the <code>tqdm</code> package is installed or not.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>tqdm</code> is available otherwise <code>False</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.imports import is_tqdm_available\n&gt;&gt;&gt; is_tqdm_available()\n</code></pre>"},{"location":"refs/utils/#grizz.utils.imports.pyarrow_available","title":"grizz.utils.imports.pyarrow_available","text":"<pre><code>pyarrow_available(\n    fn: Callable[..., Any]\n) -&gt; Callable[..., Any]\n</code></pre> <p>Implement a decorator to execute a function only if <code>pyarrow</code> package is installed.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[..., Any]</code> <p>Specifies the function to execute.</p> required <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>A wrapper around <code>fn</code> if <code>pyarrow</code> package is installed, otherwise <code>None</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.imports import pyarrow_available\n&gt;&gt;&gt; @pyarrow_available\n... def my_function(n: int = 0) -&gt; int:\n...     return 42 + n\n...\n&gt;&gt;&gt; my_function()\n</code></pre>"},{"location":"refs/utils/#grizz.utils.imports.sklearn_available","title":"grizz.utils.imports.sklearn_available","text":"<pre><code>sklearn_available(\n    fn: Callable[..., Any]\n) -&gt; Callable[..., Any]\n</code></pre> <p>Implement a decorator to execute a function only if <code>sklearn</code> package is installed.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[..., Any]</code> <p>Specifies the function to execute.</p> required <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>A wrapper around <code>fn</code> if <code>sklearn</code> package is installed, otherwise <code>None</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.imports import sklearn_available\n&gt;&gt;&gt; @sklearn_available\n... def my_function(n: int = 0) -&gt; int:\n...     return 42 + n\n...\n&gt;&gt;&gt; my_function()\n</code></pre>"},{"location":"refs/utils/#grizz.utils.imports.tqdm_available","title":"grizz.utils.imports.tqdm_available","text":"<pre><code>tqdm_available(\n    fn: Callable[..., Any]\n) -&gt; Callable[..., Any]\n</code></pre> <p>Implement a decorator to execute a function only if <code>tqdm</code> package is installed.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[..., Any]</code> <p>Specifies the function to execute.</p> required <p>Returns:</p> Type Description <code>Callable[..., Any]</code> <p>A wrapper around <code>fn</code> if <code>tqdm</code> package is installed, otherwise <code>None</code>.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.imports import tqdm_available\n&gt;&gt;&gt; @tqdm_available\n... def my_function(n: int = 0) -&gt; int:\n...     return 42 + n\n...\n&gt;&gt;&gt; my_function()\n</code></pre>"},{"location":"refs/utils/#grizz.utils.interval","title":"grizz.utils.interval","text":"<p>Contain interval utility functions.</p>"},{"location":"refs/utils/#grizz.utils.interval.find_time_unit","title":"grizz.utils.interval.find_time_unit","text":"<pre><code>find_time_unit(interval: str) -&gt; str\n</code></pre> <p>Find the time unit associated to a <code>polars</code> interval.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>str</code> <p>The <code>polars</code> interval to analyze.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The found time unit.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if no valid time unit can be found.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.interval import find_time_unit\n&gt;&gt;&gt; find_time_unit(\"3d12h4m\")\nm\n&gt;&gt;&gt; find_time_unit(\"3y5mo\")\nmo\n</code></pre>"},{"location":"refs/utils/#grizz.utils.interval.interval_to_strftime_format","title":"grizz.utils.interval.interval_to_strftime_format","text":"<pre><code>interval_to_strftime_format(interval: str) -&gt; str\n</code></pre> <p>Return the default strftime format for a given interval.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>str</code> <p>The <code>polars</code> interval to analyze.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The default strftime format.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.interval import interval_to_strftime_format\n&gt;&gt;&gt; interval_to_strftime_format(\"1h\")\n%Y-%m-%d %H:%M\n&gt;&gt;&gt; interval_to_strftime_format(\"3y1mo\")\n%Y-%m\n</code></pre>"},{"location":"refs/utils/#grizz.utils.interval.interval_to_timedelta","title":"grizz.utils.interval.interval_to_timedelta","text":"<pre><code>interval_to_timedelta(interval: str) -&gt; timedelta\n</code></pre> <p>Convert a interval to a timedelta object.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>str</code> <p>The input interval.</p> required <p>Returns:</p> Type Description <code>timedelta</code> <p>The timedelta object generated from the interval.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.interval import interval_to_timedelta\n&gt;&gt;&gt; interval_to_timedelta(\"5d1h42m\")\ndatetime.timedelta(days=5, seconds=6120)\n</code></pre>"},{"location":"refs/utils/#grizz.utils.interval.time_unit_to_strftime_format","title":"grizz.utils.interval.time_unit_to_strftime_format","text":"<pre><code>time_unit_to_strftime_format(time_unit: str) -&gt; str\n</code></pre> <p>Return the default strftime format for a given time unit.</p> <p>Parameters:</p> Name Type Description Default <code>time_unit</code> <code>str</code> <p>The time unit.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The default strftime format.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.interval import time_unit_to_strftime_format\n&gt;&gt;&gt; time_unit_to_strftime_format(\"h\")\n%Y-%m-%d %H:%M\n&gt;&gt;&gt; time_unit_to_strftime_format(\"mo\")\n%Y-%m\n</code></pre>"},{"location":"refs/utils/#grizz.utils.logging","title":"grizz.utils.logging","text":"<p>Contain utility functions to configure the standard logging library.</p>"},{"location":"refs/utils/#grizz.utils.logging.configure_logging","title":"grizz.utils.logging.configure_logging","text":"<pre><code>configure_logging(level: int = INFO) -&gt; None\n</code></pre> <p>Configure the logging module with a colored formatter.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>The lower level.</p> <code>INFO</code>"},{"location":"refs/utils/#grizz.utils.nan","title":"grizz.utils.nan","text":"<p>Contain utility functions to transform data with NaNs.</p>"},{"location":"refs/utils/#grizz.utils.nan.LowNaN","title":"grizz.utils.nan.LowNaN","text":"<p>               Bases: <code>float</code></p> <p>Implement a NaN representation that is always lower than other numbers.</p> <p>This class is designed to be used to compare numbers with NaN values and should not be used in other cases.</p> <p>https://docs.python.org/3/library/functions.html#sorted</p>"},{"location":"refs/utils/#grizz.utils.nan.remove_nan","title":"grizz.utils.nan.remove_nan","text":"<pre><code>remove_nan(data: T) -&gt; T\n</code></pre> <p>Remove the NaN values from the input sequence.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>T</code> <p>The input sequence.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The input sequence without NaN values.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.nan import remove_nan\n&gt;&gt;&gt; data = [float(\"nan\"), float(\"-inf\"), -2, 1.2]\n&gt;&gt;&gt; remove_nan(data)\n[-inf, -2, 1.2]\n</code></pre>"},{"location":"refs/utils/#grizz.utils.nan.sortnan","title":"grizz.utils.nan.sortnan","text":"<pre><code>sortnan(\n    iterable: Iterable[bool | float],\n    /,\n    *,\n    reverse: bool = False,\n) -&gt; list[bool | float]\n</code></pre> <p>Sort a sequence of numeric values with NaN.</p> <p>This function is an extension of the built-in <code>sorted</code> function. It sees NaN values as equivalent to -infinity when the values are sorted.</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>Iterable[bool | float]</code> <p>The numeric values to sort.</p> required <code>reverse</code> <code>bool</code> <p>If set to <code>True</code>, then the list elements are sorted as if each comparison were reversed.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[bool | float]</code> <p>The sorted list.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.nan import sortnan\n&gt;&gt;&gt; x = [4, float(\"nan\"), 2, 1.2, 7.9, -2]\n&gt;&gt;&gt; sorted(x)\n[4, nan, -2, 1.2, 2, 7.9]\n&gt;&gt;&gt; sortnan(x)\n[nan, -2, 1.2, 2, 4, 7.9]\n&gt;&gt;&gt; sortnan(x, reverse=True)\n[7.9, 4, 2, 1.2, -2, nan]\n</code></pre>"},{"location":"refs/utils/#grizz.utils.noop","title":"grizz.utils.noop","text":"<p>Contain no-op functions.</p>"},{"location":"refs/utils/#grizz.utils.noop.tqdm","title":"grizz.utils.noop.tqdm","text":"<pre><code>tqdm(\n    iterable: Iterable, *args: Any, **kwargs: Any\n) -&gt; Iterable\n</code></pre> <p>Implement a no-op tqdm progressbar that is used when tqdm is not installed.</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>Iterable</code> <p>Iterable to decorate with a progressbar.</p> required <code>*args</code> <code>Any</code> <p>Positional arbitrary arguments.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arbitrary arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Iterable</code> <p>The input iterable.</p>"},{"location":"refs/utils/#grizz.utils.null","title":"grizz.utils.null","text":"<p>Contain utility functions to manipulate null values in DataFrames.</p>"},{"location":"refs/utils/#grizz.utils.null.compute_null","title":"grizz.utils.null.compute_null","text":"<pre><code>compute_null(frame: DataFrame) -&gt; DataFrame\n</code></pre> <p>Return the number and percentage of null values per column.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>A DataFrame with the number and percentage of null values per column.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.utils.null import compute_null\n&gt;&gt;&gt; frame = compute_null(\n...     pl.DataFrame(\n...         {\n...             \"int\": [None, 1, 0, 1],\n...             \"float\": [1.2, 4.2, None, 2.2],\n...             \"str\": [\"A\", \"B\", None, None],\n...         },\n...         schema={\"int\": pl.Int64, \"float\": pl.Float64, \"str\": pl.String},\n...     )\n... )\n&gt;&gt;&gt; frame\nshape: (3, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 column \u2506 null \u2506 total \u2506 null_pct \u2502\n\u2502 ---    \u2506 ---  \u2506 ---   \u2506 ---      \u2502\n\u2502 str    \u2506 i64  \u2506 i64   \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 int    \u2506 1    \u2506 4     \u2506 0.25     \u2502\n\u2502 float  \u2506 1    \u2506 4     \u2506 0.25     \u2502\n\u2502 str    \u2506 2    \u2506 4     \u2506 0.5      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/utils/#grizz.utils.null.compute_null_count","title":"grizz.utils.null.compute_null_count","text":"<pre><code>compute_null_count(frame: DataFrame) -&gt; ndarray\n</code></pre> <p>Return the number of null values in each column.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>An array with the number of null values in each column. The shape of the array is the number of columns.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.utils.null import compute_null_count\n&gt;&gt;&gt; frame = pl.DataFrame(\n...     {\n...         \"int\": [None, 1, 0, 1],\n...         \"float\": [1.2, 4.2, None, 2.2],\n...         \"str\": [\"A\", \"B\", None, None],\n...     },\n...     schema={\"int\": pl.Int64, \"float\": pl.Float64, \"str\": pl.String},\n... )\n&gt;&gt;&gt; count = compute_null_count(frame)\n&gt;&gt;&gt; count\narray([1, 1, 2])\n</code></pre>"},{"location":"refs/utils/#grizz.utils.null.compute_temporal_null_count","title":"grizz.utils.null.compute_temporal_null_count","text":"<pre><code>compute_temporal_null_count(\n    frame: DataFrame,\n    columns: Sequence[str],\n    temporal_column: str,\n    period: str,\n) -&gt; tuple[ndarray, ndarray, list]\n</code></pre> <p>Compute the number of null values per temporal segments.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>columns</code> <code>Sequence[str]</code> <p>The list of columns to analyze.</p> required <code>temporal_column</code> <code>str</code> <p>The temporal column used to analyze the temporal distribution.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <p>Returns:</p> Type Description <code>tuple[ndarray, ndarray, list]</code> <p>A tuple with 3 values. The first value is a numpy NDArray that contains the number of null values per period. The second value is a numpy NDArray that contains the total number of values. The third value is a list that contains the label of each period.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.utils.null import compute_temporal_null_count\n&gt;&gt;&gt; nulls, totals, labels = compute_temporal_null_count(\n...     frame=pl.DataFrame(\n...         {\n...             \"col1\": [None, float(\"nan\"), 0.0, 1.0],\n...             \"col2\": [None, 1, 0, None],\n...             \"datetime\": [\n...                 datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...             ],\n...         },\n...         schema={\n...             \"col1\": pl.Float64,\n...             \"col2\": pl.Int64,\n...             \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...         },\n...     ),\n...     columns=[\"col1\", \"col2\"],\n...     temporal_column=\"datetime\",\n...     period=\"1mo\",\n... )\n&gt;&gt;&gt; nulls\narray([2, 0, 0, 1])\n&gt;&gt;&gt; totals\narray([2, 2, 2, 2])\n&gt;&gt;&gt; labels\n['2020-01', '2020-02', '2020-03', '2020-04']\n</code></pre>"},{"location":"refs/utils/#grizz.utils.null.propagate_nulls","title":"grizz.utils.null.propagate_nulls","text":"<pre><code>propagate_nulls(\n    frame: DataFrame, frame_with_null: DataFrame\n) -&gt; DataFrame\n</code></pre> <p>Propagate the null values from <code>frame_with_null</code> to <code>frame</code>.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The input DataFrame where to add <code>None</code> values based on <code>frame_with_null</code>.</p> required <code>frame_with_null</code> <code>DataFrame</code> <p>The DataFrame with the <code>None</code> values to propagate to <code>frame</code>.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>The output DataFrame.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.utils.null import propagate_nulls\n&gt;&gt;&gt; frame_with_null = pl.DataFrame(\n...     {\n...         \"col1\": [1, None, 3, float(\"nan\"), 5],\n...         \"col2\": [\"1\", \"2\", None, \"4\", \"5\"],\n...         \"col3\": [10, 20, 30, None, 50],\n...     },\n...     schema={\"col1\": pl.Float32, \"col2\": pl.String, \"col3\": pl.Int64},\n... )\n&gt;&gt;&gt; frame = frame_with_null.fill_null(99).fill_nan(99)\n&gt;&gt;&gt; frame\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 f32  \u2506 str  \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0  \u2506 1    \u2506 10   \u2502\n\u2502 99.0 \u2506 2    \u2506 20   \u2502\n\u2502 3.0  \u2506 null \u2506 30   \u2502\n\u2502 99.0 \u2506 4    \u2506 99   \u2502\n\u2502 5.0  \u2506 5    \u2506 50   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; out = propagate_nulls(frame=frame, frame_with_null=frame_with_null)\n&gt;&gt;&gt; out\nshape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 col3 \u2502\n\u2502 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 f32  \u2506 str  \u2506 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0  \u2506 1    \u2506 10   \u2502\n\u2502 null \u2506 2    \u2506 20   \u2502\n\u2502 3.0  \u2506 null \u2506 30   \u2502\n\u2502 99.0 \u2506 4    \u2506 null \u2502\n\u2502 5.0  \u2506 5    \u2506 50   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/utils/#grizz.utils.path","title":"grizz.utils.path","text":"<p>Contain utility functions to manage paths.</p>"},{"location":"refs/utils/#grizz.utils.path.find_files","title":"grizz.utils.path.find_files","text":"<pre><code>find_files(\n    path: Path | str,\n    filter_fn: Callable[[Path], bool],\n    recursive: bool = True,\n) -&gt; list[Path]\n</code></pre> <p>Find the path of all the tar files in a given path.</p> <p>This function does not check if a path is a symbolic link so be careful if you are using a path with symbolic links.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The path where to look for the parquet files.</p> required <code>filter_fn</code> <code>Callable[[Path], bool]</code> <p>The path filtering function. The function should return <code>True</code> for the path to find, and <code>False</code> otherwise.</p> required <code>recursive</code> <code>bool</code> <p>Indicate if it should also check the sub-folders.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[Path]</code> <p>The tuple of path of parquet files.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from grizz.utils.path import find_files\n&gt;&gt;&gt; find_files(Path(\"something\"), filter_fn=lambda path: path.name.endswith(\".txt\"))\n[...]\n</code></pre>"},{"location":"refs/utils/#grizz.utils.path.find_parquet_files","title":"grizz.utils.path.find_parquet_files","text":"<pre><code>find_parquet_files(\n    path: Path | str, recursive: bool = True\n) -&gt; list[Path]\n</code></pre> <p>Find the path of all the parquet files in a given path.</p> <p>This function does not check if a path is a symbolic link so be careful if you are using a path with symbolic links.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The path where to look for the parquet files.</p> required <code>recursive</code> <code>bool</code> <p>Specifies if it should also check the sub-folders.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[Path]</code> <p>The list of parquet files.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from grizz.utils.path import find_parquet_files\n&gt;&gt;&gt; find_parquet_files(Path(\"something\"))\n[...]\n</code></pre>"},{"location":"refs/utils/#grizz.utils.path.human_file_size","title":"grizz.utils.path.human_file_size","text":"<pre><code>human_file_size(path: Path | str, decimal: int = 2) -&gt; str\n</code></pre> <p>Get a human-readable representation of a file size.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The path to the file.</p> required <code>decimal</code> <code>int</code> <p>The number of decimal digits.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>The file size in a human-readable format.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.path import human_file_size\n&gt;&gt;&gt; human_file_size(\"README.md\")\n'...B'\n</code></pre>"},{"location":"refs/utils/#grizz.utils.path.sanitize_path","title":"grizz.utils.path.sanitize_path","text":"<pre><code>sanitize_path(path: Path | str) -&gt; Path\n</code></pre> <p>Sanitize a given path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The path to sanitize.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>The sanitized path.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from grizz.utils.path import sanitize_path\n&gt;&gt;&gt; sanitize_path(\"something\")\nPosixPath('.../something')\n&gt;&gt;&gt; sanitize_path(\"\")\nPosixPath('...')\n&gt;&gt;&gt; sanitize_path(Path(\"something\"))\nPosixPath('.../something')\n&gt;&gt;&gt; sanitize_path(Path(\"something/./../\"))\nPosixPath('...')\n</code></pre>"},{"location":"refs/utils/#grizz.utils.series","title":"grizz.utils.series","text":"<p>Contain utility functions for series.</p>"},{"location":"refs/utils/#grizz.utils.series.compute_stats_boolean","title":"grizz.utils.series.compute_stats_boolean","text":"<pre><code>compute_stats_boolean(series: Series) -&gt; dict[str, float]\n</code></pre> <p>Compute some basic statistics about a Boolean series.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>Series</code> <p>The series to analyze.</p> required <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>The statistics about the input Boolean series.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>series</code> is not a Boolean series.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.utils.series import compute_stats_boolean\n&gt;&gt;&gt; series = pl.Series([True, False, None, None, False, None])\n&gt;&gt;&gt; compute_stats_boolean(series)\n{'num_false': 2, 'num_null': 3, 'num_true': 1, 'total': 6}\n</code></pre>"},{"location":"refs/utils/#grizz.utils.sorting","title":"grizz.utils.sorting","text":"<p>Contain utility functions to sort values from multiple types.</p>"},{"location":"refs/utils/#grizz.utils.sorting.mixed_typed_sort","title":"grizz.utils.sorting.mixed_typed_sort","text":"<pre><code>mixed_typed_sort(\n    iterable: Iterable, /, *, reverse: bool = False\n) -&gt; list\n</code></pre> <p>Return a new list containing all items from the iterable sorted in ascending order.</p> <p>This function is an extension of the built-in <code>sorted</code> function that works on a list with multiple types. There is no global order for all types, so the items are sorted only by type. For example, if a list has string and float values, the string values are sorted together and the float values are sorted together. Each type must implement the python sorting interface. The types are sorted by alphabetical order, so in the previous example, the float values are before the string values in the sorted output list. This function uses <code>sortnan</code> to sort numerical values, so it is possible to sort a list with NaNs.</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>Iterable</code> <p>The data to sort.</p> required <code>reverse</code> <code>bool</code> <p>If set to <code>True</code>, then the list elements are sorted as if each comparison were reversed.</p> <code>False</code> <p>Returns:</p> Type Description <code>list</code> <p>The sorted data.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from grizz.utils.sorting import mixed_typed_sort\n&gt;&gt;&gt; x = [1, \"c\", \"a\", \"b\", 4, -2]\n&gt;&gt;&gt; mixed_typed_sort(x)\n[-2, 1, 4, 'a', 'b', 'c']\n&gt;&gt;&gt; mixed_typed_sort(x, reverse=True)\n[4, 1, -2, 'c', 'b', 'a']\n</code></pre>"},{"location":"refs/utils/#grizz.utils.temporal","title":"grizz.utils.temporal","text":"<p>Contain utility functions to do temporal transformations.</p>"},{"location":"refs/utils/#grizz.utils.temporal.compute_temporal_stats","title":"grizz.utils.temporal.compute_temporal_stats","text":"<pre><code>compute_temporal_stats(\n    frame: DataFrame,\n    column: str,\n    temporal_column: str,\n    period: str,\n) -&gt; DataFrame\n</code></pre> <p>Return a DataFrame with stats for each temporal window.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>column</code> <code>str</code> <p>The column to analyze.</p> required <code>temporal_column</code> <code>str</code> <p>The temporal column used to create the temporal DataFrames.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>A DataFrame with stats for each temporal window.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.utils.temporal import compute_temporal_stats\n&gt;&gt;&gt; stats = compute_temporal_stats(\n...     frame=pl.DataFrame(\n...         {\n...             \"col\": [1.2, 4.2, 0.0, 1.0, 4.2, 42.0],\n...             \"datetime\": [\n...                 datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=1, day=4, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=1, day=5, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...             ],\n...         },\n...         schema={\n...             \"col\": pl.Float64,\n...             \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...         },\n...     ),\n...     column=\"col\",\n...     temporal_column=\"datetime\",\n...     period=\"1mo\",\n... )\n&gt;&gt;&gt; stats\nshape: (4, 16)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 step                    \u2506 count \u2506 nunique \u2506 mean \u2506 \u2026 \u2506 q90  \u2506 q95  \u2506 q99  \u2506 max  \u2502\n\u2502 ---                     \u2506 ---   \u2506 ---     \u2506 ---  \u2506   \u2506 ---  \u2506 ---  \u2506 ---  \u2506 ---  \u2502\n\u2502 datetime[\u03bcs, UTC]       \u2506 i64   \u2506 i64     \u2506 f64  \u2506   \u2506 f64  \u2506 f64  \u2506 f64  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-01-01 00:00:00 UTC \u2506 3     \u2506 3       \u2506 1.8  \u2506 \u2026 \u2506 4.2  \u2506 4.2  \u2506 4.2  \u2506 4.2  \u2502\n\u2502 2020-02-01 00:00:00 UTC \u2506 1     \u2506 1       \u2506 1.0  \u2506 \u2026 \u2506 1.0  \u2506 1.0  \u2506 1.0  \u2506 1.0  \u2502\n\u2502 2020-03-01 00:00:00 UTC \u2506 1     \u2506 1       \u2506 4.2  \u2506 \u2026 \u2506 4.2  \u2506 4.2  \u2506 4.2  \u2506 4.2  \u2502\n\u2502 2020-04-01 00:00:00 UTC \u2506 1     \u2506 1       \u2506 42.0 \u2506 \u2026 \u2506 42.0 \u2506 42.0 \u2506 42.0 \u2506 42.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"refs/utils/#grizz.utils.temporal.to_step_names","title":"grizz.utils.temporal.to_step_names","text":"<pre><code>to_step_names(groups: GroupBy, period: str) -&gt; list[str]\n</code></pre> <p>Return the name of each step.</p> <p>Parameters:</p> Name Type Description Default <code>groups</code> <code>GroupBy</code> <p>The grouped DataFrame by step.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A list that contains the name of each step.</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.utils.temporal import to_step_names\n&gt;&gt;&gt; groups = (\n...     pl.DataFrame(\n...         {\n...             \"col\": [0.0, 1.0, 2.0, 3.0, 4.0, 5.0],\n...             \"datetime\": [\n...                 datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=1, day=4, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=1, day=5, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...             ],\n...         },\n...         schema={\n...             \"col\": pl.Float64,\n...             \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...         },\n...     )\n...     .sort(\"datetime\")\n...     .group_by_dynamic(\"datetime\", every=\"1mo\")\n... )\n&gt;&gt;&gt; steps = to_step_names(groups=groups, period=\"1mo\")\n&gt;&gt;&gt; steps\n['2020-01', '2020-02', '2020-03', '2020-04']\n</code></pre>"},{"location":"refs/utils/#grizz.utils.temporal.to_temporal_frames","title":"grizz.utils.temporal.to_temporal_frames","text":"<pre><code>to_temporal_frames(\n    frame: DataFrame, temporal_column: str, period: str\n) -&gt; tuple[list[DataFrame], list[str]]\n</code></pre> <p>Return a list of temporal DataFrames and the associated time steps.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>DataFrame</code> <p>The DataFrame to analyze.</p> required <code>temporal_column</code> <code>str</code> <p>The temporal column used to create the temporal DataFrames.</p> required <code>period</code> <code>str</code> <p>The temporal period e.g. monthly or daily.</p> required <p>Returns:</p> Type Description <code>tuple[list[DataFrame], list[str]]</code> <p>A tuple with the counts and the temporal steps.</p> <p>Example usage:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from grizz.utils.temporal import to_temporal_frames\n&gt;&gt;&gt; frames, steps = to_temporal_frames(\n...     frame=pl.DataFrame(\n...         {\n...             \"col1\": [None, float(\"nan\"), 0.0, 1.0, 4.2, 42.0],\n...             \"col2\": [None, 1, 0, None, 2, 3],\n...             \"datetime\": [\n...                 datetime(year=2020, month=1, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=1, day=4, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=1, day=5, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=2, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=3, day=3, tzinfo=timezone.utc),\n...                 datetime(year=2020, month=4, day=3, tzinfo=timezone.utc),\n...             ],\n...         },\n...         schema={\n...             \"col1\": pl.Float64,\n...             \"col2\": pl.Int64,\n...             \"datetime\": pl.Datetime(time_unit=\"us\", time_zone=\"UTC\"),\n...         },\n...     ),\n...     temporal_column=\"datetime\",\n...     period=\"1mo\",\n... )\n&gt;&gt;&gt; frames\n[shape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 datetime                \u2502\n\u2502 ---  \u2506 ---  \u2506 ---                     \u2502\n\u2502 f64  \u2506 i64  \u2506 datetime[\u03bcs, UTC]       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 null \u2506 null \u2506 2020-01-03 00:00:00 UTC \u2502\n\u2502 NaN  \u2506 1    \u2506 2020-01-04 00:00:00 UTC \u2502\n\u2502 0.0  \u2506 0    \u2506 2020-01-05 00:00:00 UTC \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518, shape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 datetime                \u2502\n\u2502 ---  \u2506 ---  \u2506 ---                     \u2502\n\u2502 f64  \u2506 i64  \u2506 datetime[\u03bcs, UTC]       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0  \u2506 null \u2506 2020-02-03 00:00:00 UTC \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518, shape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 datetime                \u2502\n\u2502 ---  \u2506 ---  \u2506 ---                     \u2502\n\u2502 f64  \u2506 i64  \u2506 datetime[\u03bcs, UTC]       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 4.2  \u2506 2    \u2506 2020-03-03 00:00:00 UTC \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518, shape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col2 \u2506 datetime                \u2502\n\u2502 ---  \u2506 ---  \u2506 ---                     \u2502\n\u2502 f64  \u2506 i64  \u2506 datetime[\u03bcs, UTC]       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 42.0 \u2506 3    \u2506 2020-04-03 00:00:00 UTC \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518]\n&gt;&gt;&gt; steps\n['2020-01', '2020-02', '2020-03', '2020-04']\n</code></pre>"}]}